
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model College
 * 
 */
export type College = $Result.DefaultSelection<Prisma.$CollegePayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserRoleAssignment
 * 
 */
export type UserRoleAssignment = $Result.DefaultSelection<Prisma.$UserRoleAssignmentPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model DepartmentElectiveGroup
 * 
 */
export type DepartmentElectiveGroup = $Result.DefaultSelection<Prisma.$DepartmentElectiveGroupPayload>
/**
 * Model CourseElectiveGroupMember
 * 
 */
export type CourseElectiveGroupMember = $Result.DefaultSelection<Prisma.$CourseElectiveGroupMemberPayload>
/**
 * Model OpenElectiveRestriction
 * 
 */
export type OpenElectiveRestriction = $Result.DefaultSelection<Prisma.$OpenElectiveRestrictionPayload>
/**
 * Model CourseOffering
 * 
 */
export type CourseOffering = $Result.DefaultSelection<Prisma.$CourseOfferingPayload>
/**
 * Model StudentEnrollment
 * 
 */
export type StudentEnrollment = $Result.DefaultSelection<Prisma.$StudentEnrollmentPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model AttendanceRecord
 * 
 */
export type AttendanceRecord = $Result.DefaultSelection<Prisma.$AttendanceRecordPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model ReportViewer
 * 
 */
export type ReportViewer = $Result.DefaultSelection<Prisma.$ReportViewerPayload>
/**
 * Model academic_years
 * 
 */
export type academic_years = $Result.DefaultSelection<Prisma.$academic_yearsPayload>
/**
 * Model sections
 * 
 */
export type sections = $Result.DefaultSelection<Prisma.$sectionsPayload>
/**
 * Model TestComponent
 * 
 */
export type TestComponent = $Result.DefaultSelection<Prisma.$TestComponentPayload>
/**
 * Model StudentMark
 * 
 */
export type StudentMark = $Result.DefaultSelection<Prisma.$StudentMarkPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const attendance_status: {
  present: 'present',
  absent: 'absent',
  not: 'not'
};

export type attendance_status = (typeof attendance_status)[keyof typeof attendance_status]


export const course_type: {
  core: 'core',
  department_elective: 'department_elective',
  open_elective: 'open_elective'
};

export type course_type = (typeof course_type)[keyof typeof course_type]


export const user_role: {
  student: 'student',
  teacher: 'teacher',
  admin: 'admin',
  report_viewer: 'report_viewer'
};

export type user_role = (typeof user_role)[keyof typeof user_role]

}

export type attendance_status = $Enums.attendance_status

export const attendance_status: typeof $Enums.attendance_status

export type course_type = $Enums.course_type

export const course_type: typeof $Enums.course_type

export type user_role = $Enums.user_role

export const user_role: typeof $Enums.user_role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Colleges
 * const colleges = await prisma.college.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Colleges
   * const colleges = await prisma.college.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.college`: Exposes CRUD operations for the **College** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Colleges
    * const colleges = await prisma.college.findMany()
    * ```
    */
  get college(): Prisma.CollegeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRoleAssignment`: Exposes CRUD operations for the **UserRoleAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoleAssignments
    * const userRoleAssignments = await prisma.userRoleAssignment.findMany()
    * ```
    */
  get userRoleAssignment(): Prisma.UserRoleAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departmentElectiveGroup`: Exposes CRUD operations for the **DepartmentElectiveGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentElectiveGroups
    * const departmentElectiveGroups = await prisma.departmentElectiveGroup.findMany()
    * ```
    */
  get departmentElectiveGroup(): Prisma.DepartmentElectiveGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseElectiveGroupMember`: Exposes CRUD operations for the **CourseElectiveGroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseElectiveGroupMembers
    * const courseElectiveGroupMembers = await prisma.courseElectiveGroupMember.findMany()
    * ```
    */
  get courseElectiveGroupMember(): Prisma.CourseElectiveGroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.openElectiveRestriction`: Exposes CRUD operations for the **OpenElectiveRestriction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenElectiveRestrictions
    * const openElectiveRestrictions = await prisma.openElectiveRestriction.findMany()
    * ```
    */
  get openElectiveRestriction(): Prisma.OpenElectiveRestrictionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseOffering`: Exposes CRUD operations for the **CourseOffering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseOfferings
    * const courseOfferings = await prisma.courseOffering.findMany()
    * ```
    */
  get courseOffering(): Prisma.CourseOfferingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentEnrollment`: Exposes CRUD operations for the **StudentEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEnrollments
    * const studentEnrollments = await prisma.studentEnrollment.findMany()
    * ```
    */
  get studentEnrollment(): Prisma.StudentEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceRecord`: Exposes CRUD operations for the **AttendanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceRecords
    * const attendanceRecords = await prisma.attendanceRecord.findMany()
    * ```
    */
  get attendanceRecord(): Prisma.AttendanceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportViewer`: Exposes CRUD operations for the **ReportViewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportViewers
    * const reportViewers = await prisma.reportViewer.findMany()
    * ```
    */
  get reportViewer(): Prisma.ReportViewerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academic_years`: Exposes CRUD operations for the **academic_years** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Academic_years
    * const academic_years = await prisma.academic_years.findMany()
    * ```
    */
  get academic_years(): Prisma.academic_yearsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sections`: Exposes CRUD operations for the **sections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.sections.findMany()
    * ```
    */
  get sections(): Prisma.sectionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testComponent`: Exposes CRUD operations for the **TestComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestComponents
    * const testComponents = await prisma.testComponent.findMany()
    * ```
    */
  get testComponent(): Prisma.TestComponentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentMark`: Exposes CRUD operations for the **StudentMark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentMarks
    * const studentMarks = await prisma.studentMark.findMany()
    * ```
    */
  get studentMark(): Prisma.StudentMarkDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    College: 'College',
    Department: 'Department',
    User: 'User',
    UserRoleAssignment: 'UserRoleAssignment',
    Student: 'Student',
    Teacher: 'Teacher',
    Course: 'Course',
    DepartmentElectiveGroup: 'DepartmentElectiveGroup',
    CourseElectiveGroupMember: 'CourseElectiveGroupMember',
    OpenElectiveRestriction: 'OpenElectiveRestriction',
    CourseOffering: 'CourseOffering',
    StudentEnrollment: 'StudentEnrollment',
    Attendance: 'Attendance',
    AttendanceRecord: 'AttendanceRecord',
    Admin: 'Admin',
    ReportViewer: 'ReportViewer',
    academic_years: 'academic_years',
    sections: 'sections',
    TestComponent: 'TestComponent',
    StudentMark: 'StudentMark'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "college" | "department" | "user" | "userRoleAssignment" | "student" | "teacher" | "course" | "departmentElectiveGroup" | "courseElectiveGroupMember" | "openElectiveRestriction" | "courseOffering" | "studentEnrollment" | "attendance" | "attendanceRecord" | "admin" | "reportViewer" | "academic_years" | "sections" | "testComponent" | "studentMark"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      College: {
        payload: Prisma.$CollegePayload<ExtArgs>
        fields: Prisma.CollegeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollegeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollegeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload>
          }
          findFirst: {
            args: Prisma.CollegeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollegeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload>
          }
          findMany: {
            args: Prisma.CollegeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload>[]
          }
          create: {
            args: Prisma.CollegeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload>
          }
          createMany: {
            args: Prisma.CollegeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollegeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload>[]
          }
          delete: {
            args: Prisma.CollegeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload>
          }
          update: {
            args: Prisma.CollegeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload>
          }
          deleteMany: {
            args: Prisma.CollegeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollegeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollegeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload>[]
          }
          upsert: {
            args: Prisma.CollegeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollegePayload>
          }
          aggregate: {
            args: Prisma.CollegeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollege>
          }
          groupBy: {
            args: Prisma.CollegeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollegeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollegeCountArgs<ExtArgs>
            result: $Utils.Optional<CollegeCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserRoleAssignment: {
        payload: Prisma.$UserRoleAssignmentPayload<ExtArgs>
        fields: Prisma.UserRoleAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          findFirst: {
            args: Prisma.UserRoleAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          findMany: {
            args: Prisma.UserRoleAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>[]
          }
          create: {
            args: Prisma.UserRoleAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          createMany: {
            args: Prisma.UserRoleAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>[]
          }
          delete: {
            args: Prisma.UserRoleAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          update: {
            args: Prisma.UserRoleAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.UserRoleAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.UserRoleAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          aggregate: {
            args: Prisma.UserRoleAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRoleAssignment>
          }
          groupBy: {
            args: Prisma.UserRoleAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      DepartmentElectiveGroup: {
        payload: Prisma.$DepartmentElectiveGroupPayload<ExtArgs>
        fields: Prisma.DepartmentElectiveGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentElectiveGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentElectiveGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload>
          }
          findFirst: {
            args: Prisma.DepartmentElectiveGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentElectiveGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload>
          }
          findMany: {
            args: Prisma.DepartmentElectiveGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload>[]
          }
          create: {
            args: Prisma.DepartmentElectiveGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload>
          }
          createMany: {
            args: Prisma.DepartmentElectiveGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentElectiveGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload>[]
          }
          delete: {
            args: Prisma.DepartmentElectiveGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload>
          }
          update: {
            args: Prisma.DepartmentElectiveGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentElectiveGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentElectiveGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentElectiveGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentElectiveGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentElectiveGroupPayload>
          }
          aggregate: {
            args: Prisma.DepartmentElectiveGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentElectiveGroup>
          }
          groupBy: {
            args: Prisma.DepartmentElectiveGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentElectiveGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentElectiveGroupCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentElectiveGroupCountAggregateOutputType> | number
          }
        }
      }
      CourseElectiveGroupMember: {
        payload: Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>
        fields: Prisma.CourseElectiveGroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseElectiveGroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseElectiveGroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload>
          }
          findFirst: {
            args: Prisma.CourseElectiveGroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseElectiveGroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload>
          }
          findMany: {
            args: Prisma.CourseElectiveGroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload>[]
          }
          create: {
            args: Prisma.CourseElectiveGroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload>
          }
          createMany: {
            args: Prisma.CourseElectiveGroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseElectiveGroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload>[]
          }
          delete: {
            args: Prisma.CourseElectiveGroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload>
          }
          update: {
            args: Prisma.CourseElectiveGroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.CourseElectiveGroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseElectiveGroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseElectiveGroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.CourseElectiveGroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseElectiveGroupMemberPayload>
          }
          aggregate: {
            args: Prisma.CourseElectiveGroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseElectiveGroupMember>
          }
          groupBy: {
            args: Prisma.CourseElectiveGroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseElectiveGroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseElectiveGroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<CourseElectiveGroupMemberCountAggregateOutputType> | number
          }
        }
      }
      OpenElectiveRestriction: {
        payload: Prisma.$OpenElectiveRestrictionPayload<ExtArgs>
        fields: Prisma.OpenElectiveRestrictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenElectiveRestrictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenElectiveRestrictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload>
          }
          findFirst: {
            args: Prisma.OpenElectiveRestrictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenElectiveRestrictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload>
          }
          findMany: {
            args: Prisma.OpenElectiveRestrictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload>[]
          }
          create: {
            args: Prisma.OpenElectiveRestrictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload>
          }
          createMany: {
            args: Prisma.OpenElectiveRestrictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpenElectiveRestrictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload>[]
          }
          delete: {
            args: Prisma.OpenElectiveRestrictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload>
          }
          update: {
            args: Prisma.OpenElectiveRestrictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload>
          }
          deleteMany: {
            args: Prisma.OpenElectiveRestrictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenElectiveRestrictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpenElectiveRestrictionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload>[]
          }
          upsert: {
            args: Prisma.OpenElectiveRestrictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenElectiveRestrictionPayload>
          }
          aggregate: {
            args: Prisma.OpenElectiveRestrictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenElectiveRestriction>
          }
          groupBy: {
            args: Prisma.OpenElectiveRestrictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenElectiveRestrictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenElectiveRestrictionCountArgs<ExtArgs>
            result: $Utils.Optional<OpenElectiveRestrictionCountAggregateOutputType> | number
          }
        }
      }
      CourseOffering: {
        payload: Prisma.$CourseOfferingPayload<ExtArgs>
        fields: Prisma.CourseOfferingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseOfferingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseOfferingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          findFirst: {
            args: Prisma.CourseOfferingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseOfferingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          findMany: {
            args: Prisma.CourseOfferingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>[]
          }
          create: {
            args: Prisma.CourseOfferingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          createMany: {
            args: Prisma.CourseOfferingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseOfferingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>[]
          }
          delete: {
            args: Prisma.CourseOfferingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          update: {
            args: Prisma.CourseOfferingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          deleteMany: {
            args: Prisma.CourseOfferingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseOfferingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseOfferingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>[]
          }
          upsert: {
            args: Prisma.CourseOfferingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          aggregate: {
            args: Prisma.CourseOfferingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseOffering>
          }
          groupBy: {
            args: Prisma.CourseOfferingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseOfferingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseOfferingCountArgs<ExtArgs>
            result: $Utils.Optional<CourseOfferingCountAggregateOutputType> | number
          }
        }
      }
      StudentEnrollment: {
        payload: Prisma.$StudentEnrollmentPayload<ExtArgs>
        fields: Prisma.StudentEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.StudentEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          findMany: {
            args: Prisma.StudentEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>[]
          }
          create: {
            args: Prisma.StudentEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          createMany: {
            args: Prisma.StudentEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.StudentEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          update: {
            args: Prisma.StudentEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.StudentEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentEnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.StudentEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.StudentEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentEnrollment>
          }
          groupBy: {
            args: Prisma.StudentEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      AttendanceRecord: {
        payload: Prisma.$AttendanceRecordPayload<ExtArgs>
        fields: Prisma.AttendanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findFirst: {
            args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findMany: {
            args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          create: {
            args: Prisma.AttendanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          createMany: {
            args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          delete: {
            args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          update: {
            args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          aggregate: {
            args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceRecord>
          }
          groupBy: {
            args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      ReportViewer: {
        payload: Prisma.$ReportViewerPayload<ExtArgs>
        fields: Prisma.ReportViewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportViewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportViewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload>
          }
          findFirst: {
            args: Prisma.ReportViewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportViewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload>
          }
          findMany: {
            args: Prisma.ReportViewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload>[]
          }
          create: {
            args: Prisma.ReportViewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload>
          }
          createMany: {
            args: Prisma.ReportViewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportViewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload>[]
          }
          delete: {
            args: Prisma.ReportViewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload>
          }
          update: {
            args: Prisma.ReportViewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload>
          }
          deleteMany: {
            args: Prisma.ReportViewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportViewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportViewerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload>[]
          }
          upsert: {
            args: Prisma.ReportViewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportViewerPayload>
          }
          aggregate: {
            args: Prisma.ReportViewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportViewer>
          }
          groupBy: {
            args: Prisma.ReportViewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportViewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportViewerCountArgs<ExtArgs>
            result: $Utils.Optional<ReportViewerCountAggregateOutputType> | number
          }
        }
      }
      academic_years: {
        payload: Prisma.$academic_yearsPayload<ExtArgs>
        fields: Prisma.academic_yearsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.academic_yearsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.academic_yearsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload>
          }
          findFirst: {
            args: Prisma.academic_yearsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.academic_yearsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload>
          }
          findMany: {
            args: Prisma.academic_yearsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload>[]
          }
          create: {
            args: Prisma.academic_yearsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload>
          }
          createMany: {
            args: Prisma.academic_yearsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.academic_yearsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload>[]
          }
          delete: {
            args: Prisma.academic_yearsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload>
          }
          update: {
            args: Prisma.academic_yearsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload>
          }
          deleteMany: {
            args: Prisma.academic_yearsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.academic_yearsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.academic_yearsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload>[]
          }
          upsert: {
            args: Prisma.academic_yearsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$academic_yearsPayload>
          }
          aggregate: {
            args: Prisma.Academic_yearsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademic_years>
          }
          groupBy: {
            args: Prisma.academic_yearsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Academic_yearsGroupByOutputType>[]
          }
          count: {
            args: Prisma.academic_yearsCountArgs<ExtArgs>
            result: $Utils.Optional<Academic_yearsCountAggregateOutputType> | number
          }
        }
      }
      sections: {
        payload: Prisma.$sectionsPayload<ExtArgs>
        fields: Prisma.sectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sectionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sectionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          findFirst: {
            args: Prisma.sectionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sectionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          findMany: {
            args: Prisma.sectionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>[]
          }
          create: {
            args: Prisma.sectionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          createMany: {
            args: Prisma.sectionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sectionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>[]
          }
          delete: {
            args: Prisma.sectionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          update: {
            args: Prisma.sectionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          deleteMany: {
            args: Prisma.sectionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sectionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sectionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>[]
          }
          upsert: {
            args: Prisma.sectionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectionsPayload>
          }
          aggregate: {
            args: Prisma.SectionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSections>
          }
          groupBy: {
            args: Prisma.sectionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sectionsCountArgs<ExtArgs>
            result: $Utils.Optional<SectionsCountAggregateOutputType> | number
          }
        }
      }
      TestComponent: {
        payload: Prisma.$TestComponentPayload<ExtArgs>
        fields: Prisma.TestComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload>
          }
          findFirst: {
            args: Prisma.TestComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload>
          }
          findMany: {
            args: Prisma.TestComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload>[]
          }
          create: {
            args: Prisma.TestComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload>
          }
          createMany: {
            args: Prisma.TestComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload>[]
          }
          delete: {
            args: Prisma.TestComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload>
          }
          update: {
            args: Prisma.TestComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload>
          }
          deleteMany: {
            args: Prisma.TestComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestComponentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload>[]
          }
          upsert: {
            args: Prisma.TestComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestComponentPayload>
          }
          aggregate: {
            args: Prisma.TestComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestComponent>
          }
          groupBy: {
            args: Prisma.TestComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestComponentCountArgs<ExtArgs>
            result: $Utils.Optional<TestComponentCountAggregateOutputType> | number
          }
        }
      }
      StudentMark: {
        payload: Prisma.$StudentMarkPayload<ExtArgs>
        fields: Prisma.StudentMarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentMarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentMarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload>
          }
          findFirst: {
            args: Prisma.StudentMarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentMarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload>
          }
          findMany: {
            args: Prisma.StudentMarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload>[]
          }
          create: {
            args: Prisma.StudentMarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload>
          }
          createMany: {
            args: Prisma.StudentMarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentMarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload>[]
          }
          delete: {
            args: Prisma.StudentMarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload>
          }
          update: {
            args: Prisma.StudentMarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload>
          }
          deleteMany: {
            args: Prisma.StudentMarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentMarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentMarkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload>[]
          }
          upsert: {
            args: Prisma.StudentMarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMarkPayload>
          }
          aggregate: {
            args: Prisma.StudentMarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentMark>
          }
          groupBy: {
            args: Prisma.StudentMarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentMarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentMarkCountArgs<ExtArgs>
            result: $Utils.Optional<StudentMarkCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    college?: CollegeOmit
    department?: DepartmentOmit
    user?: UserOmit
    userRoleAssignment?: UserRoleAssignmentOmit
    student?: StudentOmit
    teacher?: TeacherOmit
    course?: CourseOmit
    departmentElectiveGroup?: DepartmentElectiveGroupOmit
    courseElectiveGroupMember?: CourseElectiveGroupMemberOmit
    openElectiveRestriction?: OpenElectiveRestrictionOmit
    courseOffering?: CourseOfferingOmit
    studentEnrollment?: StudentEnrollmentOmit
    attendance?: AttendanceOmit
    attendanceRecord?: AttendanceRecordOmit
    admin?: AdminOmit
    reportViewer?: ReportViewerOmit
    academic_years?: academic_yearsOmit
    sections?: sectionsOmit
    testComponent?: TestComponentOmit
    studentMark?: StudentMarkOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CollegeCountOutputType
   */

  export type CollegeCountOutputType = {
    academic_years: number
    courses: number
    department_elective_groups: number
    departments: number
    students: number
    teachers: number
  }

  export type CollegeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academic_years?: boolean | CollegeCountOutputTypeCountAcademic_yearsArgs
    courses?: boolean | CollegeCountOutputTypeCountCoursesArgs
    department_elective_groups?: boolean | CollegeCountOutputTypeCountDepartment_elective_groupsArgs
    departments?: boolean | CollegeCountOutputTypeCountDepartmentsArgs
    students?: boolean | CollegeCountOutputTypeCountStudentsArgs
    teachers?: boolean | CollegeCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes
  /**
   * CollegeCountOutputType without action
   */
  export type CollegeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollegeCountOutputType
     */
    select?: CollegeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollegeCountOutputType without action
   */
  export type CollegeCountOutputTypeCountAcademic_yearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: academic_yearsWhereInput
  }

  /**
   * CollegeCountOutputType without action
   */
  export type CollegeCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * CollegeCountOutputType without action
   */
  export type CollegeCountOutputTypeCountDepartment_elective_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentElectiveGroupWhereInput
  }

  /**
   * CollegeCountOutputType without action
   */
  export type CollegeCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * CollegeCountOutputType without action
   */
  export type CollegeCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * CollegeCountOutputType without action
   */
  export type CollegeCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    courses: number
    departmentElectiveGroups: number
    openElectiveRestrictions: number
    sections: number
    students: number
    teachers: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | DepartmentCountOutputTypeCountCoursesArgs
    departmentElectiveGroups?: boolean | DepartmentCountOutputTypeCountDepartmentElectiveGroupsArgs
    openElectiveRestrictions?: boolean | DepartmentCountOutputTypeCountOpenElectiveRestrictionsArgs
    sections?: boolean | DepartmentCountOutputTypeCountSectionsArgs
    students?: boolean | DepartmentCountOutputTypeCountStudentsArgs
    teachers?: boolean | DepartmentCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountDepartmentElectiveGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentElectiveGroupWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountOpenElectiveRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenElectiveRestrictionWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sectionsWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userRoles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleAssignmentWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    attendanceRecords: number
    enrollments: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendanceRecords?: boolean | StudentCountOutputTypeCountAttendanceRecordsArgs
    enrollments?: boolean | StudentCountOutputTypeCountEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    attendances: number
    courseOfferings: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | TeacherCountOutputTypeCountAttendancesArgs
    courseOfferings?: boolean | TeacherCountOutputTypeCountCourseOfferingsArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountCourseOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseOfferingWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    courseElectiveGroupMembers: number
    courseOfferings: number
    openElectiveRestrictions: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseElectiveGroupMembers?: boolean | CourseCountOutputTypeCountCourseElectiveGroupMembersArgs
    courseOfferings?: boolean | CourseCountOutputTypeCountCourseOfferingsArgs
    openElectiveRestrictions?: boolean | CourseCountOutputTypeCountOpenElectiveRestrictionsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseElectiveGroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseElectiveGroupMemberWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseOfferingWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountOpenElectiveRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenElectiveRestrictionWhereInput
  }


  /**
   * Count Type DepartmentElectiveGroupCountOutputType
   */

  export type DepartmentElectiveGroupCountOutputType = {
    courseElectiveGroupMembers: number
  }

  export type DepartmentElectiveGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseElectiveGroupMembers?: boolean | DepartmentElectiveGroupCountOutputTypeCountCourseElectiveGroupMembersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentElectiveGroupCountOutputType without action
   */
  export type DepartmentElectiveGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroupCountOutputType
     */
    select?: DepartmentElectiveGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentElectiveGroupCountOutputType without action
   */
  export type DepartmentElectiveGroupCountOutputTypeCountCourseElectiveGroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseElectiveGroupMemberWhereInput
  }


  /**
   * Count Type CourseOfferingCountOutputType
   */

  export type CourseOfferingCountOutputType = {
    attendances: number
    enrollments: number
    testComponents: number
  }

  export type CourseOfferingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | CourseOfferingCountOutputTypeCountAttendancesArgs
    enrollments?: boolean | CourseOfferingCountOutputTypeCountEnrollmentsArgs
    testComponents?: boolean | CourseOfferingCountOutputTypeCountTestComponentsArgs
  }

  // Custom InputTypes
  /**
   * CourseOfferingCountOutputType without action
   */
  export type CourseOfferingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOfferingCountOutputType
     */
    select?: CourseOfferingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseOfferingCountOutputType without action
   */
  export type CourseOfferingCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * CourseOfferingCountOutputType without action
   */
  export type CourseOfferingCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
  }

  /**
   * CourseOfferingCountOutputType without action
   */
  export type CourseOfferingCountOutputTypeCountTestComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestComponentWhereInput
  }


  /**
   * Count Type StudentEnrollmentCountOutputType
   */

  export type StudentEnrollmentCountOutputType = {
    studentMarks: number
  }

  export type StudentEnrollmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentMarks?: boolean | StudentEnrollmentCountOutputTypeCountStudentMarksArgs
  }

  // Custom InputTypes
  /**
   * StudentEnrollmentCountOutputType without action
   */
  export type StudentEnrollmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollmentCountOutputType
     */
    select?: StudentEnrollmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentEnrollmentCountOutputType without action
   */
  export type StudentEnrollmentCountOutputTypeCountStudentMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentMarkWhereInput
  }


  /**
   * Count Type AttendanceCountOutputType
   */

  export type AttendanceCountOutputType = {
    attendanceRecords: number
  }

  export type AttendanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendanceRecords?: boolean | AttendanceCountOutputTypeCountAttendanceRecordsArgs
  }

  // Custom InputTypes
  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCountOutputType
     */
    select?: AttendanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }


  /**
   * Count Type Academic_yearsCountOutputType
   */

  export type Academic_yearsCountOutputType = {
    course_offerings: number
    student_enrollments: number
  }

  export type Academic_yearsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_offerings?: boolean | Academic_yearsCountOutputTypeCountCourse_offeringsArgs
    student_enrollments?: boolean | Academic_yearsCountOutputTypeCountStudent_enrollmentsArgs
  }

  // Custom InputTypes
  /**
   * Academic_yearsCountOutputType without action
   */
  export type Academic_yearsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academic_yearsCountOutputType
     */
    select?: Academic_yearsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Academic_yearsCountOutputType without action
   */
  export type Academic_yearsCountOutputTypeCountCourse_offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseOfferingWhereInput
  }

  /**
   * Academic_yearsCountOutputType without action
   */
  export type Academic_yearsCountOutputTypeCountStudent_enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
  }


  /**
   * Count Type SectionsCountOutputType
   */

  export type SectionsCountOutputType = {
    course_offerings: number
    students: number
  }

  export type SectionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_offerings?: boolean | SectionsCountOutputTypeCountCourse_offeringsArgs
    students?: boolean | SectionsCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * SectionsCountOutputType without action
   */
  export type SectionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionsCountOutputType
     */
    select?: SectionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionsCountOutputType without action
   */
  export type SectionsCountOutputTypeCountCourse_offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseOfferingWhereInput
  }

  /**
   * SectionsCountOutputType without action
   */
  export type SectionsCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * Count Type TestComponentCountOutputType
   */

  export type TestComponentCountOutputType = {
    studentMarks: number
  }

  export type TestComponentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentMarks?: boolean | TestComponentCountOutputTypeCountStudentMarksArgs
  }

  // Custom InputTypes
  /**
   * TestComponentCountOutputType without action
   */
  export type TestComponentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponentCountOutputType
     */
    select?: TestComponentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestComponentCountOutputType without action
   */
  export type TestComponentCountOutputTypeCountStudentMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentMarkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model College
   */

  export type AggregateCollege = {
    _count: CollegeCountAggregateOutputType | null
    _min: CollegeMinAggregateOutputType | null
    _max: CollegeMaxAggregateOutputType | null
  }

  export type CollegeMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    logoUrl: string | null
  }

  export type CollegeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    logoUrl: string | null
  }

  export type CollegeCountAggregateOutputType = {
    id: number
    name: number
    code: number
    logoUrl: number
    _all: number
  }


  export type CollegeMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    logoUrl?: true
  }

  export type CollegeMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    logoUrl?: true
  }

  export type CollegeCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    logoUrl?: true
    _all?: true
  }

  export type CollegeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which College to aggregate.
     */
    where?: CollegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colleges to fetch.
     */
    orderBy?: CollegeOrderByWithRelationInput | CollegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colleges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colleges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Colleges
    **/
    _count?: true | CollegeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollegeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollegeMaxAggregateInputType
  }

  export type GetCollegeAggregateType<T extends CollegeAggregateArgs> = {
        [P in keyof T & keyof AggregateCollege]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollege[P]>
      : GetScalarType<T[P], AggregateCollege[P]>
  }




  export type CollegeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollegeWhereInput
    orderBy?: CollegeOrderByWithAggregationInput | CollegeOrderByWithAggregationInput[]
    by: CollegeScalarFieldEnum[] | CollegeScalarFieldEnum
    having?: CollegeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollegeCountAggregateInputType | true
    _min?: CollegeMinAggregateInputType
    _max?: CollegeMaxAggregateInputType
  }

  export type CollegeGroupByOutputType = {
    id: string
    name: string
    code: string
    logoUrl: string | null
    _count: CollegeCountAggregateOutputType | null
    _min: CollegeMinAggregateOutputType | null
    _max: CollegeMaxAggregateOutputType | null
  }

  type GetCollegeGroupByPayload<T extends CollegeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollegeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollegeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollegeGroupByOutputType[P]>
            : GetScalarType<T[P], CollegeGroupByOutputType[P]>
        }
      >
    >


  export type CollegeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
    academic_years?: boolean | College$academic_yearsArgs<ExtArgs>
    courses?: boolean | College$coursesArgs<ExtArgs>
    department_elective_groups?: boolean | College$department_elective_groupsArgs<ExtArgs>
    departments?: boolean | College$departmentsArgs<ExtArgs>
    students?: boolean | College$studentsArgs<ExtArgs>
    teachers?: boolean | College$teachersArgs<ExtArgs>
    _count?: boolean | CollegeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["college"]>

  export type CollegeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
  }, ExtArgs["result"]["college"]>

  export type CollegeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
  }, ExtArgs["result"]["college"]>

  export type CollegeSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
  }

  export type CollegeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "logoUrl", ExtArgs["result"]["college"]>
  export type CollegeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academic_years?: boolean | College$academic_yearsArgs<ExtArgs>
    courses?: boolean | College$coursesArgs<ExtArgs>
    department_elective_groups?: boolean | College$department_elective_groupsArgs<ExtArgs>
    departments?: boolean | College$departmentsArgs<ExtArgs>
    students?: boolean | College$studentsArgs<ExtArgs>
    teachers?: boolean | College$teachersArgs<ExtArgs>
    _count?: boolean | CollegeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollegeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CollegeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CollegePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "College"
    objects: {
      academic_years: Prisma.$academic_yearsPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      department_elective_groups: Prisma.$DepartmentElectiveGroupPayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      teachers: Prisma.$TeacherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      logoUrl: string | null
    }, ExtArgs["result"]["college"]>
    composites: {}
  }

  type CollegeGetPayload<S extends boolean | null | undefined | CollegeDefaultArgs> = $Result.GetResult<Prisma.$CollegePayload, S>

  type CollegeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollegeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollegeCountAggregateInputType | true
    }

  export interface CollegeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['College'], meta: { name: 'College' } }
    /**
     * Find zero or one College that matches the filter.
     * @param {CollegeFindUniqueArgs} args - Arguments to find a College
     * @example
     * // Get one College
     * const college = await prisma.college.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollegeFindUniqueArgs>(args: SelectSubset<T, CollegeFindUniqueArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one College that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollegeFindUniqueOrThrowArgs} args - Arguments to find a College
     * @example
     * // Get one College
     * const college = await prisma.college.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollegeFindUniqueOrThrowArgs>(args: SelectSubset<T, CollegeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first College that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollegeFindFirstArgs} args - Arguments to find a College
     * @example
     * // Get one College
     * const college = await prisma.college.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollegeFindFirstArgs>(args?: SelectSubset<T, CollegeFindFirstArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first College that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollegeFindFirstOrThrowArgs} args - Arguments to find a College
     * @example
     * // Get one College
     * const college = await prisma.college.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollegeFindFirstOrThrowArgs>(args?: SelectSubset<T, CollegeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Colleges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollegeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Colleges
     * const colleges = await prisma.college.findMany()
     * 
     * // Get first 10 Colleges
     * const colleges = await prisma.college.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collegeWithIdOnly = await prisma.college.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollegeFindManyArgs>(args?: SelectSubset<T, CollegeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a College.
     * @param {CollegeCreateArgs} args - Arguments to create a College.
     * @example
     * // Create one College
     * const College = await prisma.college.create({
     *   data: {
     *     // ... data to create a College
     *   }
     * })
     * 
     */
    create<T extends CollegeCreateArgs>(args: SelectSubset<T, CollegeCreateArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Colleges.
     * @param {CollegeCreateManyArgs} args - Arguments to create many Colleges.
     * @example
     * // Create many Colleges
     * const college = await prisma.college.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollegeCreateManyArgs>(args?: SelectSubset<T, CollegeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Colleges and returns the data saved in the database.
     * @param {CollegeCreateManyAndReturnArgs} args - Arguments to create many Colleges.
     * @example
     * // Create many Colleges
     * const college = await prisma.college.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Colleges and only return the `id`
     * const collegeWithIdOnly = await prisma.college.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollegeCreateManyAndReturnArgs>(args?: SelectSubset<T, CollegeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a College.
     * @param {CollegeDeleteArgs} args - Arguments to delete one College.
     * @example
     * // Delete one College
     * const College = await prisma.college.delete({
     *   where: {
     *     // ... filter to delete one College
     *   }
     * })
     * 
     */
    delete<T extends CollegeDeleteArgs>(args: SelectSubset<T, CollegeDeleteArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one College.
     * @param {CollegeUpdateArgs} args - Arguments to update one College.
     * @example
     * // Update one College
     * const college = await prisma.college.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollegeUpdateArgs>(args: SelectSubset<T, CollegeUpdateArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Colleges.
     * @param {CollegeDeleteManyArgs} args - Arguments to filter Colleges to delete.
     * @example
     * // Delete a few Colleges
     * const { count } = await prisma.college.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollegeDeleteManyArgs>(args?: SelectSubset<T, CollegeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colleges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollegeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Colleges
     * const college = await prisma.college.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollegeUpdateManyArgs>(args: SelectSubset<T, CollegeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colleges and returns the data updated in the database.
     * @param {CollegeUpdateManyAndReturnArgs} args - Arguments to update many Colleges.
     * @example
     * // Update many Colleges
     * const college = await prisma.college.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Colleges and only return the `id`
     * const collegeWithIdOnly = await prisma.college.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollegeUpdateManyAndReturnArgs>(args: SelectSubset<T, CollegeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one College.
     * @param {CollegeUpsertArgs} args - Arguments to update or create a College.
     * @example
     * // Update or create a College
     * const college = await prisma.college.upsert({
     *   create: {
     *     // ... data to create a College
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the College we want to update
     *   }
     * })
     */
    upsert<T extends CollegeUpsertArgs>(args: SelectSubset<T, CollegeUpsertArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Colleges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollegeCountArgs} args - Arguments to filter Colleges to count.
     * @example
     * // Count the number of Colleges
     * const count = await prisma.college.count({
     *   where: {
     *     // ... the filter for the Colleges we want to count
     *   }
     * })
    **/
    count<T extends CollegeCountArgs>(
      args?: Subset<T, CollegeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollegeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a College.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollegeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollegeAggregateArgs>(args: Subset<T, CollegeAggregateArgs>): Prisma.PrismaPromise<GetCollegeAggregateType<T>>

    /**
     * Group by College.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollegeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollegeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollegeGroupByArgs['orderBy'] }
        : { orderBy?: CollegeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollegeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollegeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the College model
   */
  readonly fields: CollegeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for College.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollegeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academic_years<T extends College$academic_yearsArgs<ExtArgs> = {}>(args?: Subset<T, College$academic_yearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends College$coursesArgs<ExtArgs> = {}>(args?: Subset<T, College$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department_elective_groups<T extends College$department_elective_groupsArgs<ExtArgs> = {}>(args?: Subset<T, College$department_elective_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments<T extends College$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, College$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends College$studentsArgs<ExtArgs> = {}>(args?: Subset<T, College$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends College$teachersArgs<ExtArgs> = {}>(args?: Subset<T, College$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the College model
   */
  interface CollegeFieldRefs {
    readonly id: FieldRef<"College", 'String'>
    readonly name: FieldRef<"College", 'String'>
    readonly code: FieldRef<"College", 'String'>
    readonly logoUrl: FieldRef<"College", 'String'>
  }
    

  // Custom InputTypes
  /**
   * College findUnique
   */
  export type CollegeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
    /**
     * Filter, which College to fetch.
     */
    where: CollegeWhereUniqueInput
  }

  /**
   * College findUniqueOrThrow
   */
  export type CollegeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
    /**
     * Filter, which College to fetch.
     */
    where: CollegeWhereUniqueInput
  }

  /**
   * College findFirst
   */
  export type CollegeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
    /**
     * Filter, which College to fetch.
     */
    where?: CollegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colleges to fetch.
     */
    orderBy?: CollegeOrderByWithRelationInput | CollegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colleges.
     */
    cursor?: CollegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colleges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colleges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colleges.
     */
    distinct?: CollegeScalarFieldEnum | CollegeScalarFieldEnum[]
  }

  /**
   * College findFirstOrThrow
   */
  export type CollegeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
    /**
     * Filter, which College to fetch.
     */
    where?: CollegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colleges to fetch.
     */
    orderBy?: CollegeOrderByWithRelationInput | CollegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colleges.
     */
    cursor?: CollegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colleges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colleges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colleges.
     */
    distinct?: CollegeScalarFieldEnum | CollegeScalarFieldEnum[]
  }

  /**
   * College findMany
   */
  export type CollegeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
    /**
     * Filter, which Colleges to fetch.
     */
    where?: CollegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colleges to fetch.
     */
    orderBy?: CollegeOrderByWithRelationInput | CollegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Colleges.
     */
    cursor?: CollegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colleges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colleges.
     */
    skip?: number
    distinct?: CollegeScalarFieldEnum | CollegeScalarFieldEnum[]
  }

  /**
   * College create
   */
  export type CollegeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
    /**
     * The data needed to create a College.
     */
    data: XOR<CollegeCreateInput, CollegeUncheckedCreateInput>
  }

  /**
   * College createMany
   */
  export type CollegeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Colleges.
     */
    data: CollegeCreateManyInput | CollegeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * College createManyAndReturn
   */
  export type CollegeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * The data used to create many Colleges.
     */
    data: CollegeCreateManyInput | CollegeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * College update
   */
  export type CollegeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
    /**
     * The data needed to update a College.
     */
    data: XOR<CollegeUpdateInput, CollegeUncheckedUpdateInput>
    /**
     * Choose, which College to update.
     */
    where: CollegeWhereUniqueInput
  }

  /**
   * College updateMany
   */
  export type CollegeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Colleges.
     */
    data: XOR<CollegeUpdateManyMutationInput, CollegeUncheckedUpdateManyInput>
    /**
     * Filter which Colleges to update
     */
    where?: CollegeWhereInput
    /**
     * Limit how many Colleges to update.
     */
    limit?: number
  }

  /**
   * College updateManyAndReturn
   */
  export type CollegeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * The data used to update Colleges.
     */
    data: XOR<CollegeUpdateManyMutationInput, CollegeUncheckedUpdateManyInput>
    /**
     * Filter which Colleges to update
     */
    where?: CollegeWhereInput
    /**
     * Limit how many Colleges to update.
     */
    limit?: number
  }

  /**
   * College upsert
   */
  export type CollegeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
    /**
     * The filter to search for the College to update in case it exists.
     */
    where: CollegeWhereUniqueInput
    /**
     * In case the College found by the `where` argument doesn't exist, create a new College with this data.
     */
    create: XOR<CollegeCreateInput, CollegeUncheckedCreateInput>
    /**
     * In case the College was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollegeUpdateInput, CollegeUncheckedUpdateInput>
  }

  /**
   * College delete
   */
  export type CollegeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
    /**
     * Filter which College to delete.
     */
    where: CollegeWhereUniqueInput
  }

  /**
   * College deleteMany
   */
  export type CollegeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colleges to delete
     */
    where?: CollegeWhereInput
    /**
     * Limit how many Colleges to delete.
     */
    limit?: number
  }

  /**
   * College.academic_years
   */
  export type College$academic_yearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    where?: academic_yearsWhereInput
    orderBy?: academic_yearsOrderByWithRelationInput | academic_yearsOrderByWithRelationInput[]
    cursor?: academic_yearsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Academic_yearsScalarFieldEnum | Academic_yearsScalarFieldEnum[]
  }

  /**
   * College.courses
   */
  export type College$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * College.department_elective_groups
   */
  export type College$department_elective_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    where?: DepartmentElectiveGroupWhereInput
    orderBy?: DepartmentElectiveGroupOrderByWithRelationInput | DepartmentElectiveGroupOrderByWithRelationInput[]
    cursor?: DepartmentElectiveGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentElectiveGroupScalarFieldEnum | DepartmentElectiveGroupScalarFieldEnum[]
  }

  /**
   * College.departments
   */
  export type College$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * College.students
   */
  export type College$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * College.teachers
   */
  export type College$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * College without action
   */
  export type CollegeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the College
     */
    select?: CollegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the College
     */
    omit?: CollegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollegeInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    college_id: string | null
    name: string | null
    code: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    college_id: string | null
    name: string | null
    code: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    college_id: number
    name: number
    code: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    college_id?: true
    name?: true
    code?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    college_id?: true
    name?: true
    code?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    college_id?: true
    name?: true
    code?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    college_id: string
    name: string
    code: string | null
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    college_id?: boolean
    name?: boolean
    code?: boolean
    courses?: boolean | Department$coursesArgs<ExtArgs>
    departmentElectiveGroups?: boolean | Department$departmentElectiveGroupsArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    openElectiveRestrictions?: boolean | Department$openElectiveRestrictionsArgs<ExtArgs>
    sections?: boolean | Department$sectionsArgs<ExtArgs>
    students?: boolean | Department$studentsArgs<ExtArgs>
    teachers?: boolean | Department$teachersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    college_id?: boolean
    name?: boolean
    code?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    college_id?: boolean
    name?: boolean
    code?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    college_id?: boolean
    name?: boolean
    code?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "college_id" | "name" | "code", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Department$coursesArgs<ExtArgs>
    departmentElectiveGroups?: boolean | Department$departmentElectiveGroupsArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    openElectiveRestrictions?: boolean | Department$openElectiveRestrictionsArgs<ExtArgs>
    sections?: boolean | Department$sectionsArgs<ExtArgs>
    students?: boolean | Department$studentsArgs<ExtArgs>
    teachers?: boolean | Department$teachersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      courses: Prisma.$CoursePayload<ExtArgs>[]
      departmentElectiveGroups: Prisma.$DepartmentElectiveGroupPayload<ExtArgs>[]
      colleges: Prisma.$CollegePayload<ExtArgs>
      openElectiveRestrictions: Prisma.$OpenElectiveRestrictionPayload<ExtArgs>[]
      sections: Prisma.$sectionsPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      teachers: Prisma.$TeacherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      college_id: string
      name: string
      code: string | null
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Department$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Department$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departmentElectiveGroups<T extends Department$departmentElectiveGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Department$departmentElectiveGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    colleges<T extends CollegeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollegeDefaultArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    openElectiveRestrictions<T extends Department$openElectiveRestrictionsArgs<ExtArgs> = {}>(args?: Subset<T, Department$openElectiveRestrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sections<T extends Department$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Department$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Department$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Department$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends Department$teachersArgs<ExtArgs> = {}>(args?: Subset<T, Department$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly college_id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.courses
   */
  export type Department$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Department.departmentElectiveGroups
   */
  export type Department$departmentElectiveGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    where?: DepartmentElectiveGroupWhereInput
    orderBy?: DepartmentElectiveGroupOrderByWithRelationInput | DepartmentElectiveGroupOrderByWithRelationInput[]
    cursor?: DepartmentElectiveGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentElectiveGroupScalarFieldEnum | DepartmentElectiveGroupScalarFieldEnum[]
  }

  /**
   * Department.openElectiveRestrictions
   */
  export type Department$openElectiveRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    where?: OpenElectiveRestrictionWhereInput
    orderBy?: OpenElectiveRestrictionOrderByWithRelationInput | OpenElectiveRestrictionOrderByWithRelationInput[]
    cursor?: OpenElectiveRestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpenElectiveRestrictionScalarFieldEnum | OpenElectiveRestrictionScalarFieldEnum[]
  }

  /**
   * Department.sections
   */
  export type Department$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    where?: sectionsWhereInput
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    cursor?: sectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionsScalarFieldEnum | SectionsScalarFieldEnum[]
  }

  /**
   * Department.students
   */
  export type Department$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Department.teachers
   */
  export type Department$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    phone: string | null
    photoUrl: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    phone: string | null
    photoUrl: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    name: number
    phone: number
    photoUrl: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    name?: true
    phone?: true
    photoUrl?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    name?: true
    phone?: true
    photoUrl?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    name?: true
    phone?: true
    photoUrl?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string | null
    passwordHash: string
    name: string
    phone: string | null
    photoUrl: string | null
    createdAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    admin?: boolean | User$adminArgs<ExtArgs>
    reportViewer?: boolean | User$reportViewerArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    photoUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    photoUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    photoUrl?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "name" | "phone" | "photoUrl" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | User$adminArgs<ExtArgs>
    reportViewer?: boolean | User$reportViewerArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
      reportViewer: Prisma.$ReportViewerPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      userRoles: Prisma.$UserRoleAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string | null
      passwordHash: string
      name: string
      phone: string | null
      photoUrl: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reportViewer<T extends User$reportViewerArgs<ExtArgs> = {}>(args?: Subset<T, User$reportViewerArgs<ExtArgs>>): Prisma__ReportViewerClient<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends User$teacherArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly photoUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.reportViewer
   */
  export type User$reportViewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    where?: ReportViewerWhereInput
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.teacher
   */
  export type User$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    where?: UserRoleAssignmentWhereInput
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    cursor?: UserRoleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleAssignmentScalarFieldEnum | UserRoleAssignmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserRoleAssignment
   */

  export type AggregateUserRoleAssignment = {
    _count: UserRoleAssignmentCountAggregateOutputType | null
    _min: UserRoleAssignmentMinAggregateOutputType | null
    _max: UserRoleAssignmentMaxAggregateOutputType | null
  }

  export type UserRoleAssignmentMinAggregateOutputType = {
    userId: string | null
    role: $Enums.user_role | null
  }

  export type UserRoleAssignmentMaxAggregateOutputType = {
    userId: string | null
    role: $Enums.user_role | null
  }

  export type UserRoleAssignmentCountAggregateOutputType = {
    userId: number
    role: number
    _all: number
  }


  export type UserRoleAssignmentMinAggregateInputType = {
    userId?: true
    role?: true
  }

  export type UserRoleAssignmentMaxAggregateInputType = {
    userId?: true
    role?: true
  }

  export type UserRoleAssignmentCountAggregateInputType = {
    userId?: true
    role?: true
    _all?: true
  }

  export type UserRoleAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleAssignment to aggregate.
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleAssignments to fetch.
     */
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoleAssignments
    **/
    _count?: true | UserRoleAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleAssignmentMaxAggregateInputType
  }

  export type GetUserRoleAssignmentAggregateType<T extends UserRoleAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoleAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoleAssignment[P]>
      : GetScalarType<T[P], AggregateUserRoleAssignment[P]>
  }




  export type UserRoleAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleAssignmentWhereInput
    orderBy?: UserRoleAssignmentOrderByWithAggregationInput | UserRoleAssignmentOrderByWithAggregationInput[]
    by: UserRoleAssignmentScalarFieldEnum[] | UserRoleAssignmentScalarFieldEnum
    having?: UserRoleAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleAssignmentCountAggregateInputType | true
    _min?: UserRoleAssignmentMinAggregateInputType
    _max?: UserRoleAssignmentMaxAggregateInputType
  }

  export type UserRoleAssignmentGroupByOutputType = {
    userId: string
    role: $Enums.user_role
    _count: UserRoleAssignmentCountAggregateOutputType | null
    _min: UserRoleAssignmentMinAggregateOutputType | null
    _max: UserRoleAssignmentMaxAggregateOutputType | null
  }

  type GetUserRoleAssignmentGroupByPayload<T extends UserRoleAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    role?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoleAssignment"]>

  export type UserRoleAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    role?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoleAssignment"]>

  export type UserRoleAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    role?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoleAssignment"]>

  export type UserRoleAssignmentSelectScalar = {
    userId?: boolean
    role?: boolean
  }

  export type UserRoleAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "role", ExtArgs["result"]["userRoleAssignment"]>
  export type UserRoleAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRoleAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRoleAssignment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      role: $Enums.user_role
    }, ExtArgs["result"]["userRoleAssignment"]>
    composites: {}
  }

  type UserRoleAssignmentGetPayload<S extends boolean | null | undefined | UserRoleAssignmentDefaultArgs> = $Result.GetResult<Prisma.$UserRoleAssignmentPayload, S>

  type UserRoleAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleAssignmentCountAggregateInputType | true
    }

  export interface UserRoleAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRoleAssignment'], meta: { name: 'UserRoleAssignment' } }
    /**
     * Find zero or one UserRoleAssignment that matches the filter.
     * @param {UserRoleAssignmentFindUniqueArgs} args - Arguments to find a UserRoleAssignment
     * @example
     * // Get one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleAssignmentFindUniqueArgs>(args: SelectSubset<T, UserRoleAssignmentFindUniqueArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRoleAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleAssignmentFindUniqueOrThrowArgs} args - Arguments to find a UserRoleAssignment
     * @example
     * // Get one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRoleAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentFindFirstArgs} args - Arguments to find a UserRoleAssignment
     * @example
     * // Get one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleAssignmentFindFirstArgs>(args?: SelectSubset<T, UserRoleAssignmentFindFirstArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRoleAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentFindFirstOrThrowArgs} args - Arguments to find a UserRoleAssignment
     * @example
     * // Get one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoleAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoleAssignments
     * const userRoleAssignments = await prisma.userRoleAssignment.findMany()
     * 
     * // Get first 10 UserRoleAssignments
     * const userRoleAssignments = await prisma.userRoleAssignment.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleAssignmentWithUserIdOnly = await prisma.userRoleAssignment.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleAssignmentFindManyArgs>(args?: SelectSubset<T, UserRoleAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRoleAssignment.
     * @param {UserRoleAssignmentCreateArgs} args - Arguments to create a UserRoleAssignment.
     * @example
     * // Create one UserRoleAssignment
     * const UserRoleAssignment = await prisma.userRoleAssignment.create({
     *   data: {
     *     // ... data to create a UserRoleAssignment
     *   }
     * })
     * 
     */
    create<T extends UserRoleAssignmentCreateArgs>(args: SelectSubset<T, UserRoleAssignmentCreateArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoleAssignments.
     * @param {UserRoleAssignmentCreateManyArgs} args - Arguments to create many UserRoleAssignments.
     * @example
     * // Create many UserRoleAssignments
     * const userRoleAssignment = await prisma.userRoleAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleAssignmentCreateManyArgs>(args?: SelectSubset<T, UserRoleAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoleAssignments and returns the data saved in the database.
     * @param {UserRoleAssignmentCreateManyAndReturnArgs} args - Arguments to create many UserRoleAssignments.
     * @example
     * // Create many UserRoleAssignments
     * const userRoleAssignment = await prisma.userRoleAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoleAssignments and only return the `userId`
     * const userRoleAssignmentWithUserIdOnly = await prisma.userRoleAssignment.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRoleAssignment.
     * @param {UserRoleAssignmentDeleteArgs} args - Arguments to delete one UserRoleAssignment.
     * @example
     * // Delete one UserRoleAssignment
     * const UserRoleAssignment = await prisma.userRoleAssignment.delete({
     *   where: {
     *     // ... filter to delete one UserRoleAssignment
     *   }
     * })
     * 
     */
    delete<T extends UserRoleAssignmentDeleteArgs>(args: SelectSubset<T, UserRoleAssignmentDeleteArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRoleAssignment.
     * @param {UserRoleAssignmentUpdateArgs} args - Arguments to update one UserRoleAssignment.
     * @example
     * // Update one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleAssignmentUpdateArgs>(args: SelectSubset<T, UserRoleAssignmentUpdateArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoleAssignments.
     * @param {UserRoleAssignmentDeleteManyArgs} args - Arguments to filter UserRoleAssignments to delete.
     * @example
     * // Delete a few UserRoleAssignments
     * const { count } = await prisma.userRoleAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleAssignmentDeleteManyArgs>(args?: SelectSubset<T, UserRoleAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoleAssignments
     * const userRoleAssignment = await prisma.userRoleAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleAssignmentUpdateManyArgs>(args: SelectSubset<T, UserRoleAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoleAssignments and returns the data updated in the database.
     * @param {UserRoleAssignmentUpdateManyAndReturnArgs} args - Arguments to update many UserRoleAssignments.
     * @example
     * // Update many UserRoleAssignments
     * const userRoleAssignment = await prisma.userRoleAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoleAssignments and only return the `userId`
     * const userRoleAssignmentWithUserIdOnly = await prisma.userRoleAssignment.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRoleAssignment.
     * @param {UserRoleAssignmentUpsertArgs} args - Arguments to update or create a UserRoleAssignment.
     * @example
     * // Update or create a UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.upsert({
     *   create: {
     *     // ... data to create a UserRoleAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoleAssignment we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleAssignmentUpsertArgs>(args: SelectSubset<T, UserRoleAssignmentUpsertArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentCountArgs} args - Arguments to filter UserRoleAssignments to count.
     * @example
     * // Count the number of UserRoleAssignments
     * const count = await prisma.userRoleAssignment.count({
     *   where: {
     *     // ... the filter for the UserRoleAssignments we want to count
     *   }
     * })
    **/
    count<T extends UserRoleAssignmentCountArgs>(
      args?: Subset<T, UserRoleAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAssignmentAggregateArgs>(args: Subset<T, UserRoleAssignmentAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAssignmentAggregateType<T>>

    /**
     * Group by UserRoleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRoleAssignment model
   */
  readonly fields: UserRoleAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoleAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRoleAssignment model
   */
  interface UserRoleAssignmentFieldRefs {
    readonly userId: FieldRef<"UserRoleAssignment", 'String'>
    readonly role: FieldRef<"UserRoleAssignment", 'user_role'>
  }
    

  // Custom InputTypes
  /**
   * UserRoleAssignment findUnique
   */
  export type UserRoleAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignment to fetch.
     */
    where: UserRoleAssignmentWhereUniqueInput
  }

  /**
   * UserRoleAssignment findUniqueOrThrow
   */
  export type UserRoleAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignment to fetch.
     */
    where: UserRoleAssignmentWhereUniqueInput
  }

  /**
   * UserRoleAssignment findFirst
   */
  export type UserRoleAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignment to fetch.
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleAssignments to fetch.
     */
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleAssignments.
     */
    cursor?: UserRoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleAssignments.
     */
    distinct?: UserRoleAssignmentScalarFieldEnum | UserRoleAssignmentScalarFieldEnum[]
  }

  /**
   * UserRoleAssignment findFirstOrThrow
   */
  export type UserRoleAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignment to fetch.
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleAssignments to fetch.
     */
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleAssignments.
     */
    cursor?: UserRoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleAssignments.
     */
    distinct?: UserRoleAssignmentScalarFieldEnum | UserRoleAssignmentScalarFieldEnum[]
  }

  /**
   * UserRoleAssignment findMany
   */
  export type UserRoleAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignments to fetch.
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleAssignments to fetch.
     */
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoleAssignments.
     */
    cursor?: UserRoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleAssignments.
     */
    skip?: number
    distinct?: UserRoleAssignmentScalarFieldEnum | UserRoleAssignmentScalarFieldEnum[]
  }

  /**
   * UserRoleAssignment create
   */
  export type UserRoleAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRoleAssignment.
     */
    data: XOR<UserRoleAssignmentCreateInput, UserRoleAssignmentUncheckedCreateInput>
  }

  /**
   * UserRoleAssignment createMany
   */
  export type UserRoleAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoleAssignments.
     */
    data: UserRoleAssignmentCreateManyInput | UserRoleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRoleAssignment createManyAndReturn
   */
  export type UserRoleAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoleAssignments.
     */
    data: UserRoleAssignmentCreateManyInput | UserRoleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRoleAssignment update
   */
  export type UserRoleAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRoleAssignment.
     */
    data: XOR<UserRoleAssignmentUpdateInput, UserRoleAssignmentUncheckedUpdateInput>
    /**
     * Choose, which UserRoleAssignment to update.
     */
    where: UserRoleAssignmentWhereUniqueInput
  }

  /**
   * UserRoleAssignment updateMany
   */
  export type UserRoleAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoleAssignments.
     */
    data: XOR<UserRoleAssignmentUpdateManyMutationInput, UserRoleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which UserRoleAssignments to update
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * Limit how many UserRoleAssignments to update.
     */
    limit?: number
  }

  /**
   * UserRoleAssignment updateManyAndReturn
   */
  export type UserRoleAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update UserRoleAssignments.
     */
    data: XOR<UserRoleAssignmentUpdateManyMutationInput, UserRoleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which UserRoleAssignments to update
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * Limit how many UserRoleAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRoleAssignment upsert
   */
  export type UserRoleAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRoleAssignment to update in case it exists.
     */
    where: UserRoleAssignmentWhereUniqueInput
    /**
     * In case the UserRoleAssignment found by the `where` argument doesn't exist, create a new UserRoleAssignment with this data.
     */
    create: XOR<UserRoleAssignmentCreateInput, UserRoleAssignmentUncheckedCreateInput>
    /**
     * In case the UserRoleAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleAssignmentUpdateInput, UserRoleAssignmentUncheckedUpdateInput>
  }

  /**
   * UserRoleAssignment delete
   */
  export type UserRoleAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter which UserRoleAssignment to delete.
     */
    where: UserRoleAssignmentWhereUniqueInput
  }

  /**
   * UserRoleAssignment deleteMany
   */
  export type UserRoleAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleAssignments to delete
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * Limit how many UserRoleAssignments to delete.
     */
    limit?: number
  }

  /**
   * UserRoleAssignment without action
   */
  export type UserRoleAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoleAssignment
     */
    omit?: UserRoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    semester: number | null
    batchYear: number | null
  }

  export type StudentSumAggregateOutputType = {
    semester: number | null
    batchYear: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    college_id: string | null
    department_id: string | null
    section_id: string | null
    usn: string | null
    semester: number | null
    batchYear: number | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    college_id: string | null
    department_id: string | null
    section_id: string | null
    usn: string | null
    semester: number | null
    batchYear: number | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    college_id: number
    department_id: number
    section_id: number
    usn: number
    semester: number
    batchYear: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    semester?: true
    batchYear?: true
  }

  export type StudentSumAggregateInputType = {
    semester?: true
    batchYear?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    college_id?: true
    department_id?: true
    section_id?: true
    usn?: true
    semester?: true
    batchYear?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    college_id?: true
    department_id?: true
    section_id?: true
    usn?: true
    semester?: true
    batchYear?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    college_id?: true
    department_id?: true
    section_id?: true
    usn?: true
    semester?: true
    batchYear?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    college_id: string
    department_id: string | null
    section_id: string | null
    usn: string
    semester: number | null
    batchYear: number
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    college_id?: boolean
    department_id?: boolean
    section_id?: boolean
    usn?: boolean
    semester?: boolean
    batchYear?: boolean
    attendanceRecords?: boolean | Student$attendanceRecordsArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    departments?: boolean | Student$departmentsArgs<ExtArgs>
    sections?: boolean | Student$sectionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    college_id?: boolean
    department_id?: boolean
    section_id?: boolean
    usn?: boolean
    semester?: boolean
    batchYear?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    departments?: boolean | Student$departmentsArgs<ExtArgs>
    sections?: boolean | Student$sectionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    college_id?: boolean
    department_id?: boolean
    section_id?: boolean
    usn?: boolean
    semester?: boolean
    batchYear?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    departments?: boolean | Student$departmentsArgs<ExtArgs>
    sections?: boolean | Student$sectionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    college_id?: boolean
    department_id?: boolean
    section_id?: boolean
    usn?: boolean
    semester?: boolean
    batchYear?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "college_id" | "department_id" | "section_id" | "usn" | "semester" | "batchYear", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendanceRecords?: boolean | Student$attendanceRecordsArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    departments?: boolean | Student$departmentsArgs<ExtArgs>
    sections?: boolean | Student$sectionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    departments?: boolean | Student$departmentsArgs<ExtArgs>
    sections?: boolean | Student$sectionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    departments?: boolean | Student$departmentsArgs<ExtArgs>
    sections?: boolean | Student$sectionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      enrollments: Prisma.$StudentEnrollmentPayload<ExtArgs>[]
      colleges: Prisma.$CollegePayload<ExtArgs>
      departments: Prisma.$DepartmentPayload<ExtArgs> | null
      sections: Prisma.$sectionsPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      college_id: string
      department_id: string | null
      section_id: string | null
      usn: string
      semester: number | null
      batchYear: number
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendanceRecords<T extends Student$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Student$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    colleges<T extends CollegeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollegeDefaultArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    departments<T extends Student$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$departmentsArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sections<T extends Student$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Student$sectionsArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly college_id: FieldRef<"Student", 'String'>
    readonly department_id: FieldRef<"Student", 'String'>
    readonly section_id: FieldRef<"Student", 'String'>
    readonly usn: FieldRef<"Student", 'String'>
    readonly semester: FieldRef<"Student", 'Int'>
    readonly batchYear: FieldRef<"Student", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.attendanceRecords
   */
  export type Student$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Student.enrollments
   */
  export type Student$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    cursor?: StudentEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * Student.departments
   */
  export type Student$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Student.sections
   */
  export type Student$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    where?: sectionsWhereInput
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    college_id: string | null
    departmentId: string | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    college_id: string | null
    departmentId: string | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    college_id: number
    departmentId: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    college_id?: true
    departmentId?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    college_id?: true
    departmentId?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    college_id?: true
    departmentId?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    userId: string
    college_id: string
    departmentId: string | null
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    college_id?: boolean
    departmentId?: boolean
    attendances?: boolean | Teacher$attendancesArgs<ExtArgs>
    courseOfferings?: boolean | Teacher$courseOfferingsArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    college_id?: boolean
    departmentId?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    college_id?: boolean
    departmentId?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    userId?: boolean
    college_id?: boolean
    departmentId?: boolean
  }

  export type TeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "college_id" | "departmentId", ExtArgs["result"]["teacher"]>
  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | Teacher$attendancesArgs<ExtArgs>
    courseOfferings?: boolean | Teacher$courseOfferingsArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Teacher$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      courseOfferings: Prisma.$CourseOfferingPayload<ExtArgs>[]
      colleges: Prisma.$CollegePayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      college_id: string
      departmentId: string | null
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {TeacherUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendances<T extends Teacher$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courseOfferings<T extends Teacher$courseOfferingsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$courseOfferingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    colleges<T extends CollegeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollegeDefaultArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends Teacher$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly userId: FieldRef<"Teacher", 'String'>
    readonly college_id: FieldRef<"Teacher", 'String'>
    readonly departmentId: FieldRef<"Teacher", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher createManyAndReturn
   */
  export type TeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teacher updateManyAndReturn
   */
  export type TeacherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teacher.attendances
   */
  export type Teacher$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Teacher.courseOfferings
   */
  export type Teacher$courseOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    where?: CourseOfferingWhereInput
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    cursor?: CourseOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * Teacher.department
   */
  export type Teacher$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    college_id: string | null
    code: string | null
    name: string | null
    departmentId: string | null
    type: $Enums.course_type | null
    hasTheoryComponent: boolean | null
    hasLabComponent: boolean | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    college_id: string | null
    code: string | null
    name: string | null
    departmentId: string | null
    type: $Enums.course_type | null
    hasTheoryComponent: boolean | null
    hasLabComponent: boolean | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    college_id: number
    code: number
    name: number
    departmentId: number
    type: number
    hasTheoryComponent: number
    hasLabComponent: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    id?: true
    college_id?: true
    code?: true
    name?: true
    departmentId?: true
    type?: true
    hasTheoryComponent?: true
    hasLabComponent?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    college_id?: true
    code?: true
    name?: true
    departmentId?: true
    type?: true
    hasTheoryComponent?: true
    hasLabComponent?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    college_id?: true
    code?: true
    name?: true
    departmentId?: true
    type?: true
    hasTheoryComponent?: true
    hasLabComponent?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    college_id: string
    code: string
    name: string
    departmentId: string | null
    type: $Enums.course_type | null
    hasTheoryComponent: boolean
    hasLabComponent: boolean
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    college_id?: boolean
    code?: boolean
    name?: boolean
    departmentId?: boolean
    type?: boolean
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: boolean | Course$courseElectiveGroupMembersArgs<ExtArgs>
    courseOfferings?: boolean | Course$courseOfferingsArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Course$departmentArgs<ExtArgs>
    openElectiveRestrictions?: boolean | Course$openElectiveRestrictionsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    college_id?: boolean
    code?: boolean
    name?: boolean
    departmentId?: boolean
    type?: boolean
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Course$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    college_id?: boolean
    code?: boolean
    name?: boolean
    departmentId?: boolean
    type?: boolean
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Course$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    college_id?: boolean
    code?: boolean
    name?: boolean
    departmentId?: boolean
    type?: boolean
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "college_id" | "code" | "name" | "departmentId" | "type" | "hasTheoryComponent" | "hasLabComponent", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseElectiveGroupMembers?: boolean | Course$courseElectiveGroupMembersArgs<ExtArgs>
    courseOfferings?: boolean | Course$courseOfferingsArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Course$departmentArgs<ExtArgs>
    openElectiveRestrictions?: boolean | Course$openElectiveRestrictionsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Course$departmentArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | Course$departmentArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      courseElectiveGroupMembers: Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>[]
      courseOfferings: Prisma.$CourseOfferingPayload<ExtArgs>[]
      colleges: Prisma.$CollegePayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      openElectiveRestrictions: Prisma.$OpenElectiveRestrictionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      college_id: string
      code: string
      name: string
      departmentId: string | null
      type: $Enums.course_type | null
      hasTheoryComponent: boolean
      hasLabComponent: boolean
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseElectiveGroupMembers<T extends Course$courseElectiveGroupMembersArgs<ExtArgs> = {}>(args?: Subset<T, Course$courseElectiveGroupMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courseOfferings<T extends Course$courseOfferingsArgs<ExtArgs> = {}>(args?: Subset<T, Course$courseOfferingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    colleges<T extends CollegeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollegeDefaultArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends Course$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Course$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    openElectiveRestrictions<T extends Course$openElectiveRestrictionsArgs<ExtArgs> = {}>(args?: Subset<T, Course$openElectiveRestrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly college_id: FieldRef<"Course", 'String'>
    readonly code: FieldRef<"Course", 'String'>
    readonly name: FieldRef<"Course", 'String'>
    readonly departmentId: FieldRef<"Course", 'String'>
    readonly type: FieldRef<"Course", 'course_type'>
    readonly hasTheoryComponent: FieldRef<"Course", 'Boolean'>
    readonly hasLabComponent: FieldRef<"Course", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.courseElectiveGroupMembers
   */
  export type Course$courseElectiveGroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    where?: CourseElectiveGroupMemberWhereInput
    orderBy?: CourseElectiveGroupMemberOrderByWithRelationInput | CourseElectiveGroupMemberOrderByWithRelationInput[]
    cursor?: CourseElectiveGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseElectiveGroupMemberScalarFieldEnum | CourseElectiveGroupMemberScalarFieldEnum[]
  }

  /**
   * Course.courseOfferings
   */
  export type Course$courseOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    where?: CourseOfferingWhereInput
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    cursor?: CourseOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * Course.department
   */
  export type Course$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Course.openElectiveRestrictions
   */
  export type Course$openElectiveRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    where?: OpenElectiveRestrictionWhereInput
    orderBy?: OpenElectiveRestrictionOrderByWithRelationInput | OpenElectiveRestrictionOrderByWithRelationInput[]
    cursor?: OpenElectiveRestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpenElectiveRestrictionScalarFieldEnum | OpenElectiveRestrictionScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentElectiveGroup
   */

  export type AggregateDepartmentElectiveGroup = {
    _count: DepartmentElectiveGroupCountAggregateOutputType | null
    _avg: DepartmentElectiveGroupAvgAggregateOutputType | null
    _sum: DepartmentElectiveGroupSumAggregateOutputType | null
    _min: DepartmentElectiveGroupMinAggregateOutputType | null
    _max: DepartmentElectiveGroupMaxAggregateOutputType | null
  }

  export type DepartmentElectiveGroupAvgAggregateOutputType = {
    semester: number | null
    batchYear: number | null
  }

  export type DepartmentElectiveGroupSumAggregateOutputType = {
    semester: number | null
    batchYear: number | null
  }

  export type DepartmentElectiveGroupMinAggregateOutputType = {
    id: string | null
    college_id: string | null
    name: string | null
    departmentId: string | null
    semester: number | null
    batchYear: number | null
  }

  export type DepartmentElectiveGroupMaxAggregateOutputType = {
    id: string | null
    college_id: string | null
    name: string | null
    departmentId: string | null
    semester: number | null
    batchYear: number | null
  }

  export type DepartmentElectiveGroupCountAggregateOutputType = {
    id: number
    college_id: number
    name: number
    departmentId: number
    semester: number
    batchYear: number
    _all: number
  }


  export type DepartmentElectiveGroupAvgAggregateInputType = {
    semester?: true
    batchYear?: true
  }

  export type DepartmentElectiveGroupSumAggregateInputType = {
    semester?: true
    batchYear?: true
  }

  export type DepartmentElectiveGroupMinAggregateInputType = {
    id?: true
    college_id?: true
    name?: true
    departmentId?: true
    semester?: true
    batchYear?: true
  }

  export type DepartmentElectiveGroupMaxAggregateInputType = {
    id?: true
    college_id?: true
    name?: true
    departmentId?: true
    semester?: true
    batchYear?: true
  }

  export type DepartmentElectiveGroupCountAggregateInputType = {
    id?: true
    college_id?: true
    name?: true
    departmentId?: true
    semester?: true
    batchYear?: true
    _all?: true
  }

  export type DepartmentElectiveGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentElectiveGroup to aggregate.
     */
    where?: DepartmentElectiveGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentElectiveGroups to fetch.
     */
    orderBy?: DepartmentElectiveGroupOrderByWithRelationInput | DepartmentElectiveGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentElectiveGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentElectiveGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentElectiveGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentElectiveGroups
    **/
    _count?: true | DepartmentElectiveGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentElectiveGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentElectiveGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentElectiveGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentElectiveGroupMaxAggregateInputType
  }

  export type GetDepartmentElectiveGroupAggregateType<T extends DepartmentElectiveGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentElectiveGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentElectiveGroup[P]>
      : GetScalarType<T[P], AggregateDepartmentElectiveGroup[P]>
  }




  export type DepartmentElectiveGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentElectiveGroupWhereInput
    orderBy?: DepartmentElectiveGroupOrderByWithAggregationInput | DepartmentElectiveGroupOrderByWithAggregationInput[]
    by: DepartmentElectiveGroupScalarFieldEnum[] | DepartmentElectiveGroupScalarFieldEnum
    having?: DepartmentElectiveGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentElectiveGroupCountAggregateInputType | true
    _avg?: DepartmentElectiveGroupAvgAggregateInputType
    _sum?: DepartmentElectiveGroupSumAggregateInputType
    _min?: DepartmentElectiveGroupMinAggregateInputType
    _max?: DepartmentElectiveGroupMaxAggregateInputType
  }

  export type DepartmentElectiveGroupGroupByOutputType = {
    id: string
    college_id: string
    name: string
    departmentId: string
    semester: number
    batchYear: number
    _count: DepartmentElectiveGroupCountAggregateOutputType | null
    _avg: DepartmentElectiveGroupAvgAggregateOutputType | null
    _sum: DepartmentElectiveGroupSumAggregateOutputType | null
    _min: DepartmentElectiveGroupMinAggregateOutputType | null
    _max: DepartmentElectiveGroupMaxAggregateOutputType | null
  }

  type GetDepartmentElectiveGroupGroupByPayload<T extends DepartmentElectiveGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentElectiveGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentElectiveGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentElectiveGroupGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentElectiveGroupGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentElectiveGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    college_id?: boolean
    name?: boolean
    departmentId?: boolean
    semester?: boolean
    batchYear?: boolean
    courseElectiveGroupMembers?: boolean | DepartmentElectiveGroup$courseElectiveGroupMembersArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    _count?: boolean | DepartmentElectiveGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentElectiveGroup"]>

  export type DepartmentElectiveGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    college_id?: boolean
    name?: boolean
    departmentId?: boolean
    semester?: boolean
    batchYear?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentElectiveGroup"]>

  export type DepartmentElectiveGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    college_id?: boolean
    name?: boolean
    departmentId?: boolean
    semester?: boolean
    batchYear?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentElectiveGroup"]>

  export type DepartmentElectiveGroupSelectScalar = {
    id?: boolean
    college_id?: boolean
    name?: boolean
    departmentId?: boolean
    semester?: boolean
    batchYear?: boolean
  }

  export type DepartmentElectiveGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "college_id" | "name" | "departmentId" | "semester" | "batchYear", ExtArgs["result"]["departmentElectiveGroup"]>
  export type DepartmentElectiveGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseElectiveGroupMembers?: boolean | DepartmentElectiveGroup$courseElectiveGroupMembersArgs<ExtArgs>
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    _count?: boolean | DepartmentElectiveGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentElectiveGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type DepartmentElectiveGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $DepartmentElectiveGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentElectiveGroup"
    objects: {
      courseElectiveGroupMembers: Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>[]
      colleges: Prisma.$CollegePayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      college_id: string
      name: string
      departmentId: string
      semester: number
      batchYear: number
    }, ExtArgs["result"]["departmentElectiveGroup"]>
    composites: {}
  }

  type DepartmentElectiveGroupGetPayload<S extends boolean | null | undefined | DepartmentElectiveGroupDefaultArgs> = $Result.GetResult<Prisma.$DepartmentElectiveGroupPayload, S>

  type DepartmentElectiveGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentElectiveGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentElectiveGroupCountAggregateInputType | true
    }

  export interface DepartmentElectiveGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentElectiveGroup'], meta: { name: 'DepartmentElectiveGroup' } }
    /**
     * Find zero or one DepartmentElectiveGroup that matches the filter.
     * @param {DepartmentElectiveGroupFindUniqueArgs} args - Arguments to find a DepartmentElectiveGroup
     * @example
     * // Get one DepartmentElectiveGroup
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentElectiveGroupFindUniqueArgs>(args: SelectSubset<T, DepartmentElectiveGroupFindUniqueArgs<ExtArgs>>): Prisma__DepartmentElectiveGroupClient<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DepartmentElectiveGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentElectiveGroupFindUniqueOrThrowArgs} args - Arguments to find a DepartmentElectiveGroup
     * @example
     * // Get one DepartmentElectiveGroup
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentElectiveGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentElectiveGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentElectiveGroupClient<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentElectiveGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentElectiveGroupFindFirstArgs} args - Arguments to find a DepartmentElectiveGroup
     * @example
     * // Get one DepartmentElectiveGroup
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentElectiveGroupFindFirstArgs>(args?: SelectSubset<T, DepartmentElectiveGroupFindFirstArgs<ExtArgs>>): Prisma__DepartmentElectiveGroupClient<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepartmentElectiveGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentElectiveGroupFindFirstOrThrowArgs} args - Arguments to find a DepartmentElectiveGroup
     * @example
     * // Get one DepartmentElectiveGroup
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentElectiveGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentElectiveGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentElectiveGroupClient<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DepartmentElectiveGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentElectiveGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentElectiveGroups
     * const departmentElectiveGroups = await prisma.departmentElectiveGroup.findMany()
     * 
     * // Get first 10 DepartmentElectiveGroups
     * const departmentElectiveGroups = await prisma.departmentElectiveGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentElectiveGroupWithIdOnly = await prisma.departmentElectiveGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentElectiveGroupFindManyArgs>(args?: SelectSubset<T, DepartmentElectiveGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DepartmentElectiveGroup.
     * @param {DepartmentElectiveGroupCreateArgs} args - Arguments to create a DepartmentElectiveGroup.
     * @example
     * // Create one DepartmentElectiveGroup
     * const DepartmentElectiveGroup = await prisma.departmentElectiveGroup.create({
     *   data: {
     *     // ... data to create a DepartmentElectiveGroup
     *   }
     * })
     * 
     */
    create<T extends DepartmentElectiveGroupCreateArgs>(args: SelectSubset<T, DepartmentElectiveGroupCreateArgs<ExtArgs>>): Prisma__DepartmentElectiveGroupClient<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DepartmentElectiveGroups.
     * @param {DepartmentElectiveGroupCreateManyArgs} args - Arguments to create many DepartmentElectiveGroups.
     * @example
     * // Create many DepartmentElectiveGroups
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentElectiveGroupCreateManyArgs>(args?: SelectSubset<T, DepartmentElectiveGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentElectiveGroups and returns the data saved in the database.
     * @param {DepartmentElectiveGroupCreateManyAndReturnArgs} args - Arguments to create many DepartmentElectiveGroups.
     * @example
     * // Create many DepartmentElectiveGroups
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentElectiveGroups and only return the `id`
     * const departmentElectiveGroupWithIdOnly = await prisma.departmentElectiveGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentElectiveGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentElectiveGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DepartmentElectiveGroup.
     * @param {DepartmentElectiveGroupDeleteArgs} args - Arguments to delete one DepartmentElectiveGroup.
     * @example
     * // Delete one DepartmentElectiveGroup
     * const DepartmentElectiveGroup = await prisma.departmentElectiveGroup.delete({
     *   where: {
     *     // ... filter to delete one DepartmentElectiveGroup
     *   }
     * })
     * 
     */
    delete<T extends DepartmentElectiveGroupDeleteArgs>(args: SelectSubset<T, DepartmentElectiveGroupDeleteArgs<ExtArgs>>): Prisma__DepartmentElectiveGroupClient<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DepartmentElectiveGroup.
     * @param {DepartmentElectiveGroupUpdateArgs} args - Arguments to update one DepartmentElectiveGroup.
     * @example
     * // Update one DepartmentElectiveGroup
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentElectiveGroupUpdateArgs>(args: SelectSubset<T, DepartmentElectiveGroupUpdateArgs<ExtArgs>>): Prisma__DepartmentElectiveGroupClient<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DepartmentElectiveGroups.
     * @param {DepartmentElectiveGroupDeleteManyArgs} args - Arguments to filter DepartmentElectiveGroups to delete.
     * @example
     * // Delete a few DepartmentElectiveGroups
     * const { count } = await prisma.departmentElectiveGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentElectiveGroupDeleteManyArgs>(args?: SelectSubset<T, DepartmentElectiveGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentElectiveGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentElectiveGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentElectiveGroups
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentElectiveGroupUpdateManyArgs>(args: SelectSubset<T, DepartmentElectiveGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentElectiveGroups and returns the data updated in the database.
     * @param {DepartmentElectiveGroupUpdateManyAndReturnArgs} args - Arguments to update many DepartmentElectiveGroups.
     * @example
     * // Update many DepartmentElectiveGroups
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DepartmentElectiveGroups and only return the `id`
     * const departmentElectiveGroupWithIdOnly = await prisma.departmentElectiveGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentElectiveGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentElectiveGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DepartmentElectiveGroup.
     * @param {DepartmentElectiveGroupUpsertArgs} args - Arguments to update or create a DepartmentElectiveGroup.
     * @example
     * // Update or create a DepartmentElectiveGroup
     * const departmentElectiveGroup = await prisma.departmentElectiveGroup.upsert({
     *   create: {
     *     // ... data to create a DepartmentElectiveGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentElectiveGroup we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentElectiveGroupUpsertArgs>(args: SelectSubset<T, DepartmentElectiveGroupUpsertArgs<ExtArgs>>): Prisma__DepartmentElectiveGroupClient<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DepartmentElectiveGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentElectiveGroupCountArgs} args - Arguments to filter DepartmentElectiveGroups to count.
     * @example
     * // Count the number of DepartmentElectiveGroups
     * const count = await prisma.departmentElectiveGroup.count({
     *   where: {
     *     // ... the filter for the DepartmentElectiveGroups we want to count
     *   }
     * })
    **/
    count<T extends DepartmentElectiveGroupCountArgs>(
      args?: Subset<T, DepartmentElectiveGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentElectiveGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentElectiveGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentElectiveGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentElectiveGroupAggregateArgs>(args: Subset<T, DepartmentElectiveGroupAggregateArgs>): Prisma.PrismaPromise<GetDepartmentElectiveGroupAggregateType<T>>

    /**
     * Group by DepartmentElectiveGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentElectiveGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentElectiveGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentElectiveGroupGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentElectiveGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentElectiveGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentElectiveGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentElectiveGroup model
   */
  readonly fields: DepartmentElectiveGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentElectiveGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentElectiveGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseElectiveGroupMembers<T extends DepartmentElectiveGroup$courseElectiveGroupMembersArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentElectiveGroup$courseElectiveGroupMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    colleges<T extends CollegeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollegeDefaultArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentElectiveGroup model
   */
  interface DepartmentElectiveGroupFieldRefs {
    readonly id: FieldRef<"DepartmentElectiveGroup", 'String'>
    readonly college_id: FieldRef<"DepartmentElectiveGroup", 'String'>
    readonly name: FieldRef<"DepartmentElectiveGroup", 'String'>
    readonly departmentId: FieldRef<"DepartmentElectiveGroup", 'String'>
    readonly semester: FieldRef<"DepartmentElectiveGroup", 'Int'>
    readonly batchYear: FieldRef<"DepartmentElectiveGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentElectiveGroup findUnique
   */
  export type DepartmentElectiveGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentElectiveGroup to fetch.
     */
    where: DepartmentElectiveGroupWhereUniqueInput
  }

  /**
   * DepartmentElectiveGroup findUniqueOrThrow
   */
  export type DepartmentElectiveGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentElectiveGroup to fetch.
     */
    where: DepartmentElectiveGroupWhereUniqueInput
  }

  /**
   * DepartmentElectiveGroup findFirst
   */
  export type DepartmentElectiveGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentElectiveGroup to fetch.
     */
    where?: DepartmentElectiveGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentElectiveGroups to fetch.
     */
    orderBy?: DepartmentElectiveGroupOrderByWithRelationInput | DepartmentElectiveGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentElectiveGroups.
     */
    cursor?: DepartmentElectiveGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentElectiveGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentElectiveGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentElectiveGroups.
     */
    distinct?: DepartmentElectiveGroupScalarFieldEnum | DepartmentElectiveGroupScalarFieldEnum[]
  }

  /**
   * DepartmentElectiveGroup findFirstOrThrow
   */
  export type DepartmentElectiveGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentElectiveGroup to fetch.
     */
    where?: DepartmentElectiveGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentElectiveGroups to fetch.
     */
    orderBy?: DepartmentElectiveGroupOrderByWithRelationInput | DepartmentElectiveGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentElectiveGroups.
     */
    cursor?: DepartmentElectiveGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentElectiveGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentElectiveGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentElectiveGroups.
     */
    distinct?: DepartmentElectiveGroupScalarFieldEnum | DepartmentElectiveGroupScalarFieldEnum[]
  }

  /**
   * DepartmentElectiveGroup findMany
   */
  export type DepartmentElectiveGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentElectiveGroups to fetch.
     */
    where?: DepartmentElectiveGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentElectiveGroups to fetch.
     */
    orderBy?: DepartmentElectiveGroupOrderByWithRelationInput | DepartmentElectiveGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentElectiveGroups.
     */
    cursor?: DepartmentElectiveGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentElectiveGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentElectiveGroups.
     */
    skip?: number
    distinct?: DepartmentElectiveGroupScalarFieldEnum | DepartmentElectiveGroupScalarFieldEnum[]
  }

  /**
   * DepartmentElectiveGroup create
   */
  export type DepartmentElectiveGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentElectiveGroup.
     */
    data: XOR<DepartmentElectiveGroupCreateInput, DepartmentElectiveGroupUncheckedCreateInput>
  }

  /**
   * DepartmentElectiveGroup createMany
   */
  export type DepartmentElectiveGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentElectiveGroups.
     */
    data: DepartmentElectiveGroupCreateManyInput | DepartmentElectiveGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentElectiveGroup createManyAndReturn
   */
  export type DepartmentElectiveGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * The data used to create many DepartmentElectiveGroups.
     */
    data: DepartmentElectiveGroupCreateManyInput | DepartmentElectiveGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentElectiveGroup update
   */
  export type DepartmentElectiveGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentElectiveGroup.
     */
    data: XOR<DepartmentElectiveGroupUpdateInput, DepartmentElectiveGroupUncheckedUpdateInput>
    /**
     * Choose, which DepartmentElectiveGroup to update.
     */
    where: DepartmentElectiveGroupWhereUniqueInput
  }

  /**
   * DepartmentElectiveGroup updateMany
   */
  export type DepartmentElectiveGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentElectiveGroups.
     */
    data: XOR<DepartmentElectiveGroupUpdateManyMutationInput, DepartmentElectiveGroupUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentElectiveGroups to update
     */
    where?: DepartmentElectiveGroupWhereInput
    /**
     * Limit how many DepartmentElectiveGroups to update.
     */
    limit?: number
  }

  /**
   * DepartmentElectiveGroup updateManyAndReturn
   */
  export type DepartmentElectiveGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * The data used to update DepartmentElectiveGroups.
     */
    data: XOR<DepartmentElectiveGroupUpdateManyMutationInput, DepartmentElectiveGroupUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentElectiveGroups to update
     */
    where?: DepartmentElectiveGroupWhereInput
    /**
     * Limit how many DepartmentElectiveGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentElectiveGroup upsert
   */
  export type DepartmentElectiveGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentElectiveGroup to update in case it exists.
     */
    where: DepartmentElectiveGroupWhereUniqueInput
    /**
     * In case the DepartmentElectiveGroup found by the `where` argument doesn't exist, create a new DepartmentElectiveGroup with this data.
     */
    create: XOR<DepartmentElectiveGroupCreateInput, DepartmentElectiveGroupUncheckedCreateInput>
    /**
     * In case the DepartmentElectiveGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentElectiveGroupUpdateInput, DepartmentElectiveGroupUncheckedUpdateInput>
  }

  /**
   * DepartmentElectiveGroup delete
   */
  export type DepartmentElectiveGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
    /**
     * Filter which DepartmentElectiveGroup to delete.
     */
    where: DepartmentElectiveGroupWhereUniqueInput
  }

  /**
   * DepartmentElectiveGroup deleteMany
   */
  export type DepartmentElectiveGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentElectiveGroups to delete
     */
    where?: DepartmentElectiveGroupWhereInput
    /**
     * Limit how many DepartmentElectiveGroups to delete.
     */
    limit?: number
  }

  /**
   * DepartmentElectiveGroup.courseElectiveGroupMembers
   */
  export type DepartmentElectiveGroup$courseElectiveGroupMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    where?: CourseElectiveGroupMemberWhereInput
    orderBy?: CourseElectiveGroupMemberOrderByWithRelationInput | CourseElectiveGroupMemberOrderByWithRelationInput[]
    cursor?: CourseElectiveGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseElectiveGroupMemberScalarFieldEnum | CourseElectiveGroupMemberScalarFieldEnum[]
  }

  /**
   * DepartmentElectiveGroup without action
   */
  export type DepartmentElectiveGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentElectiveGroup
     */
    select?: DepartmentElectiveGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepartmentElectiveGroup
     */
    omit?: DepartmentElectiveGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentElectiveGroupInclude<ExtArgs> | null
  }


  /**
   * Model CourseElectiveGroupMember
   */

  export type AggregateCourseElectiveGroupMember = {
    _count: CourseElectiveGroupMemberCountAggregateOutputType | null
    _min: CourseElectiveGroupMemberMinAggregateOutputType | null
    _max: CourseElectiveGroupMemberMaxAggregateOutputType | null
  }

  export type CourseElectiveGroupMemberMinAggregateOutputType = {
    groupId: string | null
    courseId: string | null
  }

  export type CourseElectiveGroupMemberMaxAggregateOutputType = {
    groupId: string | null
    courseId: string | null
  }

  export type CourseElectiveGroupMemberCountAggregateOutputType = {
    groupId: number
    courseId: number
    _all: number
  }


  export type CourseElectiveGroupMemberMinAggregateInputType = {
    groupId?: true
    courseId?: true
  }

  export type CourseElectiveGroupMemberMaxAggregateInputType = {
    groupId?: true
    courseId?: true
  }

  export type CourseElectiveGroupMemberCountAggregateInputType = {
    groupId?: true
    courseId?: true
    _all?: true
  }

  export type CourseElectiveGroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseElectiveGroupMember to aggregate.
     */
    where?: CourseElectiveGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseElectiveGroupMembers to fetch.
     */
    orderBy?: CourseElectiveGroupMemberOrderByWithRelationInput | CourseElectiveGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseElectiveGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseElectiveGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseElectiveGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseElectiveGroupMembers
    **/
    _count?: true | CourseElectiveGroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseElectiveGroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseElectiveGroupMemberMaxAggregateInputType
  }

  export type GetCourseElectiveGroupMemberAggregateType<T extends CourseElectiveGroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseElectiveGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseElectiveGroupMember[P]>
      : GetScalarType<T[P], AggregateCourseElectiveGroupMember[P]>
  }




  export type CourseElectiveGroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseElectiveGroupMemberWhereInput
    orderBy?: CourseElectiveGroupMemberOrderByWithAggregationInput | CourseElectiveGroupMemberOrderByWithAggregationInput[]
    by: CourseElectiveGroupMemberScalarFieldEnum[] | CourseElectiveGroupMemberScalarFieldEnum
    having?: CourseElectiveGroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseElectiveGroupMemberCountAggregateInputType | true
    _min?: CourseElectiveGroupMemberMinAggregateInputType
    _max?: CourseElectiveGroupMemberMaxAggregateInputType
  }

  export type CourseElectiveGroupMemberGroupByOutputType = {
    groupId: string
    courseId: string
    _count: CourseElectiveGroupMemberCountAggregateOutputType | null
    _min: CourseElectiveGroupMemberMinAggregateOutputType | null
    _max: CourseElectiveGroupMemberMaxAggregateOutputType | null
  }

  type GetCourseElectiveGroupMemberGroupByPayload<T extends CourseElectiveGroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseElectiveGroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseElectiveGroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseElectiveGroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], CourseElectiveGroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type CourseElectiveGroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupId?: boolean
    courseId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    group?: boolean | DepartmentElectiveGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseElectiveGroupMember"]>

  export type CourseElectiveGroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupId?: boolean
    courseId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    group?: boolean | DepartmentElectiveGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseElectiveGroupMember"]>

  export type CourseElectiveGroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupId?: boolean
    courseId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    group?: boolean | DepartmentElectiveGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseElectiveGroupMember"]>

  export type CourseElectiveGroupMemberSelectScalar = {
    groupId?: boolean
    courseId?: boolean
  }

  export type CourseElectiveGroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"groupId" | "courseId", ExtArgs["result"]["courseElectiveGroupMember"]>
  export type CourseElectiveGroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    group?: boolean | DepartmentElectiveGroupDefaultArgs<ExtArgs>
  }
  export type CourseElectiveGroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    group?: boolean | DepartmentElectiveGroupDefaultArgs<ExtArgs>
  }
  export type CourseElectiveGroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    group?: boolean | DepartmentElectiveGroupDefaultArgs<ExtArgs>
  }

  export type $CourseElectiveGroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseElectiveGroupMember"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      group: Prisma.$DepartmentElectiveGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      groupId: string
      courseId: string
    }, ExtArgs["result"]["courseElectiveGroupMember"]>
    composites: {}
  }

  type CourseElectiveGroupMemberGetPayload<S extends boolean | null | undefined | CourseElectiveGroupMemberDefaultArgs> = $Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload, S>

  type CourseElectiveGroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseElectiveGroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseElectiveGroupMemberCountAggregateInputType | true
    }

  export interface CourseElectiveGroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseElectiveGroupMember'], meta: { name: 'CourseElectiveGroupMember' } }
    /**
     * Find zero or one CourseElectiveGroupMember that matches the filter.
     * @param {CourseElectiveGroupMemberFindUniqueArgs} args - Arguments to find a CourseElectiveGroupMember
     * @example
     * // Get one CourseElectiveGroupMember
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseElectiveGroupMemberFindUniqueArgs>(args: SelectSubset<T, CourseElectiveGroupMemberFindUniqueArgs<ExtArgs>>): Prisma__CourseElectiveGroupMemberClient<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseElectiveGroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseElectiveGroupMemberFindUniqueOrThrowArgs} args - Arguments to find a CourseElectiveGroupMember
     * @example
     * // Get one CourseElectiveGroupMember
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseElectiveGroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseElectiveGroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseElectiveGroupMemberClient<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseElectiveGroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseElectiveGroupMemberFindFirstArgs} args - Arguments to find a CourseElectiveGroupMember
     * @example
     * // Get one CourseElectiveGroupMember
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseElectiveGroupMemberFindFirstArgs>(args?: SelectSubset<T, CourseElectiveGroupMemberFindFirstArgs<ExtArgs>>): Prisma__CourseElectiveGroupMemberClient<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseElectiveGroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseElectiveGroupMemberFindFirstOrThrowArgs} args - Arguments to find a CourseElectiveGroupMember
     * @example
     * // Get one CourseElectiveGroupMember
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseElectiveGroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseElectiveGroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseElectiveGroupMemberClient<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseElectiveGroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseElectiveGroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseElectiveGroupMembers
     * const courseElectiveGroupMembers = await prisma.courseElectiveGroupMember.findMany()
     * 
     * // Get first 10 CourseElectiveGroupMembers
     * const courseElectiveGroupMembers = await prisma.courseElectiveGroupMember.findMany({ take: 10 })
     * 
     * // Only select the `groupId`
     * const courseElectiveGroupMemberWithGroupIdOnly = await prisma.courseElectiveGroupMember.findMany({ select: { groupId: true } })
     * 
     */
    findMany<T extends CourseElectiveGroupMemberFindManyArgs>(args?: SelectSubset<T, CourseElectiveGroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseElectiveGroupMember.
     * @param {CourseElectiveGroupMemberCreateArgs} args - Arguments to create a CourseElectiveGroupMember.
     * @example
     * // Create one CourseElectiveGroupMember
     * const CourseElectiveGroupMember = await prisma.courseElectiveGroupMember.create({
     *   data: {
     *     // ... data to create a CourseElectiveGroupMember
     *   }
     * })
     * 
     */
    create<T extends CourseElectiveGroupMemberCreateArgs>(args: SelectSubset<T, CourseElectiveGroupMemberCreateArgs<ExtArgs>>): Prisma__CourseElectiveGroupMemberClient<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseElectiveGroupMembers.
     * @param {CourseElectiveGroupMemberCreateManyArgs} args - Arguments to create many CourseElectiveGroupMembers.
     * @example
     * // Create many CourseElectiveGroupMembers
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseElectiveGroupMemberCreateManyArgs>(args?: SelectSubset<T, CourseElectiveGroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseElectiveGroupMembers and returns the data saved in the database.
     * @param {CourseElectiveGroupMemberCreateManyAndReturnArgs} args - Arguments to create many CourseElectiveGroupMembers.
     * @example
     * // Create many CourseElectiveGroupMembers
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseElectiveGroupMembers and only return the `groupId`
     * const courseElectiveGroupMemberWithGroupIdOnly = await prisma.courseElectiveGroupMember.createManyAndReturn({
     *   select: { groupId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseElectiveGroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseElectiveGroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseElectiveGroupMember.
     * @param {CourseElectiveGroupMemberDeleteArgs} args - Arguments to delete one CourseElectiveGroupMember.
     * @example
     * // Delete one CourseElectiveGroupMember
     * const CourseElectiveGroupMember = await prisma.courseElectiveGroupMember.delete({
     *   where: {
     *     // ... filter to delete one CourseElectiveGroupMember
     *   }
     * })
     * 
     */
    delete<T extends CourseElectiveGroupMemberDeleteArgs>(args: SelectSubset<T, CourseElectiveGroupMemberDeleteArgs<ExtArgs>>): Prisma__CourseElectiveGroupMemberClient<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseElectiveGroupMember.
     * @param {CourseElectiveGroupMemberUpdateArgs} args - Arguments to update one CourseElectiveGroupMember.
     * @example
     * // Update one CourseElectiveGroupMember
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseElectiveGroupMemberUpdateArgs>(args: SelectSubset<T, CourseElectiveGroupMemberUpdateArgs<ExtArgs>>): Prisma__CourseElectiveGroupMemberClient<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseElectiveGroupMembers.
     * @param {CourseElectiveGroupMemberDeleteManyArgs} args - Arguments to filter CourseElectiveGroupMembers to delete.
     * @example
     * // Delete a few CourseElectiveGroupMembers
     * const { count } = await prisma.courseElectiveGroupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseElectiveGroupMemberDeleteManyArgs>(args?: SelectSubset<T, CourseElectiveGroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseElectiveGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseElectiveGroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseElectiveGroupMembers
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseElectiveGroupMemberUpdateManyArgs>(args: SelectSubset<T, CourseElectiveGroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseElectiveGroupMembers and returns the data updated in the database.
     * @param {CourseElectiveGroupMemberUpdateManyAndReturnArgs} args - Arguments to update many CourseElectiveGroupMembers.
     * @example
     * // Update many CourseElectiveGroupMembers
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseElectiveGroupMembers and only return the `groupId`
     * const courseElectiveGroupMemberWithGroupIdOnly = await prisma.courseElectiveGroupMember.updateManyAndReturn({
     *   select: { groupId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseElectiveGroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseElectiveGroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseElectiveGroupMember.
     * @param {CourseElectiveGroupMemberUpsertArgs} args - Arguments to update or create a CourseElectiveGroupMember.
     * @example
     * // Update or create a CourseElectiveGroupMember
     * const courseElectiveGroupMember = await prisma.courseElectiveGroupMember.upsert({
     *   create: {
     *     // ... data to create a CourseElectiveGroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseElectiveGroupMember we want to update
     *   }
     * })
     */
    upsert<T extends CourseElectiveGroupMemberUpsertArgs>(args: SelectSubset<T, CourseElectiveGroupMemberUpsertArgs<ExtArgs>>): Prisma__CourseElectiveGroupMemberClient<$Result.GetResult<Prisma.$CourseElectiveGroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseElectiveGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseElectiveGroupMemberCountArgs} args - Arguments to filter CourseElectiveGroupMembers to count.
     * @example
     * // Count the number of CourseElectiveGroupMembers
     * const count = await prisma.courseElectiveGroupMember.count({
     *   where: {
     *     // ... the filter for the CourseElectiveGroupMembers we want to count
     *   }
     * })
    **/
    count<T extends CourseElectiveGroupMemberCountArgs>(
      args?: Subset<T, CourseElectiveGroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseElectiveGroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseElectiveGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseElectiveGroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseElectiveGroupMemberAggregateArgs>(args: Subset<T, CourseElectiveGroupMemberAggregateArgs>): Prisma.PrismaPromise<GetCourseElectiveGroupMemberAggregateType<T>>

    /**
     * Group by CourseElectiveGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseElectiveGroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseElectiveGroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseElectiveGroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: CourseElectiveGroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseElectiveGroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseElectiveGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseElectiveGroupMember model
   */
  readonly fields: CourseElectiveGroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseElectiveGroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseElectiveGroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends DepartmentElectiveGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentElectiveGroupDefaultArgs<ExtArgs>>): Prisma__DepartmentElectiveGroupClient<$Result.GetResult<Prisma.$DepartmentElectiveGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseElectiveGroupMember model
   */
  interface CourseElectiveGroupMemberFieldRefs {
    readonly groupId: FieldRef<"CourseElectiveGroupMember", 'String'>
    readonly courseId: FieldRef<"CourseElectiveGroupMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseElectiveGroupMember findUnique
   */
  export type CourseElectiveGroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CourseElectiveGroupMember to fetch.
     */
    where: CourseElectiveGroupMemberWhereUniqueInput
  }

  /**
   * CourseElectiveGroupMember findUniqueOrThrow
   */
  export type CourseElectiveGroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CourseElectiveGroupMember to fetch.
     */
    where: CourseElectiveGroupMemberWhereUniqueInput
  }

  /**
   * CourseElectiveGroupMember findFirst
   */
  export type CourseElectiveGroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CourseElectiveGroupMember to fetch.
     */
    where?: CourseElectiveGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseElectiveGroupMembers to fetch.
     */
    orderBy?: CourseElectiveGroupMemberOrderByWithRelationInput | CourseElectiveGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseElectiveGroupMembers.
     */
    cursor?: CourseElectiveGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseElectiveGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseElectiveGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseElectiveGroupMembers.
     */
    distinct?: CourseElectiveGroupMemberScalarFieldEnum | CourseElectiveGroupMemberScalarFieldEnum[]
  }

  /**
   * CourseElectiveGroupMember findFirstOrThrow
   */
  export type CourseElectiveGroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CourseElectiveGroupMember to fetch.
     */
    where?: CourseElectiveGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseElectiveGroupMembers to fetch.
     */
    orderBy?: CourseElectiveGroupMemberOrderByWithRelationInput | CourseElectiveGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseElectiveGroupMembers.
     */
    cursor?: CourseElectiveGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseElectiveGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseElectiveGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseElectiveGroupMembers.
     */
    distinct?: CourseElectiveGroupMemberScalarFieldEnum | CourseElectiveGroupMemberScalarFieldEnum[]
  }

  /**
   * CourseElectiveGroupMember findMany
   */
  export type CourseElectiveGroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CourseElectiveGroupMembers to fetch.
     */
    where?: CourseElectiveGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseElectiveGroupMembers to fetch.
     */
    orderBy?: CourseElectiveGroupMemberOrderByWithRelationInput | CourseElectiveGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseElectiveGroupMembers.
     */
    cursor?: CourseElectiveGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseElectiveGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseElectiveGroupMembers.
     */
    skip?: number
    distinct?: CourseElectiveGroupMemberScalarFieldEnum | CourseElectiveGroupMemberScalarFieldEnum[]
  }

  /**
   * CourseElectiveGroupMember create
   */
  export type CourseElectiveGroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseElectiveGroupMember.
     */
    data: XOR<CourseElectiveGroupMemberCreateInput, CourseElectiveGroupMemberUncheckedCreateInput>
  }

  /**
   * CourseElectiveGroupMember createMany
   */
  export type CourseElectiveGroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseElectiveGroupMembers.
     */
    data: CourseElectiveGroupMemberCreateManyInput | CourseElectiveGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseElectiveGroupMember createManyAndReturn
   */
  export type CourseElectiveGroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many CourseElectiveGroupMembers.
     */
    data: CourseElectiveGroupMemberCreateManyInput | CourseElectiveGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseElectiveGroupMember update
   */
  export type CourseElectiveGroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseElectiveGroupMember.
     */
    data: XOR<CourseElectiveGroupMemberUpdateInput, CourseElectiveGroupMemberUncheckedUpdateInput>
    /**
     * Choose, which CourseElectiveGroupMember to update.
     */
    where: CourseElectiveGroupMemberWhereUniqueInput
  }

  /**
   * CourseElectiveGroupMember updateMany
   */
  export type CourseElectiveGroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseElectiveGroupMembers.
     */
    data: XOR<CourseElectiveGroupMemberUpdateManyMutationInput, CourseElectiveGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which CourseElectiveGroupMembers to update
     */
    where?: CourseElectiveGroupMemberWhereInput
    /**
     * Limit how many CourseElectiveGroupMembers to update.
     */
    limit?: number
  }

  /**
   * CourseElectiveGroupMember updateManyAndReturn
   */
  export type CourseElectiveGroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update CourseElectiveGroupMembers.
     */
    data: XOR<CourseElectiveGroupMemberUpdateManyMutationInput, CourseElectiveGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which CourseElectiveGroupMembers to update
     */
    where?: CourseElectiveGroupMemberWhereInput
    /**
     * Limit how many CourseElectiveGroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseElectiveGroupMember upsert
   */
  export type CourseElectiveGroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseElectiveGroupMember to update in case it exists.
     */
    where: CourseElectiveGroupMemberWhereUniqueInput
    /**
     * In case the CourseElectiveGroupMember found by the `where` argument doesn't exist, create a new CourseElectiveGroupMember with this data.
     */
    create: XOR<CourseElectiveGroupMemberCreateInput, CourseElectiveGroupMemberUncheckedCreateInput>
    /**
     * In case the CourseElectiveGroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseElectiveGroupMemberUpdateInput, CourseElectiveGroupMemberUncheckedUpdateInput>
  }

  /**
   * CourseElectiveGroupMember delete
   */
  export type CourseElectiveGroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
    /**
     * Filter which CourseElectiveGroupMember to delete.
     */
    where: CourseElectiveGroupMemberWhereUniqueInput
  }

  /**
   * CourseElectiveGroupMember deleteMany
   */
  export type CourseElectiveGroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseElectiveGroupMembers to delete
     */
    where?: CourseElectiveGroupMemberWhereInput
    /**
     * Limit how many CourseElectiveGroupMembers to delete.
     */
    limit?: number
  }

  /**
   * CourseElectiveGroupMember without action
   */
  export type CourseElectiveGroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseElectiveGroupMember
     */
    select?: CourseElectiveGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseElectiveGroupMember
     */
    omit?: CourseElectiveGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseElectiveGroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model OpenElectiveRestriction
   */

  export type AggregateOpenElectiveRestriction = {
    _count: OpenElectiveRestrictionCountAggregateOutputType | null
    _min: OpenElectiveRestrictionMinAggregateOutputType | null
    _max: OpenElectiveRestrictionMaxAggregateOutputType | null
  }

  export type OpenElectiveRestrictionMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    restrictedDepartmentId: string | null
  }

  export type OpenElectiveRestrictionMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    restrictedDepartmentId: string | null
  }

  export type OpenElectiveRestrictionCountAggregateOutputType = {
    id: number
    courseId: number
    restrictedDepartmentId: number
    _all: number
  }


  export type OpenElectiveRestrictionMinAggregateInputType = {
    id?: true
    courseId?: true
    restrictedDepartmentId?: true
  }

  export type OpenElectiveRestrictionMaxAggregateInputType = {
    id?: true
    courseId?: true
    restrictedDepartmentId?: true
  }

  export type OpenElectiveRestrictionCountAggregateInputType = {
    id?: true
    courseId?: true
    restrictedDepartmentId?: true
    _all?: true
  }

  export type OpenElectiveRestrictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenElectiveRestriction to aggregate.
     */
    where?: OpenElectiveRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenElectiveRestrictions to fetch.
     */
    orderBy?: OpenElectiveRestrictionOrderByWithRelationInput | OpenElectiveRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenElectiveRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenElectiveRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenElectiveRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenElectiveRestrictions
    **/
    _count?: true | OpenElectiveRestrictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenElectiveRestrictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenElectiveRestrictionMaxAggregateInputType
  }

  export type GetOpenElectiveRestrictionAggregateType<T extends OpenElectiveRestrictionAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenElectiveRestriction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenElectiveRestriction[P]>
      : GetScalarType<T[P], AggregateOpenElectiveRestriction[P]>
  }




  export type OpenElectiveRestrictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenElectiveRestrictionWhereInput
    orderBy?: OpenElectiveRestrictionOrderByWithAggregationInput | OpenElectiveRestrictionOrderByWithAggregationInput[]
    by: OpenElectiveRestrictionScalarFieldEnum[] | OpenElectiveRestrictionScalarFieldEnum
    having?: OpenElectiveRestrictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenElectiveRestrictionCountAggregateInputType | true
    _min?: OpenElectiveRestrictionMinAggregateInputType
    _max?: OpenElectiveRestrictionMaxAggregateInputType
  }

  export type OpenElectiveRestrictionGroupByOutputType = {
    id: string
    courseId: string | null
    restrictedDepartmentId: string
    _count: OpenElectiveRestrictionCountAggregateOutputType | null
    _min: OpenElectiveRestrictionMinAggregateOutputType | null
    _max: OpenElectiveRestrictionMaxAggregateOutputType | null
  }

  type GetOpenElectiveRestrictionGroupByPayload<T extends OpenElectiveRestrictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenElectiveRestrictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenElectiveRestrictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenElectiveRestrictionGroupByOutputType[P]>
            : GetScalarType<T[P], OpenElectiveRestrictionGroupByOutputType[P]>
        }
      >
    >


  export type OpenElectiveRestrictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    restrictedDepartmentId?: boolean
    course?: boolean | OpenElectiveRestriction$courseArgs<ExtArgs>
    restrictedDepartment?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openElectiveRestriction"]>

  export type OpenElectiveRestrictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    restrictedDepartmentId?: boolean
    course?: boolean | OpenElectiveRestriction$courseArgs<ExtArgs>
    restrictedDepartment?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openElectiveRestriction"]>

  export type OpenElectiveRestrictionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    restrictedDepartmentId?: boolean
    course?: boolean | OpenElectiveRestriction$courseArgs<ExtArgs>
    restrictedDepartment?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openElectiveRestriction"]>

  export type OpenElectiveRestrictionSelectScalar = {
    id?: boolean
    courseId?: boolean
    restrictedDepartmentId?: boolean
  }

  export type OpenElectiveRestrictionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "restrictedDepartmentId", ExtArgs["result"]["openElectiveRestriction"]>
  export type OpenElectiveRestrictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | OpenElectiveRestriction$courseArgs<ExtArgs>
    restrictedDepartment?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type OpenElectiveRestrictionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | OpenElectiveRestriction$courseArgs<ExtArgs>
    restrictedDepartment?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type OpenElectiveRestrictionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | OpenElectiveRestriction$courseArgs<ExtArgs>
    restrictedDepartment?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $OpenElectiveRestrictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenElectiveRestriction"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      restrictedDepartment: Prisma.$DepartmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string | null
      restrictedDepartmentId: string
    }, ExtArgs["result"]["openElectiveRestriction"]>
    composites: {}
  }

  type OpenElectiveRestrictionGetPayload<S extends boolean | null | undefined | OpenElectiveRestrictionDefaultArgs> = $Result.GetResult<Prisma.$OpenElectiveRestrictionPayload, S>

  type OpenElectiveRestrictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpenElectiveRestrictionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpenElectiveRestrictionCountAggregateInputType | true
    }

  export interface OpenElectiveRestrictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenElectiveRestriction'], meta: { name: 'OpenElectiveRestriction' } }
    /**
     * Find zero or one OpenElectiveRestriction that matches the filter.
     * @param {OpenElectiveRestrictionFindUniqueArgs} args - Arguments to find a OpenElectiveRestriction
     * @example
     * // Get one OpenElectiveRestriction
     * const openElectiveRestriction = await prisma.openElectiveRestriction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenElectiveRestrictionFindUniqueArgs>(args: SelectSubset<T, OpenElectiveRestrictionFindUniqueArgs<ExtArgs>>): Prisma__OpenElectiveRestrictionClient<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OpenElectiveRestriction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpenElectiveRestrictionFindUniqueOrThrowArgs} args - Arguments to find a OpenElectiveRestriction
     * @example
     * // Get one OpenElectiveRestriction
     * const openElectiveRestriction = await prisma.openElectiveRestriction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenElectiveRestrictionFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenElectiveRestrictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenElectiveRestrictionClient<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenElectiveRestriction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenElectiveRestrictionFindFirstArgs} args - Arguments to find a OpenElectiveRestriction
     * @example
     * // Get one OpenElectiveRestriction
     * const openElectiveRestriction = await prisma.openElectiveRestriction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenElectiveRestrictionFindFirstArgs>(args?: SelectSubset<T, OpenElectiveRestrictionFindFirstArgs<ExtArgs>>): Prisma__OpenElectiveRestrictionClient<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpenElectiveRestriction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenElectiveRestrictionFindFirstOrThrowArgs} args - Arguments to find a OpenElectiveRestriction
     * @example
     * // Get one OpenElectiveRestriction
     * const openElectiveRestriction = await prisma.openElectiveRestriction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenElectiveRestrictionFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenElectiveRestrictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenElectiveRestrictionClient<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OpenElectiveRestrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenElectiveRestrictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenElectiveRestrictions
     * const openElectiveRestrictions = await prisma.openElectiveRestriction.findMany()
     * 
     * // Get first 10 OpenElectiveRestrictions
     * const openElectiveRestrictions = await prisma.openElectiveRestriction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openElectiveRestrictionWithIdOnly = await prisma.openElectiveRestriction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpenElectiveRestrictionFindManyArgs>(args?: SelectSubset<T, OpenElectiveRestrictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OpenElectiveRestriction.
     * @param {OpenElectiveRestrictionCreateArgs} args - Arguments to create a OpenElectiveRestriction.
     * @example
     * // Create one OpenElectiveRestriction
     * const OpenElectiveRestriction = await prisma.openElectiveRestriction.create({
     *   data: {
     *     // ... data to create a OpenElectiveRestriction
     *   }
     * })
     * 
     */
    create<T extends OpenElectiveRestrictionCreateArgs>(args: SelectSubset<T, OpenElectiveRestrictionCreateArgs<ExtArgs>>): Prisma__OpenElectiveRestrictionClient<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OpenElectiveRestrictions.
     * @param {OpenElectiveRestrictionCreateManyArgs} args - Arguments to create many OpenElectiveRestrictions.
     * @example
     * // Create many OpenElectiveRestrictions
     * const openElectiveRestriction = await prisma.openElectiveRestriction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenElectiveRestrictionCreateManyArgs>(args?: SelectSubset<T, OpenElectiveRestrictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpenElectiveRestrictions and returns the data saved in the database.
     * @param {OpenElectiveRestrictionCreateManyAndReturnArgs} args - Arguments to create many OpenElectiveRestrictions.
     * @example
     * // Create many OpenElectiveRestrictions
     * const openElectiveRestriction = await prisma.openElectiveRestriction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpenElectiveRestrictions and only return the `id`
     * const openElectiveRestrictionWithIdOnly = await prisma.openElectiveRestriction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpenElectiveRestrictionCreateManyAndReturnArgs>(args?: SelectSubset<T, OpenElectiveRestrictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OpenElectiveRestriction.
     * @param {OpenElectiveRestrictionDeleteArgs} args - Arguments to delete one OpenElectiveRestriction.
     * @example
     * // Delete one OpenElectiveRestriction
     * const OpenElectiveRestriction = await prisma.openElectiveRestriction.delete({
     *   where: {
     *     // ... filter to delete one OpenElectiveRestriction
     *   }
     * })
     * 
     */
    delete<T extends OpenElectiveRestrictionDeleteArgs>(args: SelectSubset<T, OpenElectiveRestrictionDeleteArgs<ExtArgs>>): Prisma__OpenElectiveRestrictionClient<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OpenElectiveRestriction.
     * @param {OpenElectiveRestrictionUpdateArgs} args - Arguments to update one OpenElectiveRestriction.
     * @example
     * // Update one OpenElectiveRestriction
     * const openElectiveRestriction = await prisma.openElectiveRestriction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenElectiveRestrictionUpdateArgs>(args: SelectSubset<T, OpenElectiveRestrictionUpdateArgs<ExtArgs>>): Prisma__OpenElectiveRestrictionClient<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OpenElectiveRestrictions.
     * @param {OpenElectiveRestrictionDeleteManyArgs} args - Arguments to filter OpenElectiveRestrictions to delete.
     * @example
     * // Delete a few OpenElectiveRestrictions
     * const { count } = await prisma.openElectiveRestriction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenElectiveRestrictionDeleteManyArgs>(args?: SelectSubset<T, OpenElectiveRestrictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenElectiveRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenElectiveRestrictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenElectiveRestrictions
     * const openElectiveRestriction = await prisma.openElectiveRestriction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenElectiveRestrictionUpdateManyArgs>(args: SelectSubset<T, OpenElectiveRestrictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenElectiveRestrictions and returns the data updated in the database.
     * @param {OpenElectiveRestrictionUpdateManyAndReturnArgs} args - Arguments to update many OpenElectiveRestrictions.
     * @example
     * // Update many OpenElectiveRestrictions
     * const openElectiveRestriction = await prisma.openElectiveRestriction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OpenElectiveRestrictions and only return the `id`
     * const openElectiveRestrictionWithIdOnly = await prisma.openElectiveRestriction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpenElectiveRestrictionUpdateManyAndReturnArgs>(args: SelectSubset<T, OpenElectiveRestrictionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OpenElectiveRestriction.
     * @param {OpenElectiveRestrictionUpsertArgs} args - Arguments to update or create a OpenElectiveRestriction.
     * @example
     * // Update or create a OpenElectiveRestriction
     * const openElectiveRestriction = await prisma.openElectiveRestriction.upsert({
     *   create: {
     *     // ... data to create a OpenElectiveRestriction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenElectiveRestriction we want to update
     *   }
     * })
     */
    upsert<T extends OpenElectiveRestrictionUpsertArgs>(args: SelectSubset<T, OpenElectiveRestrictionUpsertArgs<ExtArgs>>): Prisma__OpenElectiveRestrictionClient<$Result.GetResult<Prisma.$OpenElectiveRestrictionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OpenElectiveRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenElectiveRestrictionCountArgs} args - Arguments to filter OpenElectiveRestrictions to count.
     * @example
     * // Count the number of OpenElectiveRestrictions
     * const count = await prisma.openElectiveRestriction.count({
     *   where: {
     *     // ... the filter for the OpenElectiveRestrictions we want to count
     *   }
     * })
    **/
    count<T extends OpenElectiveRestrictionCountArgs>(
      args?: Subset<T, OpenElectiveRestrictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenElectiveRestrictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenElectiveRestriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenElectiveRestrictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenElectiveRestrictionAggregateArgs>(args: Subset<T, OpenElectiveRestrictionAggregateArgs>): Prisma.PrismaPromise<GetOpenElectiveRestrictionAggregateType<T>>

    /**
     * Group by OpenElectiveRestriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenElectiveRestrictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenElectiveRestrictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenElectiveRestrictionGroupByArgs['orderBy'] }
        : { orderBy?: OpenElectiveRestrictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenElectiveRestrictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenElectiveRestrictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenElectiveRestriction model
   */
  readonly fields: OpenElectiveRestrictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenElectiveRestriction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenElectiveRestrictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends OpenElectiveRestriction$courseArgs<ExtArgs> = {}>(args?: Subset<T, OpenElectiveRestriction$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    restrictedDepartment<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenElectiveRestriction model
   */
  interface OpenElectiveRestrictionFieldRefs {
    readonly id: FieldRef<"OpenElectiveRestriction", 'String'>
    readonly courseId: FieldRef<"OpenElectiveRestriction", 'String'>
    readonly restrictedDepartmentId: FieldRef<"OpenElectiveRestriction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OpenElectiveRestriction findUnique
   */
  export type OpenElectiveRestrictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which OpenElectiveRestriction to fetch.
     */
    where: OpenElectiveRestrictionWhereUniqueInput
  }

  /**
   * OpenElectiveRestriction findUniqueOrThrow
   */
  export type OpenElectiveRestrictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which OpenElectiveRestriction to fetch.
     */
    where: OpenElectiveRestrictionWhereUniqueInput
  }

  /**
   * OpenElectiveRestriction findFirst
   */
  export type OpenElectiveRestrictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which OpenElectiveRestriction to fetch.
     */
    where?: OpenElectiveRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenElectiveRestrictions to fetch.
     */
    orderBy?: OpenElectiveRestrictionOrderByWithRelationInput | OpenElectiveRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenElectiveRestrictions.
     */
    cursor?: OpenElectiveRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenElectiveRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenElectiveRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenElectiveRestrictions.
     */
    distinct?: OpenElectiveRestrictionScalarFieldEnum | OpenElectiveRestrictionScalarFieldEnum[]
  }

  /**
   * OpenElectiveRestriction findFirstOrThrow
   */
  export type OpenElectiveRestrictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which OpenElectiveRestriction to fetch.
     */
    where?: OpenElectiveRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenElectiveRestrictions to fetch.
     */
    orderBy?: OpenElectiveRestrictionOrderByWithRelationInput | OpenElectiveRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenElectiveRestrictions.
     */
    cursor?: OpenElectiveRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenElectiveRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenElectiveRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenElectiveRestrictions.
     */
    distinct?: OpenElectiveRestrictionScalarFieldEnum | OpenElectiveRestrictionScalarFieldEnum[]
  }

  /**
   * OpenElectiveRestriction findMany
   */
  export type OpenElectiveRestrictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    /**
     * Filter, which OpenElectiveRestrictions to fetch.
     */
    where?: OpenElectiveRestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenElectiveRestrictions to fetch.
     */
    orderBy?: OpenElectiveRestrictionOrderByWithRelationInput | OpenElectiveRestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenElectiveRestrictions.
     */
    cursor?: OpenElectiveRestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenElectiveRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenElectiveRestrictions.
     */
    skip?: number
    distinct?: OpenElectiveRestrictionScalarFieldEnum | OpenElectiveRestrictionScalarFieldEnum[]
  }

  /**
   * OpenElectiveRestriction create
   */
  export type OpenElectiveRestrictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    /**
     * The data needed to create a OpenElectiveRestriction.
     */
    data: XOR<OpenElectiveRestrictionCreateInput, OpenElectiveRestrictionUncheckedCreateInput>
  }

  /**
   * OpenElectiveRestriction createMany
   */
  export type OpenElectiveRestrictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenElectiveRestrictions.
     */
    data: OpenElectiveRestrictionCreateManyInput | OpenElectiveRestrictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenElectiveRestriction createManyAndReturn
   */
  export type OpenElectiveRestrictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * The data used to create many OpenElectiveRestrictions.
     */
    data: OpenElectiveRestrictionCreateManyInput | OpenElectiveRestrictionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpenElectiveRestriction update
   */
  export type OpenElectiveRestrictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    /**
     * The data needed to update a OpenElectiveRestriction.
     */
    data: XOR<OpenElectiveRestrictionUpdateInput, OpenElectiveRestrictionUncheckedUpdateInput>
    /**
     * Choose, which OpenElectiveRestriction to update.
     */
    where: OpenElectiveRestrictionWhereUniqueInput
  }

  /**
   * OpenElectiveRestriction updateMany
   */
  export type OpenElectiveRestrictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenElectiveRestrictions.
     */
    data: XOR<OpenElectiveRestrictionUpdateManyMutationInput, OpenElectiveRestrictionUncheckedUpdateManyInput>
    /**
     * Filter which OpenElectiveRestrictions to update
     */
    where?: OpenElectiveRestrictionWhereInput
    /**
     * Limit how many OpenElectiveRestrictions to update.
     */
    limit?: number
  }

  /**
   * OpenElectiveRestriction updateManyAndReturn
   */
  export type OpenElectiveRestrictionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * The data used to update OpenElectiveRestrictions.
     */
    data: XOR<OpenElectiveRestrictionUpdateManyMutationInput, OpenElectiveRestrictionUncheckedUpdateManyInput>
    /**
     * Filter which OpenElectiveRestrictions to update
     */
    where?: OpenElectiveRestrictionWhereInput
    /**
     * Limit how many OpenElectiveRestrictions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpenElectiveRestriction upsert
   */
  export type OpenElectiveRestrictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    /**
     * The filter to search for the OpenElectiveRestriction to update in case it exists.
     */
    where: OpenElectiveRestrictionWhereUniqueInput
    /**
     * In case the OpenElectiveRestriction found by the `where` argument doesn't exist, create a new OpenElectiveRestriction with this data.
     */
    create: XOR<OpenElectiveRestrictionCreateInput, OpenElectiveRestrictionUncheckedCreateInput>
    /**
     * In case the OpenElectiveRestriction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenElectiveRestrictionUpdateInput, OpenElectiveRestrictionUncheckedUpdateInput>
  }

  /**
   * OpenElectiveRestriction delete
   */
  export type OpenElectiveRestrictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
    /**
     * Filter which OpenElectiveRestriction to delete.
     */
    where: OpenElectiveRestrictionWhereUniqueInput
  }

  /**
   * OpenElectiveRestriction deleteMany
   */
  export type OpenElectiveRestrictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenElectiveRestrictions to delete
     */
    where?: OpenElectiveRestrictionWhereInput
    /**
     * Limit how many OpenElectiveRestrictions to delete.
     */
    limit?: number
  }

  /**
   * OpenElectiveRestriction.course
   */
  export type OpenElectiveRestriction$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * OpenElectiveRestriction without action
   */
  export type OpenElectiveRestrictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenElectiveRestriction
     */
    select?: OpenElectiveRestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenElectiveRestriction
     */
    omit?: OpenElectiveRestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenElectiveRestrictionInclude<ExtArgs> | null
  }


  /**
   * Model CourseOffering
   */

  export type AggregateCourseOffering = {
    _count: CourseOfferingCountAggregateOutputType | null
    _avg: CourseOfferingAvgAggregateOutputType | null
    _sum: CourseOfferingSumAggregateOutputType | null
    _min: CourseOfferingMinAggregateOutputType | null
    _max: CourseOfferingMaxAggregateOutputType | null
  }

  export type CourseOfferingAvgAggregateOutputType = {
    semester: number | null
  }

  export type CourseOfferingSumAggregateOutputType = {
    semester: number | null
  }

  export type CourseOfferingMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    teacherId: string | null
    section_id: string | null
    year_id: string | null
    semester: number | null
  }

  export type CourseOfferingMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    teacherId: string | null
    section_id: string | null
    year_id: string | null
    semester: number | null
  }

  export type CourseOfferingCountAggregateOutputType = {
    id: number
    courseId: number
    teacherId: number
    section_id: number
    year_id: number
    semester: number
    _all: number
  }


  export type CourseOfferingAvgAggregateInputType = {
    semester?: true
  }

  export type CourseOfferingSumAggregateInputType = {
    semester?: true
  }

  export type CourseOfferingMinAggregateInputType = {
    id?: true
    courseId?: true
    teacherId?: true
    section_id?: true
    year_id?: true
    semester?: true
  }

  export type CourseOfferingMaxAggregateInputType = {
    id?: true
    courseId?: true
    teacherId?: true
    section_id?: true
    year_id?: true
    semester?: true
  }

  export type CourseOfferingCountAggregateInputType = {
    id?: true
    courseId?: true
    teacherId?: true
    section_id?: true
    year_id?: true
    semester?: true
    _all?: true
  }

  export type CourseOfferingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseOffering to aggregate.
     */
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
     */
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseOfferings
    **/
    _count?: true | CourseOfferingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseOfferingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseOfferingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseOfferingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseOfferingMaxAggregateInputType
  }

  export type GetCourseOfferingAggregateType<T extends CourseOfferingAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseOffering]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseOffering[P]>
      : GetScalarType<T[P], AggregateCourseOffering[P]>
  }




  export type CourseOfferingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseOfferingWhereInput
    orderBy?: CourseOfferingOrderByWithAggregationInput | CourseOfferingOrderByWithAggregationInput[]
    by: CourseOfferingScalarFieldEnum[] | CourseOfferingScalarFieldEnum
    having?: CourseOfferingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseOfferingCountAggregateInputType | true
    _avg?: CourseOfferingAvgAggregateInputType
    _sum?: CourseOfferingSumAggregateInputType
    _min?: CourseOfferingMinAggregateInputType
    _max?: CourseOfferingMaxAggregateInputType
  }

  export type CourseOfferingGroupByOutputType = {
    id: string
    courseId: string
    teacherId: string | null
    section_id: string | null
    year_id: string | null
    semester: number | null
    _count: CourseOfferingCountAggregateOutputType | null
    _avg: CourseOfferingAvgAggregateOutputType | null
    _sum: CourseOfferingSumAggregateOutputType | null
    _min: CourseOfferingMinAggregateOutputType | null
    _max: CourseOfferingMaxAggregateOutputType | null
  }

  type GetCourseOfferingGroupByPayload<T extends CourseOfferingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseOfferingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseOfferingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseOfferingGroupByOutputType[P]>
            : GetScalarType<T[P], CourseOfferingGroupByOutputType[P]>
        }
      >
    >


  export type CourseOfferingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    teacherId?: boolean
    section_id?: boolean
    year_id?: boolean
    semester?: boolean
    attendances?: boolean | CourseOffering$attendancesArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    sections?: boolean | CourseOffering$sectionsArgs<ExtArgs>
    teacher?: boolean | CourseOffering$teacherArgs<ExtArgs>
    academic_years?: boolean | CourseOffering$academic_yearsArgs<ExtArgs>
    enrollments?: boolean | CourseOffering$enrollmentsArgs<ExtArgs>
    testComponents?: boolean | CourseOffering$testComponentsArgs<ExtArgs>
    _count?: boolean | CourseOfferingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseOffering"]>

  export type CourseOfferingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    teacherId?: boolean
    section_id?: boolean
    year_id?: boolean
    semester?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    sections?: boolean | CourseOffering$sectionsArgs<ExtArgs>
    teacher?: boolean | CourseOffering$teacherArgs<ExtArgs>
    academic_years?: boolean | CourseOffering$academic_yearsArgs<ExtArgs>
  }, ExtArgs["result"]["courseOffering"]>

  export type CourseOfferingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    teacherId?: boolean
    section_id?: boolean
    year_id?: boolean
    semester?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    sections?: boolean | CourseOffering$sectionsArgs<ExtArgs>
    teacher?: boolean | CourseOffering$teacherArgs<ExtArgs>
    academic_years?: boolean | CourseOffering$academic_yearsArgs<ExtArgs>
  }, ExtArgs["result"]["courseOffering"]>

  export type CourseOfferingSelectScalar = {
    id?: boolean
    courseId?: boolean
    teacherId?: boolean
    section_id?: boolean
    year_id?: boolean
    semester?: boolean
  }

  export type CourseOfferingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "teacherId" | "section_id" | "year_id" | "semester", ExtArgs["result"]["courseOffering"]>
  export type CourseOfferingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | CourseOffering$attendancesArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    sections?: boolean | CourseOffering$sectionsArgs<ExtArgs>
    teacher?: boolean | CourseOffering$teacherArgs<ExtArgs>
    academic_years?: boolean | CourseOffering$academic_yearsArgs<ExtArgs>
    enrollments?: boolean | CourseOffering$enrollmentsArgs<ExtArgs>
    testComponents?: boolean | CourseOffering$testComponentsArgs<ExtArgs>
    _count?: boolean | CourseOfferingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseOfferingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    sections?: boolean | CourseOffering$sectionsArgs<ExtArgs>
    teacher?: boolean | CourseOffering$teacherArgs<ExtArgs>
    academic_years?: boolean | CourseOffering$academic_yearsArgs<ExtArgs>
  }
  export type CourseOfferingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    sections?: boolean | CourseOffering$sectionsArgs<ExtArgs>
    teacher?: boolean | CourseOffering$teacherArgs<ExtArgs>
    academic_years?: boolean | CourseOffering$academic_yearsArgs<ExtArgs>
  }

  export type $CourseOfferingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseOffering"
    objects: {
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      course: Prisma.$CoursePayload<ExtArgs>
      sections: Prisma.$sectionsPayload<ExtArgs> | null
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      academic_years: Prisma.$academic_yearsPayload<ExtArgs> | null
      enrollments: Prisma.$StudentEnrollmentPayload<ExtArgs>[]
      testComponents: Prisma.$TestComponentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      teacherId: string | null
      section_id: string | null
      year_id: string | null
      semester: number | null
    }, ExtArgs["result"]["courseOffering"]>
    composites: {}
  }

  type CourseOfferingGetPayload<S extends boolean | null | undefined | CourseOfferingDefaultArgs> = $Result.GetResult<Prisma.$CourseOfferingPayload, S>

  type CourseOfferingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseOfferingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseOfferingCountAggregateInputType | true
    }

  export interface CourseOfferingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseOffering'], meta: { name: 'CourseOffering' } }
    /**
     * Find zero or one CourseOffering that matches the filter.
     * @param {CourseOfferingFindUniqueArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseOfferingFindUniqueArgs>(args: SelectSubset<T, CourseOfferingFindUniqueArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseOffering that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseOfferingFindUniqueOrThrowArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseOfferingFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseOfferingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseOffering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingFindFirstArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseOfferingFindFirstArgs>(args?: SelectSubset<T, CourseOfferingFindFirstArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseOffering that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingFindFirstOrThrowArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseOfferingFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseOfferingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseOfferings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseOfferings
     * const courseOfferings = await prisma.courseOffering.findMany()
     * 
     * // Get first 10 CourseOfferings
     * const courseOfferings = await prisma.courseOffering.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseOfferingWithIdOnly = await prisma.courseOffering.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseOfferingFindManyArgs>(args?: SelectSubset<T, CourseOfferingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseOffering.
     * @param {CourseOfferingCreateArgs} args - Arguments to create a CourseOffering.
     * @example
     * // Create one CourseOffering
     * const CourseOffering = await prisma.courseOffering.create({
     *   data: {
     *     // ... data to create a CourseOffering
     *   }
     * })
     * 
     */
    create<T extends CourseOfferingCreateArgs>(args: SelectSubset<T, CourseOfferingCreateArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseOfferings.
     * @param {CourseOfferingCreateManyArgs} args - Arguments to create many CourseOfferings.
     * @example
     * // Create many CourseOfferings
     * const courseOffering = await prisma.courseOffering.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseOfferingCreateManyArgs>(args?: SelectSubset<T, CourseOfferingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseOfferings and returns the data saved in the database.
     * @param {CourseOfferingCreateManyAndReturnArgs} args - Arguments to create many CourseOfferings.
     * @example
     * // Create many CourseOfferings
     * const courseOffering = await prisma.courseOffering.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseOfferings and only return the `id`
     * const courseOfferingWithIdOnly = await prisma.courseOffering.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseOfferingCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseOfferingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseOffering.
     * @param {CourseOfferingDeleteArgs} args - Arguments to delete one CourseOffering.
     * @example
     * // Delete one CourseOffering
     * const CourseOffering = await prisma.courseOffering.delete({
     *   where: {
     *     // ... filter to delete one CourseOffering
     *   }
     * })
     * 
     */
    delete<T extends CourseOfferingDeleteArgs>(args: SelectSubset<T, CourseOfferingDeleteArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseOffering.
     * @param {CourseOfferingUpdateArgs} args - Arguments to update one CourseOffering.
     * @example
     * // Update one CourseOffering
     * const courseOffering = await prisma.courseOffering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseOfferingUpdateArgs>(args: SelectSubset<T, CourseOfferingUpdateArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseOfferings.
     * @param {CourseOfferingDeleteManyArgs} args - Arguments to filter CourseOfferings to delete.
     * @example
     * // Delete a few CourseOfferings
     * const { count } = await prisma.courseOffering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseOfferingDeleteManyArgs>(args?: SelectSubset<T, CourseOfferingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseOfferings
     * const courseOffering = await prisma.courseOffering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseOfferingUpdateManyArgs>(args: SelectSubset<T, CourseOfferingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseOfferings and returns the data updated in the database.
     * @param {CourseOfferingUpdateManyAndReturnArgs} args - Arguments to update many CourseOfferings.
     * @example
     * // Update many CourseOfferings
     * const courseOffering = await prisma.courseOffering.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseOfferings and only return the `id`
     * const courseOfferingWithIdOnly = await prisma.courseOffering.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseOfferingUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseOfferingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseOffering.
     * @param {CourseOfferingUpsertArgs} args - Arguments to update or create a CourseOffering.
     * @example
     * // Update or create a CourseOffering
     * const courseOffering = await prisma.courseOffering.upsert({
     *   create: {
     *     // ... data to create a CourseOffering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseOffering we want to update
     *   }
     * })
     */
    upsert<T extends CourseOfferingUpsertArgs>(args: SelectSubset<T, CourseOfferingUpsertArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingCountArgs} args - Arguments to filter CourseOfferings to count.
     * @example
     * // Count the number of CourseOfferings
     * const count = await prisma.courseOffering.count({
     *   where: {
     *     // ... the filter for the CourseOfferings we want to count
     *   }
     * })
    **/
    count<T extends CourseOfferingCountArgs>(
      args?: Subset<T, CourseOfferingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseOfferingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseOfferingAggregateArgs>(args: Subset<T, CourseOfferingAggregateArgs>): Prisma.PrismaPromise<GetCourseOfferingAggregateType<T>>

    /**
     * Group by CourseOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseOfferingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseOfferingGroupByArgs['orderBy'] }
        : { orderBy?: CourseOfferingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseOfferingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseOfferingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseOffering model
   */
  readonly fields: CourseOfferingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseOffering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseOfferingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendances<T extends CourseOffering$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, CourseOffering$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sections<T extends CourseOffering$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, CourseOffering$sectionsArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends CourseOffering$teacherArgs<ExtArgs> = {}>(args?: Subset<T, CourseOffering$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    academic_years<T extends CourseOffering$academic_yearsArgs<ExtArgs> = {}>(args?: Subset<T, CourseOffering$academic_yearsArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enrollments<T extends CourseOffering$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, CourseOffering$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testComponents<T extends CourseOffering$testComponentsArgs<ExtArgs> = {}>(args?: Subset<T, CourseOffering$testComponentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseOffering model
   */
  interface CourseOfferingFieldRefs {
    readonly id: FieldRef<"CourseOffering", 'String'>
    readonly courseId: FieldRef<"CourseOffering", 'String'>
    readonly teacherId: FieldRef<"CourseOffering", 'String'>
    readonly section_id: FieldRef<"CourseOffering", 'String'>
    readonly year_id: FieldRef<"CourseOffering", 'String'>
    readonly semester: FieldRef<"CourseOffering", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseOffering findUnique
   */
  export type CourseOfferingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOffering to fetch.
     */
    where: CourseOfferingWhereUniqueInput
  }

  /**
   * CourseOffering findUniqueOrThrow
   */
  export type CourseOfferingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOffering to fetch.
     */
    where: CourseOfferingWhereUniqueInput
  }

  /**
   * CourseOffering findFirst
   */
  export type CourseOfferingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOffering to fetch.
     */
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
     */
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseOfferings.
     */
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseOfferings.
     */
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * CourseOffering findFirstOrThrow
   */
  export type CourseOfferingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOffering to fetch.
     */
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
     */
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseOfferings.
     */
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseOfferings.
     */
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * CourseOffering findMany
   */
  export type CourseOfferingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOfferings to fetch.
     */
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
     */
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseOfferings.
     */
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
     */
    skip?: number
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * CourseOffering create
   */
  export type CourseOfferingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseOffering.
     */
    data: XOR<CourseOfferingCreateInput, CourseOfferingUncheckedCreateInput>
  }

  /**
   * CourseOffering createMany
   */
  export type CourseOfferingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseOfferings.
     */
    data: CourseOfferingCreateManyInput | CourseOfferingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseOffering createManyAndReturn
   */
  export type CourseOfferingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * The data used to create many CourseOfferings.
     */
    data: CourseOfferingCreateManyInput | CourseOfferingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseOffering update
   */
  export type CourseOfferingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseOffering.
     */
    data: XOR<CourseOfferingUpdateInput, CourseOfferingUncheckedUpdateInput>
    /**
     * Choose, which CourseOffering to update.
     */
    where: CourseOfferingWhereUniqueInput
  }

  /**
   * CourseOffering updateMany
   */
  export type CourseOfferingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseOfferings.
     */
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyInput>
    /**
     * Filter which CourseOfferings to update
     */
    where?: CourseOfferingWhereInput
    /**
     * Limit how many CourseOfferings to update.
     */
    limit?: number
  }

  /**
   * CourseOffering updateManyAndReturn
   */
  export type CourseOfferingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * The data used to update CourseOfferings.
     */
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyInput>
    /**
     * Filter which CourseOfferings to update
     */
    where?: CourseOfferingWhereInput
    /**
     * Limit how many CourseOfferings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseOffering upsert
   */
  export type CourseOfferingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseOffering to update in case it exists.
     */
    where: CourseOfferingWhereUniqueInput
    /**
     * In case the CourseOffering found by the `where` argument doesn't exist, create a new CourseOffering with this data.
     */
    create: XOR<CourseOfferingCreateInput, CourseOfferingUncheckedCreateInput>
    /**
     * In case the CourseOffering was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseOfferingUpdateInput, CourseOfferingUncheckedUpdateInput>
  }

  /**
   * CourseOffering delete
   */
  export type CourseOfferingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter which CourseOffering to delete.
     */
    where: CourseOfferingWhereUniqueInput
  }

  /**
   * CourseOffering deleteMany
   */
  export type CourseOfferingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseOfferings to delete
     */
    where?: CourseOfferingWhereInput
    /**
     * Limit how many CourseOfferings to delete.
     */
    limit?: number
  }

  /**
   * CourseOffering.attendances
   */
  export type CourseOffering$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * CourseOffering.sections
   */
  export type CourseOffering$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    where?: sectionsWhereInput
  }

  /**
   * CourseOffering.teacher
   */
  export type CourseOffering$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * CourseOffering.academic_years
   */
  export type CourseOffering$academic_yearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    where?: academic_yearsWhereInput
  }

  /**
   * CourseOffering.enrollments
   */
  export type CourseOffering$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    cursor?: StudentEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseOffering.testComponents
   */
  export type CourseOffering$testComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    where?: TestComponentWhereInput
    orderBy?: TestComponentOrderByWithRelationInput | TestComponentOrderByWithRelationInput[]
    cursor?: TestComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestComponentScalarFieldEnum | TestComponentScalarFieldEnum[]
  }

  /**
   * CourseOffering without action
   */
  export type CourseOfferingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
  }


  /**
   * Model StudentEnrollment
   */

  export type AggregateStudentEnrollment = {
    _count: StudentEnrollmentCountAggregateOutputType | null
    _avg: StudentEnrollmentAvgAggregateOutputType | null
    _sum: StudentEnrollmentSumAggregateOutputType | null
    _min: StudentEnrollmentMinAggregateOutputType | null
    _max: StudentEnrollmentMaxAggregateOutputType | null
  }

  export type StudentEnrollmentAvgAggregateOutputType = {
    attemptNumber: number | null
  }

  export type StudentEnrollmentSumAggregateOutputType = {
    attemptNumber: number | null
  }

  export type StudentEnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    offeringId: string | null
    attemptNumber: number | null
    year_id: string | null
  }

  export type StudentEnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    offeringId: string | null
    attemptNumber: number | null
    year_id: string | null
  }

  export type StudentEnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    offeringId: number
    attemptNumber: number
    year_id: number
    _all: number
  }


  export type StudentEnrollmentAvgAggregateInputType = {
    attemptNumber?: true
  }

  export type StudentEnrollmentSumAggregateInputType = {
    attemptNumber?: true
  }

  export type StudentEnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    offeringId?: true
    attemptNumber?: true
    year_id?: true
  }

  export type StudentEnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    offeringId?: true
    attemptNumber?: true
    year_id?: true
  }

  export type StudentEnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    offeringId?: true
    attemptNumber?: true
    year_id?: true
    _all?: true
  }

  export type StudentEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrollment to aggregate.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEnrollments
    **/
    _count?: true | StudentEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentEnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentEnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEnrollmentMaxAggregateInputType
  }

  export type GetStudentEnrollmentAggregateType<T extends StudentEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEnrollment[P]>
      : GetScalarType<T[P], AggregateStudentEnrollment[P]>
  }




  export type StudentEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithAggregationInput | StudentEnrollmentOrderByWithAggregationInput[]
    by: StudentEnrollmentScalarFieldEnum[] | StudentEnrollmentScalarFieldEnum
    having?: StudentEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEnrollmentCountAggregateInputType | true
    _avg?: StudentEnrollmentAvgAggregateInputType
    _sum?: StudentEnrollmentSumAggregateInputType
    _min?: StudentEnrollmentMinAggregateInputType
    _max?: StudentEnrollmentMaxAggregateInputType
  }

  export type StudentEnrollmentGroupByOutputType = {
    id: string
    studentId: string | null
    offeringId: string | null
    attemptNumber: number | null
    year_id: string | null
    _count: StudentEnrollmentCountAggregateOutputType | null
    _avg: StudentEnrollmentAvgAggregateOutputType | null
    _sum: StudentEnrollmentSumAggregateOutputType | null
    _min: StudentEnrollmentMinAggregateOutputType | null
    _max: StudentEnrollmentMaxAggregateOutputType | null
  }

  type GetStudentEnrollmentGroupByPayload<T extends StudentEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type StudentEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    offeringId?: boolean
    attemptNumber?: boolean
    year_id?: boolean
    offering?: boolean | StudentEnrollment$offeringArgs<ExtArgs>
    student?: boolean | StudentEnrollment$studentArgs<ExtArgs>
    academic_years?: boolean | StudentEnrollment$academic_yearsArgs<ExtArgs>
    studentMarks?: boolean | StudentEnrollment$studentMarksArgs<ExtArgs>
    _count?: boolean | StudentEnrollmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrollment"]>

  export type StudentEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    offeringId?: boolean
    attemptNumber?: boolean
    year_id?: boolean
    offering?: boolean | StudentEnrollment$offeringArgs<ExtArgs>
    student?: boolean | StudentEnrollment$studentArgs<ExtArgs>
    academic_years?: boolean | StudentEnrollment$academic_yearsArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrollment"]>

  export type StudentEnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    offeringId?: boolean
    attemptNumber?: boolean
    year_id?: boolean
    offering?: boolean | StudentEnrollment$offeringArgs<ExtArgs>
    student?: boolean | StudentEnrollment$studentArgs<ExtArgs>
    academic_years?: boolean | StudentEnrollment$academic_yearsArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrollment"]>

  export type StudentEnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    offeringId?: boolean
    attemptNumber?: boolean
    year_id?: boolean
  }

  export type StudentEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "offeringId" | "attemptNumber" | "year_id", ExtArgs["result"]["studentEnrollment"]>
  export type StudentEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | StudentEnrollment$offeringArgs<ExtArgs>
    student?: boolean | StudentEnrollment$studentArgs<ExtArgs>
    academic_years?: boolean | StudentEnrollment$academic_yearsArgs<ExtArgs>
    studentMarks?: boolean | StudentEnrollment$studentMarksArgs<ExtArgs>
    _count?: boolean | StudentEnrollmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | StudentEnrollment$offeringArgs<ExtArgs>
    student?: boolean | StudentEnrollment$studentArgs<ExtArgs>
    academic_years?: boolean | StudentEnrollment$academic_yearsArgs<ExtArgs>
  }
  export type StudentEnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | StudentEnrollment$offeringArgs<ExtArgs>
    student?: boolean | StudentEnrollment$studentArgs<ExtArgs>
    academic_years?: boolean | StudentEnrollment$academic_yearsArgs<ExtArgs>
  }

  export type $StudentEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentEnrollment"
    objects: {
      offering: Prisma.$CourseOfferingPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      academic_years: Prisma.$academic_yearsPayload<ExtArgs> | null
      studentMarks: Prisma.$StudentMarkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string | null
      offeringId: string | null
      attemptNumber: number | null
      year_id: string | null
    }, ExtArgs["result"]["studentEnrollment"]>
    composites: {}
  }

  type StudentEnrollmentGetPayload<S extends boolean | null | undefined | StudentEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$StudentEnrollmentPayload, S>

  type StudentEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentEnrollmentCountAggregateInputType | true
    }

  export interface StudentEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEnrollment'], meta: { name: 'StudentEnrollment' } }
    /**
     * Find zero or one StudentEnrollment that matches the filter.
     * @param {StudentEnrollmentFindUniqueArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentEnrollmentFindUniqueArgs>(args: SelectSubset<T, StudentEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentFindFirstArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentEnrollmentFindFirstArgs>(args?: SelectSubset<T, StudentEnrollmentFindFirstArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentFindFirstOrThrowArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEnrollments
     * const studentEnrollments = await prisma.studentEnrollment.findMany()
     * 
     * // Get first 10 StudentEnrollments
     * const studentEnrollments = await prisma.studentEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEnrollmentWithIdOnly = await prisma.studentEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentEnrollmentFindManyArgs>(args?: SelectSubset<T, StudentEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentEnrollment.
     * @param {StudentEnrollmentCreateArgs} args - Arguments to create a StudentEnrollment.
     * @example
     * // Create one StudentEnrollment
     * const StudentEnrollment = await prisma.studentEnrollment.create({
     *   data: {
     *     // ... data to create a StudentEnrollment
     *   }
     * })
     * 
     */
    create<T extends StudentEnrollmentCreateArgs>(args: SelectSubset<T, StudentEnrollmentCreateArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentEnrollments.
     * @param {StudentEnrollmentCreateManyArgs} args - Arguments to create many StudentEnrollments.
     * @example
     * // Create many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentEnrollmentCreateManyArgs>(args?: SelectSubset<T, StudentEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentEnrollments and returns the data saved in the database.
     * @param {StudentEnrollmentCreateManyAndReturnArgs} args - Arguments to create many StudentEnrollments.
     * @example
     * // Create many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentEnrollments and only return the `id`
     * const studentEnrollmentWithIdOnly = await prisma.studentEnrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentEnrollment.
     * @param {StudentEnrollmentDeleteArgs} args - Arguments to delete one StudentEnrollment.
     * @example
     * // Delete one StudentEnrollment
     * const StudentEnrollment = await prisma.studentEnrollment.delete({
     *   where: {
     *     // ... filter to delete one StudentEnrollment
     *   }
     * })
     * 
     */
    delete<T extends StudentEnrollmentDeleteArgs>(args: SelectSubset<T, StudentEnrollmentDeleteArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentEnrollment.
     * @param {StudentEnrollmentUpdateArgs} args - Arguments to update one StudentEnrollment.
     * @example
     * // Update one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentEnrollmentUpdateArgs>(args: SelectSubset<T, StudentEnrollmentUpdateArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentEnrollments.
     * @param {StudentEnrollmentDeleteManyArgs} args - Arguments to filter StudentEnrollments to delete.
     * @example
     * // Delete a few StudentEnrollments
     * const { count } = await prisma.studentEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentEnrollmentDeleteManyArgs>(args?: SelectSubset<T, StudentEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentEnrollmentUpdateManyArgs>(args: SelectSubset<T, StudentEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrollments and returns the data updated in the database.
     * @param {StudentEnrollmentUpdateManyAndReturnArgs} args - Arguments to update many StudentEnrollments.
     * @example
     * // Update many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentEnrollments and only return the `id`
     * const studentEnrollmentWithIdOnly = await prisma.studentEnrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentEnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentEnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentEnrollment.
     * @param {StudentEnrollmentUpsertArgs} args - Arguments to update or create a StudentEnrollment.
     * @example
     * // Update or create a StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.upsert({
     *   create: {
     *     // ... data to create a StudentEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends StudentEnrollmentUpsertArgs>(args: SelectSubset<T, StudentEnrollmentUpsertArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentCountArgs} args - Arguments to filter StudentEnrollments to count.
     * @example
     * // Count the number of StudentEnrollments
     * const count = await prisma.studentEnrollment.count({
     *   where: {
     *     // ... the filter for the StudentEnrollments we want to count
     *   }
     * })
    **/
    count<T extends StudentEnrollmentCountArgs>(
      args?: Subset<T, StudentEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEnrollmentAggregateArgs>(args: Subset<T, StudentEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetStudentEnrollmentAggregateType<T>>

    /**
     * Group by StudentEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: StudentEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEnrollment model
   */
  readonly fields: StudentEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offering<T extends StudentEnrollment$offeringArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollment$offeringArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentEnrollment$studentArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollment$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    academic_years<T extends StudentEnrollment$academic_yearsArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollment$academic_yearsArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    studentMarks<T extends StudentEnrollment$studentMarksArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollment$studentMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentEnrollment model
   */
  interface StudentEnrollmentFieldRefs {
    readonly id: FieldRef<"StudentEnrollment", 'String'>
    readonly studentId: FieldRef<"StudentEnrollment", 'String'>
    readonly offeringId: FieldRef<"StudentEnrollment", 'String'>
    readonly attemptNumber: FieldRef<"StudentEnrollment", 'Int'>
    readonly year_id: FieldRef<"StudentEnrollment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentEnrollment findUnique
   */
  export type StudentEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment findUniqueOrThrow
   */
  export type StudentEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment findFirst
   */
  export type StudentEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrollments.
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrollments.
     */
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentEnrollment findFirstOrThrow
   */
  export type StudentEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrollments.
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrollments.
     */
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentEnrollment findMany
   */
  export type StudentEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollments to fetch.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEnrollments.
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentEnrollment create
   */
  export type StudentEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEnrollment.
     */
    data?: XOR<StudentEnrollmentCreateInput, StudentEnrollmentUncheckedCreateInput>
  }

  /**
   * StudentEnrollment createMany
   */
  export type StudentEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEnrollments.
     */
    data: StudentEnrollmentCreateManyInput | StudentEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentEnrollment createManyAndReturn
   */
  export type StudentEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many StudentEnrollments.
     */
    data: StudentEnrollmentCreateManyInput | StudentEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentEnrollment update
   */
  export type StudentEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEnrollment.
     */
    data: XOR<StudentEnrollmentUpdateInput, StudentEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which StudentEnrollment to update.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment updateMany
   */
  export type StudentEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEnrollments.
     */
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrollments to update
     */
    where?: StudentEnrollmentWhereInput
    /**
     * Limit how many StudentEnrollments to update.
     */
    limit?: number
  }

  /**
   * StudentEnrollment updateManyAndReturn
   */
  export type StudentEnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update StudentEnrollments.
     */
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrollments to update
     */
    where?: StudentEnrollmentWhereInput
    /**
     * Limit how many StudentEnrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentEnrollment upsert
   */
  export type StudentEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEnrollment to update in case it exists.
     */
    where: StudentEnrollmentWhereUniqueInput
    /**
     * In case the StudentEnrollment found by the `where` argument doesn't exist, create a new StudentEnrollment with this data.
     */
    create: XOR<StudentEnrollmentCreateInput, StudentEnrollmentUncheckedCreateInput>
    /**
     * In case the StudentEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEnrollmentUpdateInput, StudentEnrollmentUncheckedUpdateInput>
  }

  /**
   * StudentEnrollment delete
   */
  export type StudentEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which StudentEnrollment to delete.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment deleteMany
   */
  export type StudentEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrollments to delete
     */
    where?: StudentEnrollmentWhereInput
    /**
     * Limit how many StudentEnrollments to delete.
     */
    limit?: number
  }

  /**
   * StudentEnrollment.offering
   */
  export type StudentEnrollment$offeringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    where?: CourseOfferingWhereInput
  }

  /**
   * StudentEnrollment.student
   */
  export type StudentEnrollment$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * StudentEnrollment.academic_years
   */
  export type StudentEnrollment$academic_yearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    where?: academic_yearsWhereInput
  }

  /**
   * StudentEnrollment.studentMarks
   */
  export type StudentEnrollment$studentMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    where?: StudentMarkWhereInput
    orderBy?: StudentMarkOrderByWithRelationInput | StudentMarkOrderByWithRelationInput[]
    cursor?: StudentMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentMarkScalarFieldEnum | StudentMarkScalarFieldEnum[]
  }

  /**
   * StudentEnrollment without action
   */
  export type StudentEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    periodNumber: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    periodNumber: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    offeringId: string | null
    teacherId: string | null
    classDate: Date | null
    periodNumber: number | null
    syllabusCovered: string | null
    status: string | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    offeringId: string | null
    teacherId: string | null
    classDate: Date | null
    periodNumber: number | null
    syllabusCovered: string | null
    status: string | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    offeringId: number
    teacherId: number
    classDate: number
    periodNumber: number
    syllabusCovered: number
    status: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    periodNumber?: true
  }

  export type AttendanceSumAggregateInputType = {
    periodNumber?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    offeringId?: true
    teacherId?: true
    classDate?: true
    periodNumber?: true
    syllabusCovered?: true
    status?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    offeringId?: true
    teacherId?: true
    classDate?: true
    periodNumber?: true
    syllabusCovered?: true
    status?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    offeringId?: true
    teacherId?: true
    classDate?: true
    periodNumber?: true
    syllabusCovered?: true
    status?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    offeringId: string | null
    teacherId: string | null
    classDate: Date
    periodNumber: number | null
    syllabusCovered: string | null
    status: string | null
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offeringId?: boolean
    teacherId?: boolean
    classDate?: boolean
    periodNumber?: boolean
    syllabusCovered?: boolean
    status?: boolean
    offering?: boolean | Attendance$offeringArgs<ExtArgs>
    teacher?: boolean | Attendance$teacherArgs<ExtArgs>
    attendanceRecords?: boolean | Attendance$attendanceRecordsArgs<ExtArgs>
    _count?: boolean | AttendanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offeringId?: boolean
    teacherId?: boolean
    classDate?: boolean
    periodNumber?: boolean
    syllabusCovered?: boolean
    status?: boolean
    offering?: boolean | Attendance$offeringArgs<ExtArgs>
    teacher?: boolean | Attendance$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offeringId?: boolean
    teacherId?: boolean
    classDate?: boolean
    periodNumber?: boolean
    syllabusCovered?: boolean
    status?: boolean
    offering?: boolean | Attendance$offeringArgs<ExtArgs>
    teacher?: boolean | Attendance$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    offeringId?: boolean
    teacherId?: boolean
    classDate?: boolean
    periodNumber?: boolean
    syllabusCovered?: boolean
    status?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "offeringId" | "teacherId" | "classDate" | "periodNumber" | "syllabusCovered" | "status", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | Attendance$offeringArgs<ExtArgs>
    teacher?: boolean | Attendance$teacherArgs<ExtArgs>
    attendanceRecords?: boolean | Attendance$attendanceRecordsArgs<ExtArgs>
    _count?: boolean | AttendanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | Attendance$offeringArgs<ExtArgs>
    teacher?: boolean | Attendance$teacherArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | Attendance$offeringArgs<ExtArgs>
    teacher?: boolean | Attendance$teacherArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      offering: Prisma.$CourseOfferingPayload<ExtArgs> | null
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      offeringId: string | null
      teacherId: string | null
      classDate: Date
      periodNumber: number | null
      syllabusCovered: string | null
      status: string | null
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offering<T extends Attendance$offeringArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$offeringArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends Attendance$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendanceRecords<T extends Attendance$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly offeringId: FieldRef<"Attendance", 'String'>
    readonly teacherId: FieldRef<"Attendance", 'String'>
    readonly classDate: FieldRef<"Attendance", 'DateTime'>
    readonly periodNumber: FieldRef<"Attendance", 'Int'>
    readonly syllabusCovered: FieldRef<"Attendance", 'String'>
    readonly status: FieldRef<"Attendance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance.offering
   */
  export type Attendance$offeringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    where?: CourseOfferingWhereInput
  }

  /**
   * Attendance.teacher
   */
  export type Attendance$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Attendance.attendanceRecords
   */
  export type Attendance$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceRecord
   */

  export type AggregateAttendanceRecord = {
    _count: AttendanceRecordCountAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  export type AttendanceRecordMinAggregateOutputType = {
    id: string | null
    attendanceId: string | null
    studentId: string | null
    status: $Enums.attendance_status | null
  }

  export type AttendanceRecordMaxAggregateOutputType = {
    id: string | null
    attendanceId: string | null
    studentId: string | null
    status: $Enums.attendance_status | null
  }

  export type AttendanceRecordCountAggregateOutputType = {
    id: number
    attendanceId: number
    studentId: number
    status: number
    _all: number
  }


  export type AttendanceRecordMinAggregateInputType = {
    id?: true
    attendanceId?: true
    studentId?: true
    status?: true
  }

  export type AttendanceRecordMaxAggregateInputType = {
    id?: true
    attendanceId?: true
    studentId?: true
    status?: true
  }

  export type AttendanceRecordCountAggregateInputType = {
    id?: true
    attendanceId?: true
    studentId?: true
    status?: true
    _all?: true
  }

  export type AttendanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecord to aggregate.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceRecords
    **/
    _count?: true | AttendanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type GetAttendanceRecordAggregateType<T extends AttendanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceRecord[P]>
      : GetScalarType<T[P], AggregateAttendanceRecord[P]>
  }




  export type AttendanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithAggregationInput | AttendanceRecordOrderByWithAggregationInput[]
    by: AttendanceRecordScalarFieldEnum[] | AttendanceRecordScalarFieldEnum
    having?: AttendanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceRecordCountAggregateInputType | true
    _min?: AttendanceRecordMinAggregateInputType
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type AttendanceRecordGroupByOutputType = {
    id: string
    attendanceId: string | null
    studentId: string | null
    status: $Enums.attendance_status | null
    _count: AttendanceRecordCountAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  type GetAttendanceRecordGroupByPayload<T extends AttendanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    studentId?: boolean
    status?: boolean
    attendance?: boolean | AttendanceRecord$attendanceArgs<ExtArgs>
    student?: boolean | AttendanceRecord$studentArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    studentId?: boolean
    status?: boolean
    attendance?: boolean | AttendanceRecord$attendanceArgs<ExtArgs>
    student?: boolean | AttendanceRecord$studentArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendanceId?: boolean
    studentId?: boolean
    status?: boolean
    attendance?: boolean | AttendanceRecord$attendanceArgs<ExtArgs>
    student?: boolean | AttendanceRecord$studentArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectScalar = {
    id?: boolean
    attendanceId?: boolean
    studentId?: boolean
    status?: boolean
  }

  export type AttendanceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attendanceId" | "studentId" | "status", ExtArgs["result"]["attendanceRecord"]>
  export type AttendanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceRecord$attendanceArgs<ExtArgs>
    student?: boolean | AttendanceRecord$studentArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceRecord$attendanceArgs<ExtArgs>
    student?: boolean | AttendanceRecord$studentArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | AttendanceRecord$attendanceArgs<ExtArgs>
    student?: boolean | AttendanceRecord$studentArgs<ExtArgs>
  }

  export type $AttendanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceRecord"
    objects: {
      attendance: Prisma.$AttendancePayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attendanceId: string | null
      studentId: string | null
      status: $Enums.attendance_status | null
    }, ExtArgs["result"]["attendanceRecord"]>
    composites: {}
  }

  type AttendanceRecordGetPayload<S extends boolean | null | undefined | AttendanceRecordDefaultArgs> = $Result.GetResult<Prisma.$AttendanceRecordPayload, S>

  type AttendanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceRecordCountAggregateInputType | true
    }

  export interface AttendanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceRecord'], meta: { name: 'AttendanceRecord' } }
    /**
     * Find zero or one AttendanceRecord that matches the filter.
     * @param {AttendanceRecordFindUniqueArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceRecordFindUniqueArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceRecordFindUniqueOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceRecordFindFirstArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany()
     * 
     * // Get first 10 AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceRecordFindManyArgs>(args?: SelectSubset<T, AttendanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceRecord.
     * @param {AttendanceRecordCreateArgs} args - Arguments to create a AttendanceRecord.
     * @example
     * // Create one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.create({
     *   data: {
     *     // ... data to create a AttendanceRecord
     *   }
     * })
     * 
     */
    create<T extends AttendanceRecordCreateArgs>(args: SelectSubset<T, AttendanceRecordCreateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceRecords.
     * @param {AttendanceRecordCreateManyArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceRecordCreateManyArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceRecords and returns the data saved in the database.
     * @param {AttendanceRecordCreateManyAndReturnArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceRecord.
     * @param {AttendanceRecordDeleteArgs} args - Arguments to delete one AttendanceRecord.
     * @example
     * // Delete one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.delete({
     *   where: {
     *     // ... filter to delete one AttendanceRecord
     *   }
     * })
     * 
     */
    delete<T extends AttendanceRecordDeleteArgs>(args: SelectSubset<T, AttendanceRecordDeleteArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceRecord.
     * @param {AttendanceRecordUpdateArgs} args - Arguments to update one AttendanceRecord.
     * @example
     * // Update one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceRecordUpdateArgs>(args: SelectSubset<T, AttendanceRecordUpdateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceRecords.
     * @param {AttendanceRecordDeleteManyArgs} args - Arguments to filter AttendanceRecords to delete.
     * @example
     * // Delete a few AttendanceRecords
     * const { count } = await prisma.attendanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceRecordDeleteManyArgs>(args?: SelectSubset<T, AttendanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceRecordUpdateManyArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords and returns the data updated in the database.
     * @param {AttendanceRecordUpdateManyAndReturnArgs} args - Arguments to update many AttendanceRecords.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceRecord.
     * @param {AttendanceRecordUpsertArgs} args - Arguments to update or create a AttendanceRecord.
     * @example
     * // Update or create a AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.upsert({
     *   create: {
     *     // ... data to create a AttendanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceRecordUpsertArgs>(args: SelectSubset<T, AttendanceRecordUpsertArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordCountArgs} args - Arguments to filter AttendanceRecords to count.
     * @example
     * // Count the number of AttendanceRecords
     * const count = await prisma.attendanceRecord.count({
     *   where: {
     *     // ... the filter for the AttendanceRecords we want to count
     *   }
     * })
    **/
    count<T extends AttendanceRecordCountArgs>(
      args?: Subset<T, AttendanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceRecordAggregateArgs>(args: Subset<T, AttendanceRecordAggregateArgs>): Prisma.PrismaPromise<GetAttendanceRecordAggregateType<T>>

    /**
     * Group by AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceRecord model
   */
  readonly fields: AttendanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends AttendanceRecord$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceRecord$attendanceArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends AttendanceRecord$studentArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceRecord$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceRecord model
   */
  interface AttendanceRecordFieldRefs {
    readonly id: FieldRef<"AttendanceRecord", 'String'>
    readonly attendanceId: FieldRef<"AttendanceRecord", 'String'>
    readonly studentId: FieldRef<"AttendanceRecord", 'String'>
    readonly status: FieldRef<"AttendanceRecord", 'attendance_status'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceRecord findUnique
   */
  export type AttendanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findUniqueOrThrow
   */
  export type AttendanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findFirst
   */
  export type AttendanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findFirstOrThrow
   */
  export type AttendanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findMany
   */
  export type AttendanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecords to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord create
   */
  export type AttendanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceRecord.
     */
    data?: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
  }

  /**
   * AttendanceRecord createMany
   */
  export type AttendanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceRecord createManyAndReturn
   */
  export type AttendanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord update
   */
  export type AttendanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceRecord.
     */
    data: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
    /**
     * Choose, which AttendanceRecord to update.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord updateMany
   */
  export type AttendanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
  }

  /**
   * AttendanceRecord updateManyAndReturn
   */
  export type AttendanceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord upsert
   */
  export type AttendanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceRecord to update in case it exists.
     */
    where: AttendanceRecordWhereUniqueInput
    /**
     * In case the AttendanceRecord found by the `where` argument doesn't exist, create a new AttendanceRecord with this data.
     */
    create: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
    /**
     * In case the AttendanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
  }

  /**
   * AttendanceRecord delete
   */
  export type AttendanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter which AttendanceRecord to delete.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord deleteMany
   */
  export type AttendanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecords to delete
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to delete.
     */
    limit?: number
  }

  /**
   * AttendanceRecord.attendance
   */
  export type AttendanceRecord$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
  }

  /**
   * AttendanceRecord.student
   */
  export type AttendanceRecord$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * AttendanceRecord without action
   */
  export type AttendanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model ReportViewer
   */

  export type AggregateReportViewer = {
    _count: ReportViewerCountAggregateOutputType | null
    _min: ReportViewerMinAggregateOutputType | null
    _max: ReportViewerMaxAggregateOutputType | null
  }

  export type ReportViewerMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type ReportViewerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type ReportViewerCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type ReportViewerMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ReportViewerMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ReportViewerCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type ReportViewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportViewer to aggregate.
     */
    where?: ReportViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportViewers to fetch.
     */
    orderBy?: ReportViewerOrderByWithRelationInput | ReportViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportViewers
    **/
    _count?: true | ReportViewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportViewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportViewerMaxAggregateInputType
  }

  export type GetReportViewerAggregateType<T extends ReportViewerAggregateArgs> = {
        [P in keyof T & keyof AggregateReportViewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportViewer[P]>
      : GetScalarType<T[P], AggregateReportViewer[P]>
  }




  export type ReportViewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportViewerWhereInput
    orderBy?: ReportViewerOrderByWithAggregationInput | ReportViewerOrderByWithAggregationInput[]
    by: ReportViewerScalarFieldEnum[] | ReportViewerScalarFieldEnum
    having?: ReportViewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportViewerCountAggregateInputType | true
    _min?: ReportViewerMinAggregateInputType
    _max?: ReportViewerMaxAggregateInputType
  }

  export type ReportViewerGroupByOutputType = {
    id: string
    userId: string
    _count: ReportViewerCountAggregateOutputType | null
    _min: ReportViewerMinAggregateOutputType | null
    _max: ReportViewerMaxAggregateOutputType | null
  }

  type GetReportViewerGroupByPayload<T extends ReportViewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportViewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportViewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportViewerGroupByOutputType[P]>
            : GetScalarType<T[P], ReportViewerGroupByOutputType[P]>
        }
      >
    >


  export type ReportViewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportViewer"]>

  export type ReportViewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportViewer"]>

  export type ReportViewerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportViewer"]>

  export type ReportViewerSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type ReportViewerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["reportViewer"]>
  export type ReportViewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportViewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportViewerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportViewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportViewer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["reportViewer"]>
    composites: {}
  }

  type ReportViewerGetPayload<S extends boolean | null | undefined | ReportViewerDefaultArgs> = $Result.GetResult<Prisma.$ReportViewerPayload, S>

  type ReportViewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportViewerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportViewerCountAggregateInputType | true
    }

  export interface ReportViewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportViewer'], meta: { name: 'ReportViewer' } }
    /**
     * Find zero or one ReportViewer that matches the filter.
     * @param {ReportViewerFindUniqueArgs} args - Arguments to find a ReportViewer
     * @example
     * // Get one ReportViewer
     * const reportViewer = await prisma.reportViewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportViewerFindUniqueArgs>(args: SelectSubset<T, ReportViewerFindUniqueArgs<ExtArgs>>): Prisma__ReportViewerClient<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportViewer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportViewerFindUniqueOrThrowArgs} args - Arguments to find a ReportViewer
     * @example
     * // Get one ReportViewer
     * const reportViewer = await prisma.reportViewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportViewerFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportViewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportViewerClient<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportViewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportViewerFindFirstArgs} args - Arguments to find a ReportViewer
     * @example
     * // Get one ReportViewer
     * const reportViewer = await prisma.reportViewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportViewerFindFirstArgs>(args?: SelectSubset<T, ReportViewerFindFirstArgs<ExtArgs>>): Prisma__ReportViewerClient<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportViewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportViewerFindFirstOrThrowArgs} args - Arguments to find a ReportViewer
     * @example
     * // Get one ReportViewer
     * const reportViewer = await prisma.reportViewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportViewerFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportViewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportViewerClient<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportViewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportViewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportViewers
     * const reportViewers = await prisma.reportViewer.findMany()
     * 
     * // Get first 10 ReportViewers
     * const reportViewers = await prisma.reportViewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportViewerWithIdOnly = await prisma.reportViewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportViewerFindManyArgs>(args?: SelectSubset<T, ReportViewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportViewer.
     * @param {ReportViewerCreateArgs} args - Arguments to create a ReportViewer.
     * @example
     * // Create one ReportViewer
     * const ReportViewer = await prisma.reportViewer.create({
     *   data: {
     *     // ... data to create a ReportViewer
     *   }
     * })
     * 
     */
    create<T extends ReportViewerCreateArgs>(args: SelectSubset<T, ReportViewerCreateArgs<ExtArgs>>): Prisma__ReportViewerClient<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportViewers.
     * @param {ReportViewerCreateManyArgs} args - Arguments to create many ReportViewers.
     * @example
     * // Create many ReportViewers
     * const reportViewer = await prisma.reportViewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportViewerCreateManyArgs>(args?: SelectSubset<T, ReportViewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportViewers and returns the data saved in the database.
     * @param {ReportViewerCreateManyAndReturnArgs} args - Arguments to create many ReportViewers.
     * @example
     * // Create many ReportViewers
     * const reportViewer = await prisma.reportViewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportViewers and only return the `id`
     * const reportViewerWithIdOnly = await prisma.reportViewer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportViewerCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportViewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportViewer.
     * @param {ReportViewerDeleteArgs} args - Arguments to delete one ReportViewer.
     * @example
     * // Delete one ReportViewer
     * const ReportViewer = await prisma.reportViewer.delete({
     *   where: {
     *     // ... filter to delete one ReportViewer
     *   }
     * })
     * 
     */
    delete<T extends ReportViewerDeleteArgs>(args: SelectSubset<T, ReportViewerDeleteArgs<ExtArgs>>): Prisma__ReportViewerClient<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportViewer.
     * @param {ReportViewerUpdateArgs} args - Arguments to update one ReportViewer.
     * @example
     * // Update one ReportViewer
     * const reportViewer = await prisma.reportViewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportViewerUpdateArgs>(args: SelectSubset<T, ReportViewerUpdateArgs<ExtArgs>>): Prisma__ReportViewerClient<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportViewers.
     * @param {ReportViewerDeleteManyArgs} args - Arguments to filter ReportViewers to delete.
     * @example
     * // Delete a few ReportViewers
     * const { count } = await prisma.reportViewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportViewerDeleteManyArgs>(args?: SelectSubset<T, ReportViewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportViewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportViewers
     * const reportViewer = await prisma.reportViewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportViewerUpdateManyArgs>(args: SelectSubset<T, ReportViewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportViewers and returns the data updated in the database.
     * @param {ReportViewerUpdateManyAndReturnArgs} args - Arguments to update many ReportViewers.
     * @example
     * // Update many ReportViewers
     * const reportViewer = await prisma.reportViewer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportViewers and only return the `id`
     * const reportViewerWithIdOnly = await prisma.reportViewer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportViewerUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportViewerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportViewer.
     * @param {ReportViewerUpsertArgs} args - Arguments to update or create a ReportViewer.
     * @example
     * // Update or create a ReportViewer
     * const reportViewer = await prisma.reportViewer.upsert({
     *   create: {
     *     // ... data to create a ReportViewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportViewer we want to update
     *   }
     * })
     */
    upsert<T extends ReportViewerUpsertArgs>(args: SelectSubset<T, ReportViewerUpsertArgs<ExtArgs>>): Prisma__ReportViewerClient<$Result.GetResult<Prisma.$ReportViewerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportViewerCountArgs} args - Arguments to filter ReportViewers to count.
     * @example
     * // Count the number of ReportViewers
     * const count = await prisma.reportViewer.count({
     *   where: {
     *     // ... the filter for the ReportViewers we want to count
     *   }
     * })
    **/
    count<T extends ReportViewerCountArgs>(
      args?: Subset<T, ReportViewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportViewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportViewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportViewerAggregateArgs>(args: Subset<T, ReportViewerAggregateArgs>): Prisma.PrismaPromise<GetReportViewerAggregateType<T>>

    /**
     * Group by ReportViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportViewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportViewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportViewerGroupByArgs['orderBy'] }
        : { orderBy?: ReportViewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportViewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportViewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportViewer model
   */
  readonly fields: ReportViewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportViewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportViewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportViewer model
   */
  interface ReportViewerFieldRefs {
    readonly id: FieldRef<"ReportViewer", 'String'>
    readonly userId: FieldRef<"ReportViewer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReportViewer findUnique
   */
  export type ReportViewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    /**
     * Filter, which ReportViewer to fetch.
     */
    where: ReportViewerWhereUniqueInput
  }

  /**
   * ReportViewer findUniqueOrThrow
   */
  export type ReportViewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    /**
     * Filter, which ReportViewer to fetch.
     */
    where: ReportViewerWhereUniqueInput
  }

  /**
   * ReportViewer findFirst
   */
  export type ReportViewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    /**
     * Filter, which ReportViewer to fetch.
     */
    where?: ReportViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportViewers to fetch.
     */
    orderBy?: ReportViewerOrderByWithRelationInput | ReportViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportViewers.
     */
    cursor?: ReportViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportViewers.
     */
    distinct?: ReportViewerScalarFieldEnum | ReportViewerScalarFieldEnum[]
  }

  /**
   * ReportViewer findFirstOrThrow
   */
  export type ReportViewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    /**
     * Filter, which ReportViewer to fetch.
     */
    where?: ReportViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportViewers to fetch.
     */
    orderBy?: ReportViewerOrderByWithRelationInput | ReportViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportViewers.
     */
    cursor?: ReportViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportViewers.
     */
    distinct?: ReportViewerScalarFieldEnum | ReportViewerScalarFieldEnum[]
  }

  /**
   * ReportViewer findMany
   */
  export type ReportViewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    /**
     * Filter, which ReportViewers to fetch.
     */
    where?: ReportViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportViewers to fetch.
     */
    orderBy?: ReportViewerOrderByWithRelationInput | ReportViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportViewers.
     */
    cursor?: ReportViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportViewers.
     */
    skip?: number
    distinct?: ReportViewerScalarFieldEnum | ReportViewerScalarFieldEnum[]
  }

  /**
   * ReportViewer create
   */
  export type ReportViewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportViewer.
     */
    data: XOR<ReportViewerCreateInput, ReportViewerUncheckedCreateInput>
  }

  /**
   * ReportViewer createMany
   */
  export type ReportViewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportViewers.
     */
    data: ReportViewerCreateManyInput | ReportViewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportViewer createManyAndReturn
   */
  export type ReportViewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * The data used to create many ReportViewers.
     */
    data: ReportViewerCreateManyInput | ReportViewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportViewer update
   */
  export type ReportViewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportViewer.
     */
    data: XOR<ReportViewerUpdateInput, ReportViewerUncheckedUpdateInput>
    /**
     * Choose, which ReportViewer to update.
     */
    where: ReportViewerWhereUniqueInput
  }

  /**
   * ReportViewer updateMany
   */
  export type ReportViewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportViewers.
     */
    data: XOR<ReportViewerUpdateManyMutationInput, ReportViewerUncheckedUpdateManyInput>
    /**
     * Filter which ReportViewers to update
     */
    where?: ReportViewerWhereInput
    /**
     * Limit how many ReportViewers to update.
     */
    limit?: number
  }

  /**
   * ReportViewer updateManyAndReturn
   */
  export type ReportViewerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * The data used to update ReportViewers.
     */
    data: XOR<ReportViewerUpdateManyMutationInput, ReportViewerUncheckedUpdateManyInput>
    /**
     * Filter which ReportViewers to update
     */
    where?: ReportViewerWhereInput
    /**
     * Limit how many ReportViewers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportViewer upsert
   */
  export type ReportViewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportViewer to update in case it exists.
     */
    where: ReportViewerWhereUniqueInput
    /**
     * In case the ReportViewer found by the `where` argument doesn't exist, create a new ReportViewer with this data.
     */
    create: XOR<ReportViewerCreateInput, ReportViewerUncheckedCreateInput>
    /**
     * In case the ReportViewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportViewerUpdateInput, ReportViewerUncheckedUpdateInput>
  }

  /**
   * ReportViewer delete
   */
  export type ReportViewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
    /**
     * Filter which ReportViewer to delete.
     */
    where: ReportViewerWhereUniqueInput
  }

  /**
   * ReportViewer deleteMany
   */
  export type ReportViewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportViewers to delete
     */
    where?: ReportViewerWhereInput
    /**
     * Limit how many ReportViewers to delete.
     */
    limit?: number
  }

  /**
   * ReportViewer without action
   */
  export type ReportViewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportViewer
     */
    select?: ReportViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportViewer
     */
    omit?: ReportViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportViewerInclude<ExtArgs> | null
  }


  /**
   * Model academic_years
   */

  export type AggregateAcademic_years = {
    _count: Academic_yearsCountAggregateOutputType | null
    _min: Academic_yearsMinAggregateOutputType | null
    _max: Academic_yearsMaxAggregateOutputType | null
  }

  export type Academic_yearsMinAggregateOutputType = {
    year_id: string | null
    college_id: string | null
    year_name: string | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
  }

  export type Academic_yearsMaxAggregateOutputType = {
    year_id: string | null
    college_id: string | null
    year_name: string | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
  }

  export type Academic_yearsCountAggregateOutputType = {
    year_id: number
    college_id: number
    year_name: number
    start_date: number
    end_date: number
    is_active: number
    _all: number
  }


  export type Academic_yearsMinAggregateInputType = {
    year_id?: true
    college_id?: true
    year_name?: true
    start_date?: true
    end_date?: true
    is_active?: true
  }

  export type Academic_yearsMaxAggregateInputType = {
    year_id?: true
    college_id?: true
    year_name?: true
    start_date?: true
    end_date?: true
    is_active?: true
  }

  export type Academic_yearsCountAggregateInputType = {
    year_id?: true
    college_id?: true
    year_name?: true
    start_date?: true
    end_date?: true
    is_active?: true
    _all?: true
  }

  export type Academic_yearsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which academic_years to aggregate.
     */
    where?: academic_yearsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of academic_years to fetch.
     */
    orderBy?: academic_yearsOrderByWithRelationInput | academic_yearsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: academic_yearsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` academic_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` academic_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned academic_years
    **/
    _count?: true | Academic_yearsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Academic_yearsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Academic_yearsMaxAggregateInputType
  }

  export type GetAcademic_yearsAggregateType<T extends Academic_yearsAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademic_years]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademic_years[P]>
      : GetScalarType<T[P], AggregateAcademic_years[P]>
  }




  export type academic_yearsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: academic_yearsWhereInput
    orderBy?: academic_yearsOrderByWithAggregationInput | academic_yearsOrderByWithAggregationInput[]
    by: Academic_yearsScalarFieldEnum[] | Academic_yearsScalarFieldEnum
    having?: academic_yearsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Academic_yearsCountAggregateInputType | true
    _min?: Academic_yearsMinAggregateInputType
    _max?: Academic_yearsMaxAggregateInputType
  }

  export type Academic_yearsGroupByOutputType = {
    year_id: string
    college_id: string
    year_name: string
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
    _count: Academic_yearsCountAggregateOutputType | null
    _min: Academic_yearsMinAggregateOutputType | null
    _max: Academic_yearsMaxAggregateOutputType | null
  }

  type GetAcademic_yearsGroupByPayload<T extends academic_yearsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Academic_yearsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Academic_yearsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Academic_yearsGroupByOutputType[P]>
            : GetScalarType<T[P], Academic_yearsGroupByOutputType[P]>
        }
      >
    >


  export type academic_yearsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    year_id?: boolean
    college_id?: boolean
    year_name?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    course_offerings?: boolean | academic_years$course_offeringsArgs<ExtArgs>
    student_enrollments?: boolean | academic_years$student_enrollmentsArgs<ExtArgs>
    _count?: boolean | Academic_yearsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academic_years"]>

  export type academic_yearsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    year_id?: boolean
    college_id?: boolean
    year_name?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academic_years"]>

  export type academic_yearsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    year_id?: boolean
    college_id?: boolean
    year_name?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academic_years"]>

  export type academic_yearsSelectScalar = {
    year_id?: boolean
    college_id?: boolean
    year_name?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
  }

  export type academic_yearsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"year_id" | "college_id" | "year_name" | "start_date" | "end_date" | "is_active", ExtArgs["result"]["academic_years"]>
  export type academic_yearsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
    course_offerings?: boolean | academic_years$course_offeringsArgs<ExtArgs>
    student_enrollments?: boolean | academic_years$student_enrollmentsArgs<ExtArgs>
    _count?: boolean | Academic_yearsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type academic_yearsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
  }
  export type academic_yearsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colleges?: boolean | CollegeDefaultArgs<ExtArgs>
  }

  export type $academic_yearsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "academic_years"
    objects: {
      colleges: Prisma.$CollegePayload<ExtArgs>
      course_offerings: Prisma.$CourseOfferingPayload<ExtArgs>[]
      student_enrollments: Prisma.$StudentEnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      year_id: string
      college_id: string
      year_name: string
      start_date: Date | null
      end_date: Date | null
      is_active: boolean | null
    }, ExtArgs["result"]["academic_years"]>
    composites: {}
  }

  type academic_yearsGetPayload<S extends boolean | null | undefined | academic_yearsDefaultArgs> = $Result.GetResult<Prisma.$academic_yearsPayload, S>

  type academic_yearsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<academic_yearsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Academic_yearsCountAggregateInputType | true
    }

  export interface academic_yearsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['academic_years'], meta: { name: 'academic_years' } }
    /**
     * Find zero or one Academic_years that matches the filter.
     * @param {academic_yearsFindUniqueArgs} args - Arguments to find a Academic_years
     * @example
     * // Get one Academic_years
     * const academic_years = await prisma.academic_years.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends academic_yearsFindUniqueArgs>(args: SelectSubset<T, academic_yearsFindUniqueArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Academic_years that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {academic_yearsFindUniqueOrThrowArgs} args - Arguments to find a Academic_years
     * @example
     * // Get one Academic_years
     * const academic_years = await prisma.academic_years.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends academic_yearsFindUniqueOrThrowArgs>(args: SelectSubset<T, academic_yearsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Academic_years that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearsFindFirstArgs} args - Arguments to find a Academic_years
     * @example
     * // Get one Academic_years
     * const academic_years = await prisma.academic_years.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends academic_yearsFindFirstArgs>(args?: SelectSubset<T, academic_yearsFindFirstArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Academic_years that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearsFindFirstOrThrowArgs} args - Arguments to find a Academic_years
     * @example
     * // Get one Academic_years
     * const academic_years = await prisma.academic_years.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends academic_yearsFindFirstOrThrowArgs>(args?: SelectSubset<T, academic_yearsFindFirstOrThrowArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Academic_years that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Academic_years
     * const academic_years = await prisma.academic_years.findMany()
     * 
     * // Get first 10 Academic_years
     * const academic_years = await prisma.academic_years.findMany({ take: 10 })
     * 
     * // Only select the `year_id`
     * const academic_yearsWithYear_idOnly = await prisma.academic_years.findMany({ select: { year_id: true } })
     * 
     */
    findMany<T extends academic_yearsFindManyArgs>(args?: SelectSubset<T, academic_yearsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Academic_years.
     * @param {academic_yearsCreateArgs} args - Arguments to create a Academic_years.
     * @example
     * // Create one Academic_years
     * const Academic_years = await prisma.academic_years.create({
     *   data: {
     *     // ... data to create a Academic_years
     *   }
     * })
     * 
     */
    create<T extends academic_yearsCreateArgs>(args: SelectSubset<T, academic_yearsCreateArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Academic_years.
     * @param {academic_yearsCreateManyArgs} args - Arguments to create many Academic_years.
     * @example
     * // Create many Academic_years
     * const academic_years = await prisma.academic_years.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends academic_yearsCreateManyArgs>(args?: SelectSubset<T, academic_yearsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Academic_years and returns the data saved in the database.
     * @param {academic_yearsCreateManyAndReturnArgs} args - Arguments to create many Academic_years.
     * @example
     * // Create many Academic_years
     * const academic_years = await prisma.academic_years.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Academic_years and only return the `year_id`
     * const academic_yearsWithYear_idOnly = await prisma.academic_years.createManyAndReturn({
     *   select: { year_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends academic_yearsCreateManyAndReturnArgs>(args?: SelectSubset<T, academic_yearsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Academic_years.
     * @param {academic_yearsDeleteArgs} args - Arguments to delete one Academic_years.
     * @example
     * // Delete one Academic_years
     * const Academic_years = await prisma.academic_years.delete({
     *   where: {
     *     // ... filter to delete one Academic_years
     *   }
     * })
     * 
     */
    delete<T extends academic_yearsDeleteArgs>(args: SelectSubset<T, academic_yearsDeleteArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Academic_years.
     * @param {academic_yearsUpdateArgs} args - Arguments to update one Academic_years.
     * @example
     * // Update one Academic_years
     * const academic_years = await prisma.academic_years.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends academic_yearsUpdateArgs>(args: SelectSubset<T, academic_yearsUpdateArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Academic_years.
     * @param {academic_yearsDeleteManyArgs} args - Arguments to filter Academic_years to delete.
     * @example
     * // Delete a few Academic_years
     * const { count } = await prisma.academic_years.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends academic_yearsDeleteManyArgs>(args?: SelectSubset<T, academic_yearsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Academic_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Academic_years
     * const academic_years = await prisma.academic_years.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends academic_yearsUpdateManyArgs>(args: SelectSubset<T, academic_yearsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Academic_years and returns the data updated in the database.
     * @param {academic_yearsUpdateManyAndReturnArgs} args - Arguments to update many Academic_years.
     * @example
     * // Update many Academic_years
     * const academic_years = await prisma.academic_years.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Academic_years and only return the `year_id`
     * const academic_yearsWithYear_idOnly = await prisma.academic_years.updateManyAndReturn({
     *   select: { year_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends academic_yearsUpdateManyAndReturnArgs>(args: SelectSubset<T, academic_yearsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Academic_years.
     * @param {academic_yearsUpsertArgs} args - Arguments to update or create a Academic_years.
     * @example
     * // Update or create a Academic_years
     * const academic_years = await prisma.academic_years.upsert({
     *   create: {
     *     // ... data to create a Academic_years
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Academic_years we want to update
     *   }
     * })
     */
    upsert<T extends academic_yearsUpsertArgs>(args: SelectSubset<T, academic_yearsUpsertArgs<ExtArgs>>): Prisma__academic_yearsClient<$Result.GetResult<Prisma.$academic_yearsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Academic_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearsCountArgs} args - Arguments to filter Academic_years to count.
     * @example
     * // Count the number of Academic_years
     * const count = await prisma.academic_years.count({
     *   where: {
     *     // ... the filter for the Academic_years we want to count
     *   }
     * })
    **/
    count<T extends academic_yearsCountArgs>(
      args?: Subset<T, academic_yearsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Academic_yearsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Academic_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Academic_yearsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Academic_yearsAggregateArgs>(args: Subset<T, Academic_yearsAggregateArgs>): Prisma.PrismaPromise<GetAcademic_yearsAggregateType<T>>

    /**
     * Group by Academic_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends academic_yearsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: academic_yearsGroupByArgs['orderBy'] }
        : { orderBy?: academic_yearsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, academic_yearsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademic_yearsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the academic_years model
   */
  readonly fields: academic_yearsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for academic_years.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__academic_yearsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    colleges<T extends CollegeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollegeDefaultArgs<ExtArgs>>): Prisma__CollegeClient<$Result.GetResult<Prisma.$CollegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course_offerings<T extends academic_years$course_offeringsArgs<ExtArgs> = {}>(args?: Subset<T, academic_years$course_offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_enrollments<T extends academic_years$student_enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, academic_years$student_enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the academic_years model
   */
  interface academic_yearsFieldRefs {
    readonly year_id: FieldRef<"academic_years", 'String'>
    readonly college_id: FieldRef<"academic_years", 'String'>
    readonly year_name: FieldRef<"academic_years", 'String'>
    readonly start_date: FieldRef<"academic_years", 'DateTime'>
    readonly end_date: FieldRef<"academic_years", 'DateTime'>
    readonly is_active: FieldRef<"academic_years", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * academic_years findUnique
   */
  export type academic_yearsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    /**
     * Filter, which academic_years to fetch.
     */
    where: academic_yearsWhereUniqueInput
  }

  /**
   * academic_years findUniqueOrThrow
   */
  export type academic_yearsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    /**
     * Filter, which academic_years to fetch.
     */
    where: academic_yearsWhereUniqueInput
  }

  /**
   * academic_years findFirst
   */
  export type academic_yearsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    /**
     * Filter, which academic_years to fetch.
     */
    where?: academic_yearsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of academic_years to fetch.
     */
    orderBy?: academic_yearsOrderByWithRelationInput | academic_yearsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for academic_years.
     */
    cursor?: academic_yearsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` academic_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` academic_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of academic_years.
     */
    distinct?: Academic_yearsScalarFieldEnum | Academic_yearsScalarFieldEnum[]
  }

  /**
   * academic_years findFirstOrThrow
   */
  export type academic_yearsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    /**
     * Filter, which academic_years to fetch.
     */
    where?: academic_yearsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of academic_years to fetch.
     */
    orderBy?: academic_yearsOrderByWithRelationInput | academic_yearsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for academic_years.
     */
    cursor?: academic_yearsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` academic_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` academic_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of academic_years.
     */
    distinct?: Academic_yearsScalarFieldEnum | Academic_yearsScalarFieldEnum[]
  }

  /**
   * academic_years findMany
   */
  export type academic_yearsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    /**
     * Filter, which academic_years to fetch.
     */
    where?: academic_yearsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of academic_years to fetch.
     */
    orderBy?: academic_yearsOrderByWithRelationInput | academic_yearsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing academic_years.
     */
    cursor?: academic_yearsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` academic_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` academic_years.
     */
    skip?: number
    distinct?: Academic_yearsScalarFieldEnum | Academic_yearsScalarFieldEnum[]
  }

  /**
   * academic_years create
   */
  export type academic_yearsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    /**
     * The data needed to create a academic_years.
     */
    data: XOR<academic_yearsCreateInput, academic_yearsUncheckedCreateInput>
  }

  /**
   * academic_years createMany
   */
  export type academic_yearsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many academic_years.
     */
    data: academic_yearsCreateManyInput | academic_yearsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * academic_years createManyAndReturn
   */
  export type academic_yearsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * The data used to create many academic_years.
     */
    data: academic_yearsCreateManyInput | academic_yearsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * academic_years update
   */
  export type academic_yearsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    /**
     * The data needed to update a academic_years.
     */
    data: XOR<academic_yearsUpdateInput, academic_yearsUncheckedUpdateInput>
    /**
     * Choose, which academic_years to update.
     */
    where: academic_yearsWhereUniqueInput
  }

  /**
   * academic_years updateMany
   */
  export type academic_yearsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update academic_years.
     */
    data: XOR<academic_yearsUpdateManyMutationInput, academic_yearsUncheckedUpdateManyInput>
    /**
     * Filter which academic_years to update
     */
    where?: academic_yearsWhereInput
    /**
     * Limit how many academic_years to update.
     */
    limit?: number
  }

  /**
   * academic_years updateManyAndReturn
   */
  export type academic_yearsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * The data used to update academic_years.
     */
    data: XOR<academic_yearsUpdateManyMutationInput, academic_yearsUncheckedUpdateManyInput>
    /**
     * Filter which academic_years to update
     */
    where?: academic_yearsWhereInput
    /**
     * Limit how many academic_years to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * academic_years upsert
   */
  export type academic_yearsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    /**
     * The filter to search for the academic_years to update in case it exists.
     */
    where: academic_yearsWhereUniqueInput
    /**
     * In case the academic_years found by the `where` argument doesn't exist, create a new academic_years with this data.
     */
    create: XOR<academic_yearsCreateInput, academic_yearsUncheckedCreateInput>
    /**
     * In case the academic_years was found with the provided `where` argument, update it with this data.
     */
    update: XOR<academic_yearsUpdateInput, academic_yearsUncheckedUpdateInput>
  }

  /**
   * academic_years delete
   */
  export type academic_yearsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
    /**
     * Filter which academic_years to delete.
     */
    where: academic_yearsWhereUniqueInput
  }

  /**
   * academic_years deleteMany
   */
  export type academic_yearsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which academic_years to delete
     */
    where?: academic_yearsWhereInput
    /**
     * Limit how many academic_years to delete.
     */
    limit?: number
  }

  /**
   * academic_years.course_offerings
   */
  export type academic_years$course_offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    where?: CourseOfferingWhereInput
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    cursor?: CourseOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * academic_years.student_enrollments
   */
  export type academic_years$student_enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    cursor?: StudentEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * academic_years without action
   */
  export type academic_yearsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the academic_years
     */
    select?: academic_yearsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the academic_years
     */
    omit?: academic_yearsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: academic_yearsInclude<ExtArgs> | null
  }


  /**
   * Model sections
   */

  export type AggregateSections = {
    _count: SectionsCountAggregateOutputType | null
    _min: SectionsMinAggregateOutputType | null
    _max: SectionsMaxAggregateOutputType | null
  }

  export type SectionsMinAggregateOutputType = {
    section_id: string | null
    department_id: string | null
    section_name: string | null
  }

  export type SectionsMaxAggregateOutputType = {
    section_id: string | null
    department_id: string | null
    section_name: string | null
  }

  export type SectionsCountAggregateOutputType = {
    section_id: number
    department_id: number
    section_name: number
    _all: number
  }


  export type SectionsMinAggregateInputType = {
    section_id?: true
    department_id?: true
    section_name?: true
  }

  export type SectionsMaxAggregateInputType = {
    section_id?: true
    department_id?: true
    section_name?: true
  }

  export type SectionsCountAggregateInputType = {
    section_id?: true
    department_id?: true
    section_name?: true
    _all?: true
  }

  export type SectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sections to aggregate.
     */
    where?: sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sections to fetch.
     */
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sections
    **/
    _count?: true | SectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionsMaxAggregateInputType
  }

  export type GetSectionsAggregateType<T extends SectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSections[P]>
      : GetScalarType<T[P], AggregateSections[P]>
  }




  export type sectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sectionsWhereInput
    orderBy?: sectionsOrderByWithAggregationInput | sectionsOrderByWithAggregationInput[]
    by: SectionsScalarFieldEnum[] | SectionsScalarFieldEnum
    having?: sectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionsCountAggregateInputType | true
    _min?: SectionsMinAggregateInputType
    _max?: SectionsMaxAggregateInputType
  }

  export type SectionsGroupByOutputType = {
    section_id: string
    department_id: string
    section_name: string
    _count: SectionsCountAggregateOutputType | null
    _min: SectionsMinAggregateOutputType | null
    _max: SectionsMaxAggregateOutputType | null
  }

  type GetSectionsGroupByPayload<T extends sectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionsGroupByOutputType[P]>
            : GetScalarType<T[P], SectionsGroupByOutputType[P]>
        }
      >
    >


  export type sectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    section_id?: boolean
    department_id?: boolean
    section_name?: boolean
    course_offerings?: boolean | sections$course_offeringsArgs<ExtArgs>
    departments?: boolean | DepartmentDefaultArgs<ExtArgs>
    students?: boolean | sections$studentsArgs<ExtArgs>
    _count?: boolean | SectionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sections"]>

  export type sectionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    section_id?: boolean
    department_id?: boolean
    section_name?: boolean
    departments?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sections"]>

  export type sectionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    section_id?: boolean
    department_id?: boolean
    section_name?: boolean
    departments?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sections"]>

  export type sectionsSelectScalar = {
    section_id?: boolean
    department_id?: boolean
    section_name?: boolean
  }

  export type sectionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"section_id" | "department_id" | "section_name", ExtArgs["result"]["sections"]>
  export type sectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_offerings?: boolean | sections$course_offeringsArgs<ExtArgs>
    departments?: boolean | DepartmentDefaultArgs<ExtArgs>
    students?: boolean | sections$studentsArgs<ExtArgs>
    _count?: boolean | SectionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sectionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type sectionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $sectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sections"
    objects: {
      course_offerings: Prisma.$CourseOfferingPayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>
      students: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      section_id: string
      department_id: string
      section_name: string
    }, ExtArgs["result"]["sections"]>
    composites: {}
  }

  type sectionsGetPayload<S extends boolean | null | undefined | sectionsDefaultArgs> = $Result.GetResult<Prisma.$sectionsPayload, S>

  type sectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sectionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionsCountAggregateInputType | true
    }

  export interface sectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sections'], meta: { name: 'sections' } }
    /**
     * Find zero or one Sections that matches the filter.
     * @param {sectionsFindUniqueArgs} args - Arguments to find a Sections
     * @example
     * // Get one Sections
     * const sections = await prisma.sections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sectionsFindUniqueArgs>(args: SelectSubset<T, sectionsFindUniqueArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sections that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sectionsFindUniqueOrThrowArgs} args - Arguments to find a Sections
     * @example
     * // Get one Sections
     * const sections = await prisma.sections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sectionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sectionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsFindFirstArgs} args - Arguments to find a Sections
     * @example
     * // Get one Sections
     * const sections = await prisma.sections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sectionsFindFirstArgs>(args?: SelectSubset<T, sectionsFindFirstArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsFindFirstOrThrowArgs} args - Arguments to find a Sections
     * @example
     * // Get one Sections
     * const sections = await prisma.sections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sectionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sectionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.sections.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.sections.findMany({ take: 10 })
     * 
     * // Only select the `section_id`
     * const sectionsWithSection_idOnly = await prisma.sections.findMany({ select: { section_id: true } })
     * 
     */
    findMany<T extends sectionsFindManyArgs>(args?: SelectSubset<T, sectionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sections.
     * @param {sectionsCreateArgs} args - Arguments to create a Sections.
     * @example
     * // Create one Sections
     * const Sections = await prisma.sections.create({
     *   data: {
     *     // ... data to create a Sections
     *   }
     * })
     * 
     */
    create<T extends sectionsCreateArgs>(args: SelectSubset<T, sectionsCreateArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sections.
     * @param {sectionsCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const sections = await prisma.sections.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sectionsCreateManyArgs>(args?: SelectSubset<T, sectionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {sectionsCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const sections = await prisma.sections.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `section_id`
     * const sectionsWithSection_idOnly = await prisma.sections.createManyAndReturn({
     *   select: { section_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sectionsCreateManyAndReturnArgs>(args?: SelectSubset<T, sectionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sections.
     * @param {sectionsDeleteArgs} args - Arguments to delete one Sections.
     * @example
     * // Delete one Sections
     * const Sections = await prisma.sections.delete({
     *   where: {
     *     // ... filter to delete one Sections
     *   }
     * })
     * 
     */
    delete<T extends sectionsDeleteArgs>(args: SelectSubset<T, sectionsDeleteArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sections.
     * @param {sectionsUpdateArgs} args - Arguments to update one Sections.
     * @example
     * // Update one Sections
     * const sections = await prisma.sections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sectionsUpdateArgs>(args: SelectSubset<T, sectionsUpdateArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sections.
     * @param {sectionsDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.sections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sectionsDeleteManyArgs>(args?: SelectSubset<T, sectionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const sections = await prisma.sections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sectionsUpdateManyArgs>(args: SelectSubset<T, sectionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections and returns the data updated in the database.
     * @param {sectionsUpdateManyAndReturnArgs} args - Arguments to update many Sections.
     * @example
     * // Update many Sections
     * const sections = await prisma.sections.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sections and only return the `section_id`
     * const sectionsWithSection_idOnly = await prisma.sections.updateManyAndReturn({
     *   select: { section_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sectionsUpdateManyAndReturnArgs>(args: SelectSubset<T, sectionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sections.
     * @param {sectionsUpsertArgs} args - Arguments to update or create a Sections.
     * @example
     * // Update or create a Sections
     * const sections = await prisma.sections.upsert({
     *   create: {
     *     // ... data to create a Sections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sections we want to update
     *   }
     * })
     */
    upsert<T extends sectionsUpsertArgs>(args: SelectSubset<T, sectionsUpsertArgs<ExtArgs>>): Prisma__sectionsClient<$Result.GetResult<Prisma.$sectionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.sections.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends sectionsCountArgs>(
      args?: Subset<T, sectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionsAggregateArgs>(args: Subset<T, SectionsAggregateArgs>): Prisma.PrismaPromise<GetSectionsAggregateType<T>>

    /**
     * Group by Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sectionsGroupByArgs['orderBy'] }
        : { orderBy?: sectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sections model
   */
  readonly fields: sectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course_offerings<T extends sections$course_offeringsArgs<ExtArgs> = {}>(args?: Subset<T, sections$course_offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends sections$studentsArgs<ExtArgs> = {}>(args?: Subset<T, sections$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sections model
   */
  interface sectionsFieldRefs {
    readonly section_id: FieldRef<"sections", 'String'>
    readonly department_id: FieldRef<"sections", 'String'>
    readonly section_name: FieldRef<"sections", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sections findUnique
   */
  export type sectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where: sectionsWhereUniqueInput
  }

  /**
   * sections findUniqueOrThrow
   */
  export type sectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where: sectionsWhereUniqueInput
  }

  /**
   * sections findFirst
   */
  export type sectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where?: sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sections to fetch.
     */
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sections.
     */
    cursor?: sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sections.
     */
    distinct?: SectionsScalarFieldEnum | SectionsScalarFieldEnum[]
  }

  /**
   * sections findFirstOrThrow
   */
  export type sectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where?: sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sections to fetch.
     */
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sections.
     */
    cursor?: sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sections.
     */
    distinct?: SectionsScalarFieldEnum | SectionsScalarFieldEnum[]
  }

  /**
   * sections findMany
   */
  export type sectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter, which sections to fetch.
     */
    where?: sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sections to fetch.
     */
    orderBy?: sectionsOrderByWithRelationInput | sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sections.
     */
    cursor?: sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sections.
     */
    skip?: number
    distinct?: SectionsScalarFieldEnum | SectionsScalarFieldEnum[]
  }

  /**
   * sections create
   */
  export type sectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sections.
     */
    data: XOR<sectionsCreateInput, sectionsUncheckedCreateInput>
  }

  /**
   * sections createMany
   */
  export type sectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sections.
     */
    data: sectionsCreateManyInput | sectionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sections createManyAndReturn
   */
  export type sectionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * The data used to create many sections.
     */
    data: sectionsCreateManyInput | sectionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sections update
   */
  export type sectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sections.
     */
    data: XOR<sectionsUpdateInput, sectionsUncheckedUpdateInput>
    /**
     * Choose, which sections to update.
     */
    where: sectionsWhereUniqueInput
  }

  /**
   * sections updateMany
   */
  export type sectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sections.
     */
    data: XOR<sectionsUpdateManyMutationInput, sectionsUncheckedUpdateManyInput>
    /**
     * Filter which sections to update
     */
    where?: sectionsWhereInput
    /**
     * Limit how many sections to update.
     */
    limit?: number
  }

  /**
   * sections updateManyAndReturn
   */
  export type sectionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * The data used to update sections.
     */
    data: XOR<sectionsUpdateManyMutationInput, sectionsUncheckedUpdateManyInput>
    /**
     * Filter which sections to update
     */
    where?: sectionsWhereInput
    /**
     * Limit how many sections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sections upsert
   */
  export type sectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sections to update in case it exists.
     */
    where: sectionsWhereUniqueInput
    /**
     * In case the sections found by the `where` argument doesn't exist, create a new sections with this data.
     */
    create: XOR<sectionsCreateInput, sectionsUncheckedCreateInput>
    /**
     * In case the sections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sectionsUpdateInput, sectionsUncheckedUpdateInput>
  }

  /**
   * sections delete
   */
  export type sectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
    /**
     * Filter which sections to delete.
     */
    where: sectionsWhereUniqueInput
  }

  /**
   * sections deleteMany
   */
  export type sectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sections to delete
     */
    where?: sectionsWhereInput
    /**
     * Limit how many sections to delete.
     */
    limit?: number
  }

  /**
   * sections.course_offerings
   */
  export type sections$course_offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    where?: CourseOfferingWhereInput
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    cursor?: CourseOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * sections.students
   */
  export type sections$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * sections without action
   */
  export type sectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sections
     */
    select?: sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sections
     */
    omit?: sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectionsInclude<ExtArgs> | null
  }


  /**
   * Model TestComponent
   */

  export type AggregateTestComponent = {
    _count: TestComponentCountAggregateOutputType | null
    _avg: TestComponentAvgAggregateOutputType | null
    _sum: TestComponentSumAggregateOutputType | null
    _min: TestComponentMinAggregateOutputType | null
    _max: TestComponentMaxAggregateOutputType | null
  }

  export type TestComponentAvgAggregateOutputType = {
    maxMarks: number | null
    weightage: number | null
  }

  export type TestComponentSumAggregateOutputType = {
    maxMarks: number | null
    weightage: number | null
  }

  export type TestComponentMinAggregateOutputType = {
    id: string | null
    courseOfferingId: string | null
    name: string | null
    maxMarks: number | null
    weightage: number | null
  }

  export type TestComponentMaxAggregateOutputType = {
    id: string | null
    courseOfferingId: string | null
    name: string | null
    maxMarks: number | null
    weightage: number | null
  }

  export type TestComponentCountAggregateOutputType = {
    id: number
    courseOfferingId: number
    name: number
    maxMarks: number
    weightage: number
    _all: number
  }


  export type TestComponentAvgAggregateInputType = {
    maxMarks?: true
    weightage?: true
  }

  export type TestComponentSumAggregateInputType = {
    maxMarks?: true
    weightage?: true
  }

  export type TestComponentMinAggregateInputType = {
    id?: true
    courseOfferingId?: true
    name?: true
    maxMarks?: true
    weightage?: true
  }

  export type TestComponentMaxAggregateInputType = {
    id?: true
    courseOfferingId?: true
    name?: true
    maxMarks?: true
    weightage?: true
  }

  export type TestComponentCountAggregateInputType = {
    id?: true
    courseOfferingId?: true
    name?: true
    maxMarks?: true
    weightage?: true
    _all?: true
  }

  export type TestComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestComponent to aggregate.
     */
    where?: TestComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestComponents to fetch.
     */
    orderBy?: TestComponentOrderByWithRelationInput | TestComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestComponents
    **/
    _count?: true | TestComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestComponentMaxAggregateInputType
  }

  export type GetTestComponentAggregateType<T extends TestComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateTestComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestComponent[P]>
      : GetScalarType<T[P], AggregateTestComponent[P]>
  }




  export type TestComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestComponentWhereInput
    orderBy?: TestComponentOrderByWithAggregationInput | TestComponentOrderByWithAggregationInput[]
    by: TestComponentScalarFieldEnum[] | TestComponentScalarFieldEnum
    having?: TestComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestComponentCountAggregateInputType | true
    _avg?: TestComponentAvgAggregateInputType
    _sum?: TestComponentSumAggregateInputType
    _min?: TestComponentMinAggregateInputType
    _max?: TestComponentMaxAggregateInputType
  }

  export type TestComponentGroupByOutputType = {
    id: string
    courseOfferingId: string
    name: string
    maxMarks: number
    weightage: number
    _count: TestComponentCountAggregateOutputType | null
    _avg: TestComponentAvgAggregateOutputType | null
    _sum: TestComponentSumAggregateOutputType | null
    _min: TestComponentMinAggregateOutputType | null
    _max: TestComponentMaxAggregateOutputType | null
  }

  type GetTestComponentGroupByPayload<T extends TestComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestComponentGroupByOutputType[P]>
            : GetScalarType<T[P], TestComponentGroupByOutputType[P]>
        }
      >
    >


  export type TestComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseOfferingId?: boolean
    name?: boolean
    maxMarks?: boolean
    weightage?: boolean
    courseOffering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
    studentMarks?: boolean | TestComponent$studentMarksArgs<ExtArgs>
    _count?: boolean | TestComponentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testComponent"]>

  export type TestComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseOfferingId?: boolean
    name?: boolean
    maxMarks?: boolean
    weightage?: boolean
    courseOffering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testComponent"]>

  export type TestComponentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseOfferingId?: boolean
    name?: boolean
    maxMarks?: boolean
    weightage?: boolean
    courseOffering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testComponent"]>

  export type TestComponentSelectScalar = {
    id?: boolean
    courseOfferingId?: boolean
    name?: boolean
    maxMarks?: boolean
    weightage?: boolean
  }

  export type TestComponentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseOfferingId" | "name" | "maxMarks" | "weightage", ExtArgs["result"]["testComponent"]>
  export type TestComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseOffering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
    studentMarks?: boolean | TestComponent$studentMarksArgs<ExtArgs>
    _count?: boolean | TestComponentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseOffering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }
  export type TestComponentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseOffering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }

  export type $TestComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestComponent"
    objects: {
      courseOffering: Prisma.$CourseOfferingPayload<ExtArgs>
      studentMarks: Prisma.$StudentMarkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseOfferingId: string
      name: string
      maxMarks: number
      weightage: number
    }, ExtArgs["result"]["testComponent"]>
    composites: {}
  }

  type TestComponentGetPayload<S extends boolean | null | undefined | TestComponentDefaultArgs> = $Result.GetResult<Prisma.$TestComponentPayload, S>

  type TestComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestComponentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestComponentCountAggregateInputType | true
    }

  export interface TestComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestComponent'], meta: { name: 'TestComponent' } }
    /**
     * Find zero or one TestComponent that matches the filter.
     * @param {TestComponentFindUniqueArgs} args - Arguments to find a TestComponent
     * @example
     * // Get one TestComponent
     * const testComponent = await prisma.testComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestComponentFindUniqueArgs>(args: SelectSubset<T, TestComponentFindUniqueArgs<ExtArgs>>): Prisma__TestComponentClient<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestComponent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestComponentFindUniqueOrThrowArgs} args - Arguments to find a TestComponent
     * @example
     * // Get one TestComponent
     * const testComponent = await prisma.testComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, TestComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestComponentClient<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestComponentFindFirstArgs} args - Arguments to find a TestComponent
     * @example
     * // Get one TestComponent
     * const testComponent = await prisma.testComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestComponentFindFirstArgs>(args?: SelectSubset<T, TestComponentFindFirstArgs<ExtArgs>>): Prisma__TestComponentClient<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestComponentFindFirstOrThrowArgs} args - Arguments to find a TestComponent
     * @example
     * // Get one TestComponent
     * const testComponent = await prisma.testComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, TestComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestComponentClient<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestComponents
     * const testComponents = await prisma.testComponent.findMany()
     * 
     * // Get first 10 TestComponents
     * const testComponents = await prisma.testComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testComponentWithIdOnly = await prisma.testComponent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestComponentFindManyArgs>(args?: SelectSubset<T, TestComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestComponent.
     * @param {TestComponentCreateArgs} args - Arguments to create a TestComponent.
     * @example
     * // Create one TestComponent
     * const TestComponent = await prisma.testComponent.create({
     *   data: {
     *     // ... data to create a TestComponent
     *   }
     * })
     * 
     */
    create<T extends TestComponentCreateArgs>(args: SelectSubset<T, TestComponentCreateArgs<ExtArgs>>): Prisma__TestComponentClient<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestComponents.
     * @param {TestComponentCreateManyArgs} args - Arguments to create many TestComponents.
     * @example
     * // Create many TestComponents
     * const testComponent = await prisma.testComponent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestComponentCreateManyArgs>(args?: SelectSubset<T, TestComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestComponents and returns the data saved in the database.
     * @param {TestComponentCreateManyAndReturnArgs} args - Arguments to create many TestComponents.
     * @example
     * // Create many TestComponents
     * const testComponent = await prisma.testComponent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestComponents and only return the `id`
     * const testComponentWithIdOnly = await prisma.testComponent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, TestComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestComponent.
     * @param {TestComponentDeleteArgs} args - Arguments to delete one TestComponent.
     * @example
     * // Delete one TestComponent
     * const TestComponent = await prisma.testComponent.delete({
     *   where: {
     *     // ... filter to delete one TestComponent
     *   }
     * })
     * 
     */
    delete<T extends TestComponentDeleteArgs>(args: SelectSubset<T, TestComponentDeleteArgs<ExtArgs>>): Prisma__TestComponentClient<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestComponent.
     * @param {TestComponentUpdateArgs} args - Arguments to update one TestComponent.
     * @example
     * // Update one TestComponent
     * const testComponent = await prisma.testComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestComponentUpdateArgs>(args: SelectSubset<T, TestComponentUpdateArgs<ExtArgs>>): Prisma__TestComponentClient<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestComponents.
     * @param {TestComponentDeleteManyArgs} args - Arguments to filter TestComponents to delete.
     * @example
     * // Delete a few TestComponents
     * const { count } = await prisma.testComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestComponentDeleteManyArgs>(args?: SelectSubset<T, TestComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestComponents
     * const testComponent = await prisma.testComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestComponentUpdateManyArgs>(args: SelectSubset<T, TestComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestComponents and returns the data updated in the database.
     * @param {TestComponentUpdateManyAndReturnArgs} args - Arguments to update many TestComponents.
     * @example
     * // Update many TestComponents
     * const testComponent = await prisma.testComponent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestComponents and only return the `id`
     * const testComponentWithIdOnly = await prisma.testComponent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestComponentUpdateManyAndReturnArgs>(args: SelectSubset<T, TestComponentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestComponent.
     * @param {TestComponentUpsertArgs} args - Arguments to update or create a TestComponent.
     * @example
     * // Update or create a TestComponent
     * const testComponent = await prisma.testComponent.upsert({
     *   create: {
     *     // ... data to create a TestComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestComponent we want to update
     *   }
     * })
     */
    upsert<T extends TestComponentUpsertArgs>(args: SelectSubset<T, TestComponentUpsertArgs<ExtArgs>>): Prisma__TestComponentClient<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestComponentCountArgs} args - Arguments to filter TestComponents to count.
     * @example
     * // Count the number of TestComponents
     * const count = await prisma.testComponent.count({
     *   where: {
     *     // ... the filter for the TestComponents we want to count
     *   }
     * })
    **/
    count<T extends TestComponentCountArgs>(
      args?: Subset<T, TestComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestComponentAggregateArgs>(args: Subset<T, TestComponentAggregateArgs>): Prisma.PrismaPromise<GetTestComponentAggregateType<T>>

    /**
     * Group by TestComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestComponentGroupByArgs['orderBy'] }
        : { orderBy?: TestComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestComponent model
   */
  readonly fields: TestComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseOffering<T extends CourseOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseOfferingDefaultArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentMarks<T extends TestComponent$studentMarksArgs<ExtArgs> = {}>(args?: Subset<T, TestComponent$studentMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestComponent model
   */
  interface TestComponentFieldRefs {
    readonly id: FieldRef<"TestComponent", 'String'>
    readonly courseOfferingId: FieldRef<"TestComponent", 'String'>
    readonly name: FieldRef<"TestComponent", 'String'>
    readonly maxMarks: FieldRef<"TestComponent", 'Int'>
    readonly weightage: FieldRef<"TestComponent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TestComponent findUnique
   */
  export type TestComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    /**
     * Filter, which TestComponent to fetch.
     */
    where: TestComponentWhereUniqueInput
  }

  /**
   * TestComponent findUniqueOrThrow
   */
  export type TestComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    /**
     * Filter, which TestComponent to fetch.
     */
    where: TestComponentWhereUniqueInput
  }

  /**
   * TestComponent findFirst
   */
  export type TestComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    /**
     * Filter, which TestComponent to fetch.
     */
    where?: TestComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestComponents to fetch.
     */
    orderBy?: TestComponentOrderByWithRelationInput | TestComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestComponents.
     */
    cursor?: TestComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestComponents.
     */
    distinct?: TestComponentScalarFieldEnum | TestComponentScalarFieldEnum[]
  }

  /**
   * TestComponent findFirstOrThrow
   */
  export type TestComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    /**
     * Filter, which TestComponent to fetch.
     */
    where?: TestComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestComponents to fetch.
     */
    orderBy?: TestComponentOrderByWithRelationInput | TestComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestComponents.
     */
    cursor?: TestComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestComponents.
     */
    distinct?: TestComponentScalarFieldEnum | TestComponentScalarFieldEnum[]
  }

  /**
   * TestComponent findMany
   */
  export type TestComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    /**
     * Filter, which TestComponents to fetch.
     */
    where?: TestComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestComponents to fetch.
     */
    orderBy?: TestComponentOrderByWithRelationInput | TestComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestComponents.
     */
    cursor?: TestComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestComponents.
     */
    skip?: number
    distinct?: TestComponentScalarFieldEnum | TestComponentScalarFieldEnum[]
  }

  /**
   * TestComponent create
   */
  export type TestComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a TestComponent.
     */
    data: XOR<TestComponentCreateInput, TestComponentUncheckedCreateInput>
  }

  /**
   * TestComponent createMany
   */
  export type TestComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestComponents.
     */
    data: TestComponentCreateManyInput | TestComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestComponent createManyAndReturn
   */
  export type TestComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * The data used to create many TestComponents.
     */
    data: TestComponentCreateManyInput | TestComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestComponent update
   */
  export type TestComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a TestComponent.
     */
    data: XOR<TestComponentUpdateInput, TestComponentUncheckedUpdateInput>
    /**
     * Choose, which TestComponent to update.
     */
    where: TestComponentWhereUniqueInput
  }

  /**
   * TestComponent updateMany
   */
  export type TestComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestComponents.
     */
    data: XOR<TestComponentUpdateManyMutationInput, TestComponentUncheckedUpdateManyInput>
    /**
     * Filter which TestComponents to update
     */
    where?: TestComponentWhereInput
    /**
     * Limit how many TestComponents to update.
     */
    limit?: number
  }

  /**
   * TestComponent updateManyAndReturn
   */
  export type TestComponentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * The data used to update TestComponents.
     */
    data: XOR<TestComponentUpdateManyMutationInput, TestComponentUncheckedUpdateManyInput>
    /**
     * Filter which TestComponents to update
     */
    where?: TestComponentWhereInput
    /**
     * Limit how many TestComponents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestComponent upsert
   */
  export type TestComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the TestComponent to update in case it exists.
     */
    where: TestComponentWhereUniqueInput
    /**
     * In case the TestComponent found by the `where` argument doesn't exist, create a new TestComponent with this data.
     */
    create: XOR<TestComponentCreateInput, TestComponentUncheckedCreateInput>
    /**
     * In case the TestComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestComponentUpdateInput, TestComponentUncheckedUpdateInput>
  }

  /**
   * TestComponent delete
   */
  export type TestComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
    /**
     * Filter which TestComponent to delete.
     */
    where: TestComponentWhereUniqueInput
  }

  /**
   * TestComponent deleteMany
   */
  export type TestComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestComponents to delete
     */
    where?: TestComponentWhereInput
    /**
     * Limit how many TestComponents to delete.
     */
    limit?: number
  }

  /**
   * TestComponent.studentMarks
   */
  export type TestComponent$studentMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    where?: StudentMarkWhereInput
    orderBy?: StudentMarkOrderByWithRelationInput | StudentMarkOrderByWithRelationInput[]
    cursor?: StudentMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentMarkScalarFieldEnum | StudentMarkScalarFieldEnum[]
  }

  /**
   * TestComponent without action
   */
  export type TestComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestComponent
     */
    select?: TestComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestComponent
     */
    omit?: TestComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestComponentInclude<ExtArgs> | null
  }


  /**
   * Model StudentMark
   */

  export type AggregateStudentMark = {
    _count: StudentMarkCountAggregateOutputType | null
    _avg: StudentMarkAvgAggregateOutputType | null
    _sum: StudentMarkSumAggregateOutputType | null
    _min: StudentMarkMinAggregateOutputType | null
    _max: StudentMarkMaxAggregateOutputType | null
  }

  export type StudentMarkAvgAggregateOutputType = {
    marksObtained: number | null
  }

  export type StudentMarkSumAggregateOutputType = {
    marksObtained: number | null
  }

  export type StudentMarkMinAggregateOutputType = {
    id: string | null
    enrollmentId: string | null
    testComponentId: string | null
    marksObtained: number | null
  }

  export type StudentMarkMaxAggregateOutputType = {
    id: string | null
    enrollmentId: string | null
    testComponentId: string | null
    marksObtained: number | null
  }

  export type StudentMarkCountAggregateOutputType = {
    id: number
    enrollmentId: number
    testComponentId: number
    marksObtained: number
    _all: number
  }


  export type StudentMarkAvgAggregateInputType = {
    marksObtained?: true
  }

  export type StudentMarkSumAggregateInputType = {
    marksObtained?: true
  }

  export type StudentMarkMinAggregateInputType = {
    id?: true
    enrollmentId?: true
    testComponentId?: true
    marksObtained?: true
  }

  export type StudentMarkMaxAggregateInputType = {
    id?: true
    enrollmentId?: true
    testComponentId?: true
    marksObtained?: true
  }

  export type StudentMarkCountAggregateInputType = {
    id?: true
    enrollmentId?: true
    testComponentId?: true
    marksObtained?: true
    _all?: true
  }

  export type StudentMarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentMark to aggregate.
     */
    where?: StudentMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMarks to fetch.
     */
    orderBy?: StudentMarkOrderByWithRelationInput | StudentMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentMarks
    **/
    _count?: true | StudentMarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentMarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentMarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMarkMaxAggregateInputType
  }

  export type GetStudentMarkAggregateType<T extends StudentMarkAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentMark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentMark[P]>
      : GetScalarType<T[P], AggregateStudentMark[P]>
  }




  export type StudentMarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentMarkWhereInput
    orderBy?: StudentMarkOrderByWithAggregationInput | StudentMarkOrderByWithAggregationInput[]
    by: StudentMarkScalarFieldEnum[] | StudentMarkScalarFieldEnum
    having?: StudentMarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentMarkCountAggregateInputType | true
    _avg?: StudentMarkAvgAggregateInputType
    _sum?: StudentMarkSumAggregateInputType
    _min?: StudentMarkMinAggregateInputType
    _max?: StudentMarkMaxAggregateInputType
  }

  export type StudentMarkGroupByOutputType = {
    id: string
    enrollmentId: string
    testComponentId: string
    marksObtained: number | null
    _count: StudentMarkCountAggregateOutputType | null
    _avg: StudentMarkAvgAggregateOutputType | null
    _sum: StudentMarkSumAggregateOutputType | null
    _min: StudentMarkMinAggregateOutputType | null
    _max: StudentMarkMaxAggregateOutputType | null
  }

  type GetStudentMarkGroupByPayload<T extends StudentMarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentMarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentMarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentMarkGroupByOutputType[P]>
            : GetScalarType<T[P], StudentMarkGroupByOutputType[P]>
        }
      >
    >


  export type StudentMarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    testComponentId?: boolean
    marksObtained?: boolean
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    testComponent?: boolean | TestComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentMark"]>

  export type StudentMarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    testComponentId?: boolean
    marksObtained?: boolean
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    testComponent?: boolean | TestComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentMark"]>

  export type StudentMarkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrollmentId?: boolean
    testComponentId?: boolean
    marksObtained?: boolean
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    testComponent?: boolean | TestComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentMark"]>

  export type StudentMarkSelectScalar = {
    id?: boolean
    enrollmentId?: boolean
    testComponentId?: boolean
    marksObtained?: boolean
  }

  export type StudentMarkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enrollmentId" | "testComponentId" | "marksObtained", ExtArgs["result"]["studentMark"]>
  export type StudentMarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    testComponent?: boolean | TestComponentDefaultArgs<ExtArgs>
  }
  export type StudentMarkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    testComponent?: boolean | TestComponentDefaultArgs<ExtArgs>
  }
  export type StudentMarkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | StudentEnrollmentDefaultArgs<ExtArgs>
    testComponent?: boolean | TestComponentDefaultArgs<ExtArgs>
  }

  export type $StudentMarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentMark"
    objects: {
      enrollment: Prisma.$StudentEnrollmentPayload<ExtArgs>
      testComponent: Prisma.$TestComponentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enrollmentId: string
      testComponentId: string
      marksObtained: number | null
    }, ExtArgs["result"]["studentMark"]>
    composites: {}
  }

  type StudentMarkGetPayload<S extends boolean | null | undefined | StudentMarkDefaultArgs> = $Result.GetResult<Prisma.$StudentMarkPayload, S>

  type StudentMarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentMarkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentMarkCountAggregateInputType | true
    }

  export interface StudentMarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentMark'], meta: { name: 'StudentMark' } }
    /**
     * Find zero or one StudentMark that matches the filter.
     * @param {StudentMarkFindUniqueArgs} args - Arguments to find a StudentMark
     * @example
     * // Get one StudentMark
     * const studentMark = await prisma.studentMark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentMarkFindUniqueArgs>(args: SelectSubset<T, StudentMarkFindUniqueArgs<ExtArgs>>): Prisma__StudentMarkClient<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentMark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentMarkFindUniqueOrThrowArgs} args - Arguments to find a StudentMark
     * @example
     * // Get one StudentMark
     * const studentMark = await prisma.studentMark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentMarkFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentMarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentMarkClient<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentMark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMarkFindFirstArgs} args - Arguments to find a StudentMark
     * @example
     * // Get one StudentMark
     * const studentMark = await prisma.studentMark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentMarkFindFirstArgs>(args?: SelectSubset<T, StudentMarkFindFirstArgs<ExtArgs>>): Prisma__StudentMarkClient<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentMark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMarkFindFirstOrThrowArgs} args - Arguments to find a StudentMark
     * @example
     * // Get one StudentMark
     * const studentMark = await prisma.studentMark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentMarkFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentMarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentMarkClient<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentMarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentMarks
     * const studentMarks = await prisma.studentMark.findMany()
     * 
     * // Get first 10 StudentMarks
     * const studentMarks = await prisma.studentMark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentMarkWithIdOnly = await prisma.studentMark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentMarkFindManyArgs>(args?: SelectSubset<T, StudentMarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentMark.
     * @param {StudentMarkCreateArgs} args - Arguments to create a StudentMark.
     * @example
     * // Create one StudentMark
     * const StudentMark = await prisma.studentMark.create({
     *   data: {
     *     // ... data to create a StudentMark
     *   }
     * })
     * 
     */
    create<T extends StudentMarkCreateArgs>(args: SelectSubset<T, StudentMarkCreateArgs<ExtArgs>>): Prisma__StudentMarkClient<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentMarks.
     * @param {StudentMarkCreateManyArgs} args - Arguments to create many StudentMarks.
     * @example
     * // Create many StudentMarks
     * const studentMark = await prisma.studentMark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentMarkCreateManyArgs>(args?: SelectSubset<T, StudentMarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentMarks and returns the data saved in the database.
     * @param {StudentMarkCreateManyAndReturnArgs} args - Arguments to create many StudentMarks.
     * @example
     * // Create many StudentMarks
     * const studentMark = await prisma.studentMark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentMarks and only return the `id`
     * const studentMarkWithIdOnly = await prisma.studentMark.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentMarkCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentMarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentMark.
     * @param {StudentMarkDeleteArgs} args - Arguments to delete one StudentMark.
     * @example
     * // Delete one StudentMark
     * const StudentMark = await prisma.studentMark.delete({
     *   where: {
     *     // ... filter to delete one StudentMark
     *   }
     * })
     * 
     */
    delete<T extends StudentMarkDeleteArgs>(args: SelectSubset<T, StudentMarkDeleteArgs<ExtArgs>>): Prisma__StudentMarkClient<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentMark.
     * @param {StudentMarkUpdateArgs} args - Arguments to update one StudentMark.
     * @example
     * // Update one StudentMark
     * const studentMark = await prisma.studentMark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentMarkUpdateArgs>(args: SelectSubset<T, StudentMarkUpdateArgs<ExtArgs>>): Prisma__StudentMarkClient<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentMarks.
     * @param {StudentMarkDeleteManyArgs} args - Arguments to filter StudentMarks to delete.
     * @example
     * // Delete a few StudentMarks
     * const { count } = await prisma.studentMark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentMarkDeleteManyArgs>(args?: SelectSubset<T, StudentMarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentMarks
     * const studentMark = await prisma.studentMark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentMarkUpdateManyArgs>(args: SelectSubset<T, StudentMarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentMarks and returns the data updated in the database.
     * @param {StudentMarkUpdateManyAndReturnArgs} args - Arguments to update many StudentMarks.
     * @example
     * // Update many StudentMarks
     * const studentMark = await prisma.studentMark.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentMarks and only return the `id`
     * const studentMarkWithIdOnly = await prisma.studentMark.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentMarkUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentMarkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentMark.
     * @param {StudentMarkUpsertArgs} args - Arguments to update or create a StudentMark.
     * @example
     * // Update or create a StudentMark
     * const studentMark = await prisma.studentMark.upsert({
     *   create: {
     *     // ... data to create a StudentMark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentMark we want to update
     *   }
     * })
     */
    upsert<T extends StudentMarkUpsertArgs>(args: SelectSubset<T, StudentMarkUpsertArgs<ExtArgs>>): Prisma__StudentMarkClient<$Result.GetResult<Prisma.$StudentMarkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMarkCountArgs} args - Arguments to filter StudentMarks to count.
     * @example
     * // Count the number of StudentMarks
     * const count = await prisma.studentMark.count({
     *   where: {
     *     // ... the filter for the StudentMarks we want to count
     *   }
     * })
    **/
    count<T extends StudentMarkCountArgs>(
      args?: Subset<T, StudentMarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentMarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentMarkAggregateArgs>(args: Subset<T, StudentMarkAggregateArgs>): Prisma.PrismaPromise<GetStudentMarkAggregateType<T>>

    /**
     * Group by StudentMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentMarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentMarkGroupByArgs['orderBy'] }
        : { orderBy?: StudentMarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentMarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentMarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentMark model
   */
  readonly fields: StudentMarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentMark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentMarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollment<T extends StudentEnrollmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollmentDefaultArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    testComponent<T extends TestComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestComponentDefaultArgs<ExtArgs>>): Prisma__TestComponentClient<$Result.GetResult<Prisma.$TestComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentMark model
   */
  interface StudentMarkFieldRefs {
    readonly id: FieldRef<"StudentMark", 'String'>
    readonly enrollmentId: FieldRef<"StudentMark", 'String'>
    readonly testComponentId: FieldRef<"StudentMark", 'String'>
    readonly marksObtained: FieldRef<"StudentMark", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StudentMark findUnique
   */
  export type StudentMarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentMark to fetch.
     */
    where: StudentMarkWhereUniqueInput
  }

  /**
   * StudentMark findUniqueOrThrow
   */
  export type StudentMarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentMark to fetch.
     */
    where: StudentMarkWhereUniqueInput
  }

  /**
   * StudentMark findFirst
   */
  export type StudentMarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentMark to fetch.
     */
    where?: StudentMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMarks to fetch.
     */
    orderBy?: StudentMarkOrderByWithRelationInput | StudentMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentMarks.
     */
    cursor?: StudentMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentMarks.
     */
    distinct?: StudentMarkScalarFieldEnum | StudentMarkScalarFieldEnum[]
  }

  /**
   * StudentMark findFirstOrThrow
   */
  export type StudentMarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentMark to fetch.
     */
    where?: StudentMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMarks to fetch.
     */
    orderBy?: StudentMarkOrderByWithRelationInput | StudentMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentMarks.
     */
    cursor?: StudentMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentMarks.
     */
    distinct?: StudentMarkScalarFieldEnum | StudentMarkScalarFieldEnum[]
  }

  /**
   * StudentMark findMany
   */
  export type StudentMarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentMarks to fetch.
     */
    where?: StudentMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMarks to fetch.
     */
    orderBy?: StudentMarkOrderByWithRelationInput | StudentMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentMarks.
     */
    cursor?: StudentMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMarks.
     */
    skip?: number
    distinct?: StudentMarkScalarFieldEnum | StudentMarkScalarFieldEnum[]
  }

  /**
   * StudentMark create
   */
  export type StudentMarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentMark.
     */
    data: XOR<StudentMarkCreateInput, StudentMarkUncheckedCreateInput>
  }

  /**
   * StudentMark createMany
   */
  export type StudentMarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentMarks.
     */
    data: StudentMarkCreateManyInput | StudentMarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentMark createManyAndReturn
   */
  export type StudentMarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * The data used to create many StudentMarks.
     */
    data: StudentMarkCreateManyInput | StudentMarkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentMark update
   */
  export type StudentMarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentMark.
     */
    data: XOR<StudentMarkUpdateInput, StudentMarkUncheckedUpdateInput>
    /**
     * Choose, which StudentMark to update.
     */
    where: StudentMarkWhereUniqueInput
  }

  /**
   * StudentMark updateMany
   */
  export type StudentMarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentMarks.
     */
    data: XOR<StudentMarkUpdateManyMutationInput, StudentMarkUncheckedUpdateManyInput>
    /**
     * Filter which StudentMarks to update
     */
    where?: StudentMarkWhereInput
    /**
     * Limit how many StudentMarks to update.
     */
    limit?: number
  }

  /**
   * StudentMark updateManyAndReturn
   */
  export type StudentMarkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * The data used to update StudentMarks.
     */
    data: XOR<StudentMarkUpdateManyMutationInput, StudentMarkUncheckedUpdateManyInput>
    /**
     * Filter which StudentMarks to update
     */
    where?: StudentMarkWhereInput
    /**
     * Limit how many StudentMarks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentMark upsert
   */
  export type StudentMarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentMark to update in case it exists.
     */
    where: StudentMarkWhereUniqueInput
    /**
     * In case the StudentMark found by the `where` argument doesn't exist, create a new StudentMark with this data.
     */
    create: XOR<StudentMarkCreateInput, StudentMarkUncheckedCreateInput>
    /**
     * In case the StudentMark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentMarkUpdateInput, StudentMarkUncheckedUpdateInput>
  }

  /**
   * StudentMark delete
   */
  export type StudentMarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
    /**
     * Filter which StudentMark to delete.
     */
    where: StudentMarkWhereUniqueInput
  }

  /**
   * StudentMark deleteMany
   */
  export type StudentMarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentMarks to delete
     */
    where?: StudentMarkWhereInput
    /**
     * Limit how many StudentMarks to delete.
     */
    limit?: number
  }

  /**
   * StudentMark without action
   */
  export type StudentMarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMark
     */
    select?: StudentMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMark
     */
    omit?: StudentMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMarkInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CollegeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    logoUrl: 'logoUrl'
  };

  export type CollegeScalarFieldEnum = (typeof CollegeScalarFieldEnum)[keyof typeof CollegeScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    college_id: 'college_id',
    name: 'name',
    code: 'code'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    phone: 'phone',
    photoUrl: 'photoUrl',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserRoleAssignmentScalarFieldEnum: {
    userId: 'userId',
    role: 'role'
  };

  export type UserRoleAssignmentScalarFieldEnum = (typeof UserRoleAssignmentScalarFieldEnum)[keyof typeof UserRoleAssignmentScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    college_id: 'college_id',
    department_id: 'department_id',
    section_id: 'section_id',
    usn: 'usn',
    semester: 'semester',
    batchYear: 'batchYear'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    college_id: 'college_id',
    departmentId: 'departmentId'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    college_id: 'college_id',
    code: 'code',
    name: 'name',
    departmentId: 'departmentId',
    type: 'type',
    hasTheoryComponent: 'hasTheoryComponent',
    hasLabComponent: 'hasLabComponent'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const DepartmentElectiveGroupScalarFieldEnum: {
    id: 'id',
    college_id: 'college_id',
    name: 'name',
    departmentId: 'departmentId',
    semester: 'semester',
    batchYear: 'batchYear'
  };

  export type DepartmentElectiveGroupScalarFieldEnum = (typeof DepartmentElectiveGroupScalarFieldEnum)[keyof typeof DepartmentElectiveGroupScalarFieldEnum]


  export const CourseElectiveGroupMemberScalarFieldEnum: {
    groupId: 'groupId',
    courseId: 'courseId'
  };

  export type CourseElectiveGroupMemberScalarFieldEnum = (typeof CourseElectiveGroupMemberScalarFieldEnum)[keyof typeof CourseElectiveGroupMemberScalarFieldEnum]


  export const OpenElectiveRestrictionScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    restrictedDepartmentId: 'restrictedDepartmentId'
  };

  export type OpenElectiveRestrictionScalarFieldEnum = (typeof OpenElectiveRestrictionScalarFieldEnum)[keyof typeof OpenElectiveRestrictionScalarFieldEnum]


  export const CourseOfferingScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    teacherId: 'teacherId',
    section_id: 'section_id',
    year_id: 'year_id',
    semester: 'semester'
  };

  export type CourseOfferingScalarFieldEnum = (typeof CourseOfferingScalarFieldEnum)[keyof typeof CourseOfferingScalarFieldEnum]


  export const StudentEnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    offeringId: 'offeringId',
    attemptNumber: 'attemptNumber',
    year_id: 'year_id'
  };

  export type StudentEnrollmentScalarFieldEnum = (typeof StudentEnrollmentScalarFieldEnum)[keyof typeof StudentEnrollmentScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    offeringId: 'offeringId',
    teacherId: 'teacherId',
    classDate: 'classDate',
    periodNumber: 'periodNumber',
    syllabusCovered: 'syllabusCovered',
    status: 'status'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const AttendanceRecordScalarFieldEnum: {
    id: 'id',
    attendanceId: 'attendanceId',
    studentId: 'studentId',
    status: 'status'
  };

  export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ReportViewerScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type ReportViewerScalarFieldEnum = (typeof ReportViewerScalarFieldEnum)[keyof typeof ReportViewerScalarFieldEnum]


  export const Academic_yearsScalarFieldEnum: {
    year_id: 'year_id',
    college_id: 'college_id',
    year_name: 'year_name',
    start_date: 'start_date',
    end_date: 'end_date',
    is_active: 'is_active'
  };

  export type Academic_yearsScalarFieldEnum = (typeof Academic_yearsScalarFieldEnum)[keyof typeof Academic_yearsScalarFieldEnum]


  export const SectionsScalarFieldEnum: {
    section_id: 'section_id',
    department_id: 'department_id',
    section_name: 'section_name'
  };

  export type SectionsScalarFieldEnum = (typeof SectionsScalarFieldEnum)[keyof typeof SectionsScalarFieldEnum]


  export const TestComponentScalarFieldEnum: {
    id: 'id',
    courseOfferingId: 'courseOfferingId',
    name: 'name',
    maxMarks: 'maxMarks',
    weightage: 'weightage'
  };

  export type TestComponentScalarFieldEnum = (typeof TestComponentScalarFieldEnum)[keyof typeof TestComponentScalarFieldEnum]


  export const StudentMarkScalarFieldEnum: {
    id: 'id',
    enrollmentId: 'enrollmentId',
    testComponentId: 'testComponentId',
    marksObtained: 'marksObtained'
  };

  export type StudentMarkScalarFieldEnum = (typeof StudentMarkScalarFieldEnum)[keyof typeof StudentMarkScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'user_role'
   */
  export type Enumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role'>
    


  /**
   * Reference to a field of type 'user_role[]'
   */
  export type ListEnumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'course_type'
   */
  export type Enumcourse_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'course_type'>
    


  /**
   * Reference to a field of type 'course_type[]'
   */
  export type ListEnumcourse_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'course_type[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'attendance_status'
   */
  export type Enumattendance_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'attendance_status'>
    


  /**
   * Reference to a field of type 'attendance_status[]'
   */
  export type ListEnumattendance_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'attendance_status[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CollegeWhereInput = {
    AND?: CollegeWhereInput | CollegeWhereInput[]
    OR?: CollegeWhereInput[]
    NOT?: CollegeWhereInput | CollegeWhereInput[]
    id?: UuidFilter<"College"> | string
    name?: StringFilter<"College"> | string
    code?: StringFilter<"College"> | string
    logoUrl?: StringNullableFilter<"College"> | string | null
    academic_years?: Academic_yearsListRelationFilter
    courses?: CourseListRelationFilter
    department_elective_groups?: DepartmentElectiveGroupListRelationFilter
    departments?: DepartmentListRelationFilter
    students?: StudentListRelationFilter
    teachers?: TeacherListRelationFilter
  }

  export type CollegeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    academic_years?: academic_yearsOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    department_elective_groups?: DepartmentElectiveGroupOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    teachers?: TeacherOrderByRelationAggregateInput
  }

  export type CollegeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: CollegeWhereInput | CollegeWhereInput[]
    OR?: CollegeWhereInput[]
    NOT?: CollegeWhereInput | CollegeWhereInput[]
    logoUrl?: StringNullableFilter<"College"> | string | null
    academic_years?: Academic_yearsListRelationFilter
    courses?: CourseListRelationFilter
    department_elective_groups?: DepartmentElectiveGroupListRelationFilter
    departments?: DepartmentListRelationFilter
    students?: StudentListRelationFilter
    teachers?: TeacherListRelationFilter
  }, "id" | "name" | "code">

  export type CollegeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    _count?: CollegeCountOrderByAggregateInput
    _max?: CollegeMaxOrderByAggregateInput
    _min?: CollegeMinOrderByAggregateInput
  }

  export type CollegeScalarWhereWithAggregatesInput = {
    AND?: CollegeScalarWhereWithAggregatesInput | CollegeScalarWhereWithAggregatesInput[]
    OR?: CollegeScalarWhereWithAggregatesInput[]
    NOT?: CollegeScalarWhereWithAggregatesInput | CollegeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"College"> | string
    name?: StringWithAggregatesFilter<"College"> | string
    code?: StringWithAggregatesFilter<"College"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"College"> | string | null
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: UuidFilter<"Department"> | string
    college_id?: UuidFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    courses?: CourseListRelationFilter
    departmentElectiveGroups?: DepartmentElectiveGroupListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    openElectiveRestrictions?: OpenElectiveRestrictionListRelationFilter
    sections?: SectionsListRelationFilter
    students?: StudentListRelationFilter
    teachers?: TeacherListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    courses?: CourseOrderByRelationAggregateInput
    departmentElectiveGroups?: DepartmentElectiveGroupOrderByRelationAggregateInput
    colleges?: CollegeOrderByWithRelationInput
    openElectiveRestrictions?: OpenElectiveRestrictionOrderByRelationAggregateInput
    sections?: sectionsOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    teachers?: TeacherOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    college_id_code?: DepartmentCollege_idCodeCompoundUniqueInput
    college_id_name?: DepartmentCollege_idNameCompoundUniqueInput
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    college_id?: UuidFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    courses?: CourseListRelationFilter
    departmentElectiveGroups?: DepartmentElectiveGroupListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    openElectiveRestrictions?: OpenElectiveRestrictionListRelationFilter
    sections?: SectionsListRelationFilter
    students?: StudentListRelationFilter
    teachers?: TeacherListRelationFilter
  }, "id" | "college_id_code" | "college_id_name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Department"> | string
    college_id?: UuidWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    code?: StringNullableWithAggregatesFilter<"Department"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    reportViewer?: XOR<ReportViewerNullableScalarRelationFilter, ReportViewerWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    userRoles?: UserRoleAssignmentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    reportViewer?: ReportViewerOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    userRoles?: UserRoleAssignmentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    reportViewer?: XOR<ReportViewerNullableScalarRelationFilter, ReportViewerWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    userRoles?: UserRoleAssignmentListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserRoleAssignmentWhereInput = {
    AND?: UserRoleAssignmentWhereInput | UserRoleAssignmentWhereInput[]
    OR?: UserRoleAssignmentWhereInput[]
    NOT?: UserRoleAssignmentWhereInput | UserRoleAssignmentWhereInput[]
    userId?: UuidFilter<"UserRoleAssignment"> | string
    role?: Enumuser_roleFilter<"UserRoleAssignment"> | $Enums.user_role
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserRoleAssignmentOrderByWithRelationInput = {
    userId?: SortOrder
    role?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserRoleAssignmentWhereUniqueInput = Prisma.AtLeast<{
    userId_role?: UserRoleAssignmentUserIdRoleCompoundUniqueInput
    AND?: UserRoleAssignmentWhereInput | UserRoleAssignmentWhereInput[]
    OR?: UserRoleAssignmentWhereInput[]
    NOT?: UserRoleAssignmentWhereInput | UserRoleAssignmentWhereInput[]
    userId?: UuidFilter<"UserRoleAssignment"> | string
    role?: Enumuser_roleFilter<"UserRoleAssignment"> | $Enums.user_role
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_role">

  export type UserRoleAssignmentOrderByWithAggregationInput = {
    userId?: SortOrder
    role?: SortOrder
    _count?: UserRoleAssignmentCountOrderByAggregateInput
    _max?: UserRoleAssignmentMaxOrderByAggregateInput
    _min?: UserRoleAssignmentMinOrderByAggregateInput
  }

  export type UserRoleAssignmentScalarWhereWithAggregatesInput = {
    AND?: UserRoleAssignmentScalarWhereWithAggregatesInput | UserRoleAssignmentScalarWhereWithAggregatesInput[]
    OR?: UserRoleAssignmentScalarWhereWithAggregatesInput[]
    NOT?: UserRoleAssignmentScalarWhereWithAggregatesInput | UserRoleAssignmentScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserRoleAssignment"> | string
    role?: Enumuser_roleWithAggregatesFilter<"UserRoleAssignment"> | $Enums.user_role
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: UuidFilter<"Student"> | string
    userId?: UuidFilter<"Student"> | string
    college_id?: UuidFilter<"Student"> | string
    department_id?: UuidNullableFilter<"Student"> | string | null
    section_id?: UuidNullableFilter<"Student"> | string | null
    usn?: StringFilter<"Student"> | string
    semester?: IntNullableFilter<"Student"> | number | null
    batchYear?: IntFilter<"Student"> | number
    attendanceRecords?: AttendanceRecordListRelationFilter
    enrollments?: StudentEnrollmentListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    departments?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    sections?: XOR<SectionsNullableScalarRelationFilter, sectionsWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    department_id?: SortOrderInput | SortOrder
    section_id?: SortOrderInput | SortOrder
    usn?: SortOrder
    semester?: SortOrderInput | SortOrder
    batchYear?: SortOrder
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
    enrollments?: StudentEnrollmentOrderByRelationAggregateInput
    colleges?: CollegeOrderByWithRelationInput
    departments?: DepartmentOrderByWithRelationInput
    sections?: sectionsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    usn?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    college_id?: UuidFilter<"Student"> | string
    department_id?: UuidNullableFilter<"Student"> | string | null
    section_id?: UuidNullableFilter<"Student"> | string | null
    semester?: IntNullableFilter<"Student"> | number | null
    batchYear?: IntFilter<"Student"> | number
    attendanceRecords?: AttendanceRecordListRelationFilter
    enrollments?: StudentEnrollmentListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    departments?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    sections?: XOR<SectionsNullableScalarRelationFilter, sectionsWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "usn">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    department_id?: SortOrderInput | SortOrder
    section_id?: SortOrderInput | SortOrder
    usn?: SortOrder
    semester?: SortOrderInput | SortOrder
    batchYear?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Student"> | string
    userId?: UuidWithAggregatesFilter<"Student"> | string
    college_id?: UuidWithAggregatesFilter<"Student"> | string
    department_id?: UuidNullableWithAggregatesFilter<"Student"> | string | null
    section_id?: UuidNullableWithAggregatesFilter<"Student"> | string | null
    usn?: StringWithAggregatesFilter<"Student"> | string
    semester?: IntNullableWithAggregatesFilter<"Student"> | number | null
    batchYear?: IntWithAggregatesFilter<"Student"> | number
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: UuidFilter<"Teacher"> | string
    userId?: UuidFilter<"Teacher"> | string
    college_id?: UuidFilter<"Teacher"> | string
    departmentId?: UuidNullableFilter<"Teacher"> | string | null
    attendances?: AttendanceListRelationFilter
    courseOfferings?: CourseOfferingListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    attendances?: AttendanceOrderByRelationAggregateInput
    courseOfferings?: CourseOfferingOrderByRelationAggregateInput
    colleges?: CollegeOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    college_id?: UuidFilter<"Teacher"> | string
    departmentId?: UuidNullableFilter<"Teacher"> | string | null
    attendances?: AttendanceListRelationFilter
    courseOfferings?: CourseOfferingListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Teacher"> | string
    userId?: UuidWithAggregatesFilter<"Teacher"> | string
    college_id?: UuidWithAggregatesFilter<"Teacher"> | string
    departmentId?: UuidNullableWithAggregatesFilter<"Teacher"> | string | null
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: UuidFilter<"Course"> | string
    college_id?: UuidFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    departmentId?: UuidNullableFilter<"Course"> | string | null
    type?: Enumcourse_typeNullableFilter<"Course"> | $Enums.course_type | null
    hasTheoryComponent?: BoolFilter<"Course"> | boolean
    hasLabComponent?: BoolFilter<"Course"> | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberListRelationFilter
    courseOfferings?: CourseOfferingListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    openElectiveRestrictions?: OpenElectiveRestrictionListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    college_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    hasTheoryComponent?: SortOrder
    hasLabComponent?: SortOrder
    courseElectiveGroupMembers?: CourseElectiveGroupMemberOrderByRelationAggregateInput
    courseOfferings?: CourseOfferingOrderByRelationAggregateInput
    colleges?: CollegeOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    openElectiveRestrictions?: OpenElectiveRestrictionOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    college_id_code?: CourseCollege_idCodeCompoundUniqueInput
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    college_id?: UuidFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    departmentId?: UuidNullableFilter<"Course"> | string | null
    type?: Enumcourse_typeNullableFilter<"Course"> | $Enums.course_type | null
    hasTheoryComponent?: BoolFilter<"Course"> | boolean
    hasLabComponent?: BoolFilter<"Course"> | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberListRelationFilter
    courseOfferings?: CourseOfferingListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    openElectiveRestrictions?: OpenElectiveRestrictionListRelationFilter
  }, "id" | "college_id_code">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    college_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    hasTheoryComponent?: SortOrder
    hasLabComponent?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Course"> | string
    college_id?: UuidWithAggregatesFilter<"Course"> | string
    code?: StringWithAggregatesFilter<"Course"> | string
    name?: StringWithAggregatesFilter<"Course"> | string
    departmentId?: UuidNullableWithAggregatesFilter<"Course"> | string | null
    type?: Enumcourse_typeNullableWithAggregatesFilter<"Course"> | $Enums.course_type | null
    hasTheoryComponent?: BoolWithAggregatesFilter<"Course"> | boolean
    hasLabComponent?: BoolWithAggregatesFilter<"Course"> | boolean
  }

  export type DepartmentElectiveGroupWhereInput = {
    AND?: DepartmentElectiveGroupWhereInput | DepartmentElectiveGroupWhereInput[]
    OR?: DepartmentElectiveGroupWhereInput[]
    NOT?: DepartmentElectiveGroupWhereInput | DepartmentElectiveGroupWhereInput[]
    id?: UuidFilter<"DepartmentElectiveGroup"> | string
    college_id?: UuidFilter<"DepartmentElectiveGroup"> | string
    name?: StringFilter<"DepartmentElectiveGroup"> | string
    departmentId?: UuidFilter<"DepartmentElectiveGroup"> | string
    semester?: IntFilter<"DepartmentElectiveGroup"> | number
    batchYear?: IntFilter<"DepartmentElectiveGroup"> | number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }

  export type DepartmentElectiveGroupOrderByWithRelationInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    semester?: SortOrder
    batchYear?: SortOrder
    courseElectiveGroupMembers?: CourseElectiveGroupMemberOrderByRelationAggregateInput
    colleges?: CollegeOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
  }

  export type DepartmentElectiveGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    college_id_name_departmentId_semester_batchYear?: DepartmentElectiveGroupCollege_idNameDepartmentIdSemesterBatchYearCompoundUniqueInput
    AND?: DepartmentElectiveGroupWhereInput | DepartmentElectiveGroupWhereInput[]
    OR?: DepartmentElectiveGroupWhereInput[]
    NOT?: DepartmentElectiveGroupWhereInput | DepartmentElectiveGroupWhereInput[]
    college_id?: UuidFilter<"DepartmentElectiveGroup"> | string
    name?: StringFilter<"DepartmentElectiveGroup"> | string
    departmentId?: UuidFilter<"DepartmentElectiveGroup"> | string
    semester?: IntFilter<"DepartmentElectiveGroup"> | number
    batchYear?: IntFilter<"DepartmentElectiveGroup"> | number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberListRelationFilter
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }, "id" | "college_id_name_departmentId_semester_batchYear">

  export type DepartmentElectiveGroupOrderByWithAggregationInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    semester?: SortOrder
    batchYear?: SortOrder
    _count?: DepartmentElectiveGroupCountOrderByAggregateInput
    _avg?: DepartmentElectiveGroupAvgOrderByAggregateInput
    _max?: DepartmentElectiveGroupMaxOrderByAggregateInput
    _min?: DepartmentElectiveGroupMinOrderByAggregateInput
    _sum?: DepartmentElectiveGroupSumOrderByAggregateInput
  }

  export type DepartmentElectiveGroupScalarWhereWithAggregatesInput = {
    AND?: DepartmentElectiveGroupScalarWhereWithAggregatesInput | DepartmentElectiveGroupScalarWhereWithAggregatesInput[]
    OR?: DepartmentElectiveGroupScalarWhereWithAggregatesInput[]
    NOT?: DepartmentElectiveGroupScalarWhereWithAggregatesInput | DepartmentElectiveGroupScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DepartmentElectiveGroup"> | string
    college_id?: UuidWithAggregatesFilter<"DepartmentElectiveGroup"> | string
    name?: StringWithAggregatesFilter<"DepartmentElectiveGroup"> | string
    departmentId?: UuidWithAggregatesFilter<"DepartmentElectiveGroup"> | string
    semester?: IntWithAggregatesFilter<"DepartmentElectiveGroup"> | number
    batchYear?: IntWithAggregatesFilter<"DepartmentElectiveGroup"> | number
  }

  export type CourseElectiveGroupMemberWhereInput = {
    AND?: CourseElectiveGroupMemberWhereInput | CourseElectiveGroupMemberWhereInput[]
    OR?: CourseElectiveGroupMemberWhereInput[]
    NOT?: CourseElectiveGroupMemberWhereInput | CourseElectiveGroupMemberWhereInput[]
    groupId?: UuidFilter<"CourseElectiveGroupMember"> | string
    courseId?: UuidFilter<"CourseElectiveGroupMember"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    group?: XOR<DepartmentElectiveGroupScalarRelationFilter, DepartmentElectiveGroupWhereInput>
  }

  export type CourseElectiveGroupMemberOrderByWithRelationInput = {
    groupId?: SortOrder
    courseId?: SortOrder
    course?: CourseOrderByWithRelationInput
    group?: DepartmentElectiveGroupOrderByWithRelationInput
  }

  export type CourseElectiveGroupMemberWhereUniqueInput = Prisma.AtLeast<{
    groupId_courseId?: CourseElectiveGroupMemberGroupIdCourseIdCompoundUniqueInput
    AND?: CourseElectiveGroupMemberWhereInput | CourseElectiveGroupMemberWhereInput[]
    OR?: CourseElectiveGroupMemberWhereInput[]
    NOT?: CourseElectiveGroupMemberWhereInput | CourseElectiveGroupMemberWhereInput[]
    groupId?: UuidFilter<"CourseElectiveGroupMember"> | string
    courseId?: UuidFilter<"CourseElectiveGroupMember"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    group?: XOR<DepartmentElectiveGroupScalarRelationFilter, DepartmentElectiveGroupWhereInput>
  }, "groupId_courseId">

  export type CourseElectiveGroupMemberOrderByWithAggregationInput = {
    groupId?: SortOrder
    courseId?: SortOrder
    _count?: CourseElectiveGroupMemberCountOrderByAggregateInput
    _max?: CourseElectiveGroupMemberMaxOrderByAggregateInput
    _min?: CourseElectiveGroupMemberMinOrderByAggregateInput
  }

  export type CourseElectiveGroupMemberScalarWhereWithAggregatesInput = {
    AND?: CourseElectiveGroupMemberScalarWhereWithAggregatesInput | CourseElectiveGroupMemberScalarWhereWithAggregatesInput[]
    OR?: CourseElectiveGroupMemberScalarWhereWithAggregatesInput[]
    NOT?: CourseElectiveGroupMemberScalarWhereWithAggregatesInput | CourseElectiveGroupMemberScalarWhereWithAggregatesInput[]
    groupId?: UuidWithAggregatesFilter<"CourseElectiveGroupMember"> | string
    courseId?: UuidWithAggregatesFilter<"CourseElectiveGroupMember"> | string
  }

  export type OpenElectiveRestrictionWhereInput = {
    AND?: OpenElectiveRestrictionWhereInput | OpenElectiveRestrictionWhereInput[]
    OR?: OpenElectiveRestrictionWhereInput[]
    NOT?: OpenElectiveRestrictionWhereInput | OpenElectiveRestrictionWhereInput[]
    id?: UuidFilter<"OpenElectiveRestriction"> | string
    courseId?: UuidNullableFilter<"OpenElectiveRestriction"> | string | null
    restrictedDepartmentId?: UuidFilter<"OpenElectiveRestriction"> | string
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    restrictedDepartment?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }

  export type OpenElectiveRestrictionOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrderInput | SortOrder
    restrictedDepartmentId?: SortOrder
    course?: CourseOrderByWithRelationInput
    restrictedDepartment?: DepartmentOrderByWithRelationInput
  }

  export type OpenElectiveRestrictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_restrictedDepartmentId?: OpenElectiveRestrictionCourseIdRestrictedDepartmentIdCompoundUniqueInput
    AND?: OpenElectiveRestrictionWhereInput | OpenElectiveRestrictionWhereInput[]
    OR?: OpenElectiveRestrictionWhereInput[]
    NOT?: OpenElectiveRestrictionWhereInput | OpenElectiveRestrictionWhereInput[]
    courseId?: UuidNullableFilter<"OpenElectiveRestriction"> | string | null
    restrictedDepartmentId?: UuidFilter<"OpenElectiveRestriction"> | string
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    restrictedDepartment?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }, "id" | "courseId_restrictedDepartmentId">

  export type OpenElectiveRestrictionOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrderInput | SortOrder
    restrictedDepartmentId?: SortOrder
    _count?: OpenElectiveRestrictionCountOrderByAggregateInput
    _max?: OpenElectiveRestrictionMaxOrderByAggregateInput
    _min?: OpenElectiveRestrictionMinOrderByAggregateInput
  }

  export type OpenElectiveRestrictionScalarWhereWithAggregatesInput = {
    AND?: OpenElectiveRestrictionScalarWhereWithAggregatesInput | OpenElectiveRestrictionScalarWhereWithAggregatesInput[]
    OR?: OpenElectiveRestrictionScalarWhereWithAggregatesInput[]
    NOT?: OpenElectiveRestrictionScalarWhereWithAggregatesInput | OpenElectiveRestrictionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OpenElectiveRestriction"> | string
    courseId?: UuidNullableWithAggregatesFilter<"OpenElectiveRestriction"> | string | null
    restrictedDepartmentId?: UuidWithAggregatesFilter<"OpenElectiveRestriction"> | string
  }

  export type CourseOfferingWhereInput = {
    AND?: CourseOfferingWhereInput | CourseOfferingWhereInput[]
    OR?: CourseOfferingWhereInput[]
    NOT?: CourseOfferingWhereInput | CourseOfferingWhereInput[]
    id?: UuidFilter<"CourseOffering"> | string
    courseId?: UuidFilter<"CourseOffering"> | string
    teacherId?: UuidNullableFilter<"CourseOffering"> | string | null
    section_id?: UuidNullableFilter<"CourseOffering"> | string | null
    year_id?: UuidNullableFilter<"CourseOffering"> | string | null
    semester?: IntNullableFilter<"CourseOffering"> | number | null
    attendances?: AttendanceListRelationFilter
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    sections?: XOR<SectionsNullableScalarRelationFilter, sectionsWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    academic_years?: XOR<Academic_yearsNullableScalarRelationFilter, academic_yearsWhereInput> | null
    enrollments?: StudentEnrollmentListRelationFilter
    testComponents?: TestComponentListRelationFilter
  }

  export type CourseOfferingOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    section_id?: SortOrderInput | SortOrder
    year_id?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    attendances?: AttendanceOrderByRelationAggregateInput
    course?: CourseOrderByWithRelationInput
    sections?: sectionsOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    academic_years?: academic_yearsOrderByWithRelationInput
    enrollments?: StudentEnrollmentOrderByRelationAggregateInput
    testComponents?: TestComponentOrderByRelationAggregateInput
  }

  export type CourseOfferingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseOfferingWhereInput | CourseOfferingWhereInput[]
    OR?: CourseOfferingWhereInput[]
    NOT?: CourseOfferingWhereInput | CourseOfferingWhereInput[]
    courseId?: UuidFilter<"CourseOffering"> | string
    teacherId?: UuidNullableFilter<"CourseOffering"> | string | null
    section_id?: UuidNullableFilter<"CourseOffering"> | string | null
    year_id?: UuidNullableFilter<"CourseOffering"> | string | null
    semester?: IntNullableFilter<"CourseOffering"> | number | null
    attendances?: AttendanceListRelationFilter
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    sections?: XOR<SectionsNullableScalarRelationFilter, sectionsWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    academic_years?: XOR<Academic_yearsNullableScalarRelationFilter, academic_yearsWhereInput> | null
    enrollments?: StudentEnrollmentListRelationFilter
    testComponents?: TestComponentListRelationFilter
  }, "id">

  export type CourseOfferingOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    section_id?: SortOrderInput | SortOrder
    year_id?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    _count?: CourseOfferingCountOrderByAggregateInput
    _avg?: CourseOfferingAvgOrderByAggregateInput
    _max?: CourseOfferingMaxOrderByAggregateInput
    _min?: CourseOfferingMinOrderByAggregateInput
    _sum?: CourseOfferingSumOrderByAggregateInput
  }

  export type CourseOfferingScalarWhereWithAggregatesInput = {
    AND?: CourseOfferingScalarWhereWithAggregatesInput | CourseOfferingScalarWhereWithAggregatesInput[]
    OR?: CourseOfferingScalarWhereWithAggregatesInput[]
    NOT?: CourseOfferingScalarWhereWithAggregatesInput | CourseOfferingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CourseOffering"> | string
    courseId?: UuidWithAggregatesFilter<"CourseOffering"> | string
    teacherId?: UuidNullableWithAggregatesFilter<"CourseOffering"> | string | null
    section_id?: UuidNullableWithAggregatesFilter<"CourseOffering"> | string | null
    year_id?: UuidNullableWithAggregatesFilter<"CourseOffering"> | string | null
    semester?: IntNullableWithAggregatesFilter<"CourseOffering"> | number | null
  }

  export type StudentEnrollmentWhereInput = {
    AND?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    OR?: StudentEnrollmentWhereInput[]
    NOT?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    id?: UuidFilter<"StudentEnrollment"> | string
    studentId?: UuidNullableFilter<"StudentEnrollment"> | string | null
    offeringId?: UuidNullableFilter<"StudentEnrollment"> | string | null
    attemptNumber?: IntNullableFilter<"StudentEnrollment"> | number | null
    year_id?: UuidNullableFilter<"StudentEnrollment"> | string | null
    offering?: XOR<CourseOfferingNullableScalarRelationFilter, CourseOfferingWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    academic_years?: XOR<Academic_yearsNullableScalarRelationFilter, academic_yearsWhereInput> | null
    studentMarks?: StudentMarkListRelationFilter
  }

  export type StudentEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    offeringId?: SortOrderInput | SortOrder
    attemptNumber?: SortOrderInput | SortOrder
    year_id?: SortOrderInput | SortOrder
    offering?: CourseOfferingOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    academic_years?: academic_yearsOrderByWithRelationInput
    studentMarks?: StudentMarkOrderByRelationAggregateInput
  }

  export type StudentEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    OR?: StudentEnrollmentWhereInput[]
    NOT?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    studentId?: UuidNullableFilter<"StudentEnrollment"> | string | null
    offeringId?: UuidNullableFilter<"StudentEnrollment"> | string | null
    attemptNumber?: IntNullableFilter<"StudentEnrollment"> | number | null
    year_id?: UuidNullableFilter<"StudentEnrollment"> | string | null
    offering?: XOR<CourseOfferingNullableScalarRelationFilter, CourseOfferingWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    academic_years?: XOR<Academic_yearsNullableScalarRelationFilter, academic_yearsWhereInput> | null
    studentMarks?: StudentMarkListRelationFilter
  }, "id">

  export type StudentEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    offeringId?: SortOrderInput | SortOrder
    attemptNumber?: SortOrderInput | SortOrder
    year_id?: SortOrderInput | SortOrder
    _count?: StudentEnrollmentCountOrderByAggregateInput
    _avg?: StudentEnrollmentAvgOrderByAggregateInput
    _max?: StudentEnrollmentMaxOrderByAggregateInput
    _min?: StudentEnrollmentMinOrderByAggregateInput
    _sum?: StudentEnrollmentSumOrderByAggregateInput
  }

  export type StudentEnrollmentScalarWhereWithAggregatesInput = {
    AND?: StudentEnrollmentScalarWhereWithAggregatesInput | StudentEnrollmentScalarWhereWithAggregatesInput[]
    OR?: StudentEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: StudentEnrollmentScalarWhereWithAggregatesInput | StudentEnrollmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StudentEnrollment"> | string
    studentId?: UuidNullableWithAggregatesFilter<"StudentEnrollment"> | string | null
    offeringId?: UuidNullableWithAggregatesFilter<"StudentEnrollment"> | string | null
    attemptNumber?: IntNullableWithAggregatesFilter<"StudentEnrollment"> | number | null
    year_id?: UuidNullableWithAggregatesFilter<"StudentEnrollment"> | string | null
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: UuidFilter<"Attendance"> | string
    offeringId?: UuidNullableFilter<"Attendance"> | string | null
    teacherId?: UuidNullableFilter<"Attendance"> | string | null
    classDate?: DateTimeFilter<"Attendance"> | Date | string
    periodNumber?: IntNullableFilter<"Attendance"> | number | null
    syllabusCovered?: StringNullableFilter<"Attendance"> | string | null
    status?: StringNullableFilter<"Attendance"> | string | null
    offering?: XOR<CourseOfferingNullableScalarRelationFilter, CourseOfferingWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    attendanceRecords?: AttendanceRecordListRelationFilter
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    offeringId?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    classDate?: SortOrder
    periodNumber?: SortOrderInput | SortOrder
    syllabusCovered?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    offering?: CourseOfferingOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    offeringId?: UuidNullableFilter<"Attendance"> | string | null
    teacherId?: UuidNullableFilter<"Attendance"> | string | null
    classDate?: DateTimeFilter<"Attendance"> | Date | string
    periodNumber?: IntNullableFilter<"Attendance"> | number | null
    syllabusCovered?: StringNullableFilter<"Attendance"> | string | null
    status?: StringNullableFilter<"Attendance"> | string | null
    offering?: XOR<CourseOfferingNullableScalarRelationFilter, CourseOfferingWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    attendanceRecords?: AttendanceRecordListRelationFilter
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    offeringId?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    classDate?: SortOrder
    periodNumber?: SortOrderInput | SortOrder
    syllabusCovered?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Attendance"> | string
    offeringId?: UuidNullableWithAggregatesFilter<"Attendance"> | string | null
    teacherId?: UuidNullableWithAggregatesFilter<"Attendance"> | string | null
    classDate?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    periodNumber?: IntNullableWithAggregatesFilter<"Attendance"> | number | null
    syllabusCovered?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    status?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
  }

  export type AttendanceRecordWhereInput = {
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    id?: UuidFilter<"AttendanceRecord"> | string
    attendanceId?: UuidNullableFilter<"AttendanceRecord"> | string | null
    studentId?: UuidNullableFilter<"AttendanceRecord"> | string | null
    status?: Enumattendance_statusNullableFilter<"AttendanceRecord"> | $Enums.attendance_status | null
    attendance?: XOR<AttendanceNullableScalarRelationFilter, AttendanceWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }

  export type AttendanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    attendanceId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    attendance?: AttendanceOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type AttendanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    attendanceId?: UuidNullableFilter<"AttendanceRecord"> | string | null
    studentId?: UuidNullableFilter<"AttendanceRecord"> | string | null
    status?: Enumattendance_statusNullableFilter<"AttendanceRecord"> | $Enums.attendance_status | null
    attendance?: XOR<AttendanceNullableScalarRelationFilter, AttendanceWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }, "id">

  export type AttendanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    attendanceId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: AttendanceRecordCountOrderByAggregateInput
    _max?: AttendanceRecordMaxOrderByAggregateInput
    _min?: AttendanceRecordMinOrderByAggregateInput
  }

  export type AttendanceRecordScalarWhereWithAggregatesInput = {
    AND?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    OR?: AttendanceRecordScalarWhereWithAggregatesInput[]
    NOT?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AttendanceRecord"> | string
    attendanceId?: UuidNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
    studentId?: UuidNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
    status?: Enumattendance_statusNullableWithAggregatesFilter<"AttendanceRecord"> | $Enums.attendance_status | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: UuidFilter<"Admin"> | string
    userId?: UuidFilter<"Admin"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Admin"> | string
    userId?: UuidWithAggregatesFilter<"Admin"> | string
  }

  export type ReportViewerWhereInput = {
    AND?: ReportViewerWhereInput | ReportViewerWhereInput[]
    OR?: ReportViewerWhereInput[]
    NOT?: ReportViewerWhereInput | ReportViewerWhereInput[]
    id?: UuidFilter<"ReportViewer"> | string
    userId?: UuidFilter<"ReportViewer"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReportViewerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ReportViewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ReportViewerWhereInput | ReportViewerWhereInput[]
    OR?: ReportViewerWhereInput[]
    NOT?: ReportViewerWhereInput | ReportViewerWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ReportViewerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: ReportViewerCountOrderByAggregateInput
    _max?: ReportViewerMaxOrderByAggregateInput
    _min?: ReportViewerMinOrderByAggregateInput
  }

  export type ReportViewerScalarWhereWithAggregatesInput = {
    AND?: ReportViewerScalarWhereWithAggregatesInput | ReportViewerScalarWhereWithAggregatesInput[]
    OR?: ReportViewerScalarWhereWithAggregatesInput[]
    NOT?: ReportViewerScalarWhereWithAggregatesInput | ReportViewerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ReportViewer"> | string
    userId?: UuidWithAggregatesFilter<"ReportViewer"> | string
  }

  export type academic_yearsWhereInput = {
    AND?: academic_yearsWhereInput | academic_yearsWhereInput[]
    OR?: academic_yearsWhereInput[]
    NOT?: academic_yearsWhereInput | academic_yearsWhereInput[]
    year_id?: UuidFilter<"academic_years"> | string
    college_id?: UuidFilter<"academic_years"> | string
    year_name?: StringFilter<"academic_years"> | string
    start_date?: DateTimeNullableFilter<"academic_years"> | Date | string | null
    end_date?: DateTimeNullableFilter<"academic_years"> | Date | string | null
    is_active?: BoolNullableFilter<"academic_years"> | boolean | null
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    course_offerings?: CourseOfferingListRelationFilter
    student_enrollments?: StudentEnrollmentListRelationFilter
  }

  export type academic_yearsOrderByWithRelationInput = {
    year_id?: SortOrder
    college_id?: SortOrder
    year_name?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    colleges?: CollegeOrderByWithRelationInput
    course_offerings?: CourseOfferingOrderByRelationAggregateInput
    student_enrollments?: StudentEnrollmentOrderByRelationAggregateInput
  }

  export type academic_yearsWhereUniqueInput = Prisma.AtLeast<{
    year_id?: string
    college_id_year_name?: academic_yearsCollege_idYear_nameCompoundUniqueInput
    AND?: academic_yearsWhereInput | academic_yearsWhereInput[]
    OR?: academic_yearsWhereInput[]
    NOT?: academic_yearsWhereInput | academic_yearsWhereInput[]
    college_id?: UuidFilter<"academic_years"> | string
    year_name?: StringFilter<"academic_years"> | string
    start_date?: DateTimeNullableFilter<"academic_years"> | Date | string | null
    end_date?: DateTimeNullableFilter<"academic_years"> | Date | string | null
    is_active?: BoolNullableFilter<"academic_years"> | boolean | null
    colleges?: XOR<CollegeScalarRelationFilter, CollegeWhereInput>
    course_offerings?: CourseOfferingListRelationFilter
    student_enrollments?: StudentEnrollmentListRelationFilter
  }, "year_id" | "college_id_year_name">

  export type academic_yearsOrderByWithAggregationInput = {
    year_id?: SortOrder
    college_id?: SortOrder
    year_name?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: academic_yearsCountOrderByAggregateInput
    _max?: academic_yearsMaxOrderByAggregateInput
    _min?: academic_yearsMinOrderByAggregateInput
  }

  export type academic_yearsScalarWhereWithAggregatesInput = {
    AND?: academic_yearsScalarWhereWithAggregatesInput | academic_yearsScalarWhereWithAggregatesInput[]
    OR?: academic_yearsScalarWhereWithAggregatesInput[]
    NOT?: academic_yearsScalarWhereWithAggregatesInput | academic_yearsScalarWhereWithAggregatesInput[]
    year_id?: UuidWithAggregatesFilter<"academic_years"> | string
    college_id?: UuidWithAggregatesFilter<"academic_years"> | string
    year_name?: StringWithAggregatesFilter<"academic_years"> | string
    start_date?: DateTimeNullableWithAggregatesFilter<"academic_years"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"academic_years"> | Date | string | null
    is_active?: BoolNullableWithAggregatesFilter<"academic_years"> | boolean | null
  }

  export type sectionsWhereInput = {
    AND?: sectionsWhereInput | sectionsWhereInput[]
    OR?: sectionsWhereInput[]
    NOT?: sectionsWhereInput | sectionsWhereInput[]
    section_id?: UuidFilter<"sections"> | string
    department_id?: UuidFilter<"sections"> | string
    section_name?: StringFilter<"sections"> | string
    course_offerings?: CourseOfferingListRelationFilter
    departments?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    students?: StudentListRelationFilter
  }

  export type sectionsOrderByWithRelationInput = {
    section_id?: SortOrder
    department_id?: SortOrder
    section_name?: SortOrder
    course_offerings?: CourseOfferingOrderByRelationAggregateInput
    departments?: DepartmentOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
  }

  export type sectionsWhereUniqueInput = Prisma.AtLeast<{
    section_id?: string
    department_id_section_name?: sectionsDepartment_idSection_nameCompoundUniqueInput
    AND?: sectionsWhereInput | sectionsWhereInput[]
    OR?: sectionsWhereInput[]
    NOT?: sectionsWhereInput | sectionsWhereInput[]
    department_id?: UuidFilter<"sections"> | string
    section_name?: StringFilter<"sections"> | string
    course_offerings?: CourseOfferingListRelationFilter
    departments?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    students?: StudentListRelationFilter
  }, "section_id" | "department_id_section_name">

  export type sectionsOrderByWithAggregationInput = {
    section_id?: SortOrder
    department_id?: SortOrder
    section_name?: SortOrder
    _count?: sectionsCountOrderByAggregateInput
    _max?: sectionsMaxOrderByAggregateInput
    _min?: sectionsMinOrderByAggregateInput
  }

  export type sectionsScalarWhereWithAggregatesInput = {
    AND?: sectionsScalarWhereWithAggregatesInput | sectionsScalarWhereWithAggregatesInput[]
    OR?: sectionsScalarWhereWithAggregatesInput[]
    NOT?: sectionsScalarWhereWithAggregatesInput | sectionsScalarWhereWithAggregatesInput[]
    section_id?: UuidWithAggregatesFilter<"sections"> | string
    department_id?: UuidWithAggregatesFilter<"sections"> | string
    section_name?: StringWithAggregatesFilter<"sections"> | string
  }

  export type TestComponentWhereInput = {
    AND?: TestComponentWhereInput | TestComponentWhereInput[]
    OR?: TestComponentWhereInput[]
    NOT?: TestComponentWhereInput | TestComponentWhereInput[]
    id?: UuidFilter<"TestComponent"> | string
    courseOfferingId?: UuidFilter<"TestComponent"> | string
    name?: StringFilter<"TestComponent"> | string
    maxMarks?: IntFilter<"TestComponent"> | number
    weightage?: IntFilter<"TestComponent"> | number
    courseOffering?: XOR<CourseOfferingScalarRelationFilter, CourseOfferingWhereInput>
    studentMarks?: StudentMarkListRelationFilter
  }

  export type TestComponentOrderByWithRelationInput = {
    id?: SortOrder
    courseOfferingId?: SortOrder
    name?: SortOrder
    maxMarks?: SortOrder
    weightage?: SortOrder
    courseOffering?: CourseOfferingOrderByWithRelationInput
    studentMarks?: StudentMarkOrderByRelationAggregateInput
  }

  export type TestComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestComponentWhereInput | TestComponentWhereInput[]
    OR?: TestComponentWhereInput[]
    NOT?: TestComponentWhereInput | TestComponentWhereInput[]
    courseOfferingId?: UuidFilter<"TestComponent"> | string
    name?: StringFilter<"TestComponent"> | string
    maxMarks?: IntFilter<"TestComponent"> | number
    weightage?: IntFilter<"TestComponent"> | number
    courseOffering?: XOR<CourseOfferingScalarRelationFilter, CourseOfferingWhereInput>
    studentMarks?: StudentMarkListRelationFilter
  }, "id">

  export type TestComponentOrderByWithAggregationInput = {
    id?: SortOrder
    courseOfferingId?: SortOrder
    name?: SortOrder
    maxMarks?: SortOrder
    weightage?: SortOrder
    _count?: TestComponentCountOrderByAggregateInput
    _avg?: TestComponentAvgOrderByAggregateInput
    _max?: TestComponentMaxOrderByAggregateInput
    _min?: TestComponentMinOrderByAggregateInput
    _sum?: TestComponentSumOrderByAggregateInput
  }

  export type TestComponentScalarWhereWithAggregatesInput = {
    AND?: TestComponentScalarWhereWithAggregatesInput | TestComponentScalarWhereWithAggregatesInput[]
    OR?: TestComponentScalarWhereWithAggregatesInput[]
    NOT?: TestComponentScalarWhereWithAggregatesInput | TestComponentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TestComponent"> | string
    courseOfferingId?: UuidWithAggregatesFilter<"TestComponent"> | string
    name?: StringWithAggregatesFilter<"TestComponent"> | string
    maxMarks?: IntWithAggregatesFilter<"TestComponent"> | number
    weightage?: IntWithAggregatesFilter<"TestComponent"> | number
  }

  export type StudentMarkWhereInput = {
    AND?: StudentMarkWhereInput | StudentMarkWhereInput[]
    OR?: StudentMarkWhereInput[]
    NOT?: StudentMarkWhereInput | StudentMarkWhereInput[]
    id?: UuidFilter<"StudentMark"> | string
    enrollmentId?: UuidFilter<"StudentMark"> | string
    testComponentId?: UuidFilter<"StudentMark"> | string
    marksObtained?: IntNullableFilter<"StudentMark"> | number | null
    enrollment?: XOR<StudentEnrollmentScalarRelationFilter, StudentEnrollmentWhereInput>
    testComponent?: XOR<TestComponentScalarRelationFilter, TestComponentWhereInput>
  }

  export type StudentMarkOrderByWithRelationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    testComponentId?: SortOrder
    marksObtained?: SortOrderInput | SortOrder
    enrollment?: StudentEnrollmentOrderByWithRelationInput
    testComponent?: TestComponentOrderByWithRelationInput
  }

  export type StudentMarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    enrollmentId_testComponentId?: StudentMarkEnrollmentIdTestComponentIdCompoundUniqueInput
    AND?: StudentMarkWhereInput | StudentMarkWhereInput[]
    OR?: StudentMarkWhereInput[]
    NOT?: StudentMarkWhereInput | StudentMarkWhereInput[]
    enrollmentId?: UuidFilter<"StudentMark"> | string
    testComponentId?: UuidFilter<"StudentMark"> | string
    marksObtained?: IntNullableFilter<"StudentMark"> | number | null
    enrollment?: XOR<StudentEnrollmentScalarRelationFilter, StudentEnrollmentWhereInput>
    testComponent?: XOR<TestComponentScalarRelationFilter, TestComponentWhereInput>
  }, "id" | "enrollmentId_testComponentId">

  export type StudentMarkOrderByWithAggregationInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    testComponentId?: SortOrder
    marksObtained?: SortOrderInput | SortOrder
    _count?: StudentMarkCountOrderByAggregateInput
    _avg?: StudentMarkAvgOrderByAggregateInput
    _max?: StudentMarkMaxOrderByAggregateInput
    _min?: StudentMarkMinOrderByAggregateInput
    _sum?: StudentMarkSumOrderByAggregateInput
  }

  export type StudentMarkScalarWhereWithAggregatesInput = {
    AND?: StudentMarkScalarWhereWithAggregatesInput | StudentMarkScalarWhereWithAggregatesInput[]
    OR?: StudentMarkScalarWhereWithAggregatesInput[]
    NOT?: StudentMarkScalarWhereWithAggregatesInput | StudentMarkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StudentMark"> | string
    enrollmentId?: UuidWithAggregatesFilter<"StudentMark"> | string
    testComponentId?: UuidWithAggregatesFilter<"StudentMark"> | string
    marksObtained?: IntNullableWithAggregatesFilter<"StudentMark"> | number | null
  }

  export type CollegeCreateInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsCreateNestedManyWithoutCollegesInput
    courses?: CourseCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupCreateNestedManyWithoutCollegesInput
    departments?: DepartmentCreateNestedManyWithoutCollegesInput
    students?: StudentCreateNestedManyWithoutCollegesInput
    teachers?: TeacherCreateNestedManyWithoutCollegesInput
  }

  export type CollegeUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsUncheckedCreateNestedManyWithoutCollegesInput
    courses?: CourseUncheckedCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutCollegesInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCollegesInput
    students?: StudentUncheckedCreateNestedManyWithoutCollegesInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutCollegesInput
  }

  export type CollegeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUpdateManyWithoutCollegesNestedInput
    courses?: CourseUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUpdateManyWithoutCollegesNestedInput
    students?: StudentUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUpdateManyWithoutCollegesNestedInput
  }

  export type CollegeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUncheckedUpdateManyWithoutCollegesNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCollegesNestedInput
    students?: StudentUncheckedUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutCollegesNestedInput
  }

  export type CollegeCreateManyInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
  }

  export type CollegeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollegeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    code?: string | null
    courses?: CourseCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupCreateNestedManyWithoutDepartmentInput
    colleges: CollegeCreateNestedOneWithoutDepartmentsInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsCreateNestedManyWithoutDepartmentsInput
    students?: StudentCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    college_id: string
    name: string
    code?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutDepartmentInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsUncheckedCreateNestedManyWithoutDepartmentsInput
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUpdateManyWithoutDepartmentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutDepartmentsNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUncheckedUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUncheckedUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    college_id: string
    name: string
    code?: string | null
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    reportViewer?: ReportViewerCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    reportViewer?: ReportViewerUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    reportViewer?: ReportViewerUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    reportViewer?: ReportViewerUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoleAssignmentCreateInput = {
    role: $Enums.user_role
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleAssignmentUncheckedCreateInput = {
    userId: string
    role: $Enums.user_role
  }

  export type UserRoleAssignmentUpdateInput = {
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleAssignmentUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
  }

  export type UserRoleAssignmentCreateManyInput = {
    userId: string
    role: $Enums.user_role
  }

  export type UserRoleAssignmentUpdateManyMutationInput = {
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
  }

  export type UserRoleAssignmentUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
  }

  export type StudentCreateInput = {
    id?: string
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    colleges: CollegeCreateNestedOneWithoutStudentsInput
    departments?: DepartmentCreateNestedOneWithoutStudentsInput
    sections?: sectionsCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    college_id: string
    department_id?: string | null
    section_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutStudentsNestedInput
    departments?: DepartmentUpdateOneWithoutStudentsNestedInput
    sections?: sectionsUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    college_id: string
    department_id?: string | null
    section_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherCreateInput = {
    id?: string
    attendances?: AttendanceCreateNestedManyWithoutTeacherInput
    courseOfferings?: CourseOfferingCreateNestedManyWithoutTeacherInput
    colleges: CollegeCreateNestedOneWithoutTeachersInput
    department?: DepartmentCreateNestedOneWithoutTeachersInput
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    userId: string
    college_id: string
    departmentId?: string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTeacherInput
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendances?: AttendanceUpdateManyWithoutTeacherNestedInput
    courseOfferings?: CourseOfferingUpdateManyWithoutTeacherNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutTeachersNestedInput
    department?: DepartmentUpdateOneWithoutTeachersNestedInput
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutTeacherNestedInput
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    userId: string
    college_id: string
    departmentId?: string | null
  }

  export type TeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseCreateInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberCreateNestedManyWithoutCourseInput
    courseOfferings?: CourseOfferingCreateNestedManyWithoutCourseInput
    colleges: CollegeCreateNestedOneWithoutCoursesInput
    department?: DepartmentCreateNestedOneWithoutCoursesInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    college_id: string
    code: string
    name: string
    departmentId?: string | null
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutCourseInput
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUpdateManyWithoutCourseNestedInput
    courseOfferings?: CourseOfferingUpdateManyWithoutCourseNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutCoursesNestedInput
    department?: DepartmentUpdateOneWithoutCoursesNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedUpdateManyWithoutCourseNestedInput
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutCourseNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    college_id: string
    code: string
    name: string
    departmentId?: string | null
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DepartmentElectiveGroupCreateInput = {
    id?: string
    name: string
    semester: number
    batchYear: number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberCreateNestedManyWithoutGroupInput
    colleges: CollegeCreateNestedOneWithoutDepartment_elective_groupsInput
    department: DepartmentCreateNestedOneWithoutDepartmentElectiveGroupsInput
  }

  export type DepartmentElectiveGroupUncheckedCreateInput = {
    id?: string
    college_id: string
    name: string
    departmentId: string
    semester: number
    batchYear: number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type DepartmentElectiveGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUpdateManyWithoutGroupNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutDepartment_elective_groupsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutDepartmentElectiveGroupsNestedInput
  }

  export type DepartmentElectiveGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type DepartmentElectiveGroupCreateManyInput = {
    id?: string
    college_id: string
    name: string
    departmentId: string
    semester: number
    batchYear: number
  }

  export type DepartmentElectiveGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentElectiveGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type CourseElectiveGroupMemberCreateInput = {
    course: CourseCreateNestedOneWithoutCourseElectiveGroupMembersInput
    group: DepartmentElectiveGroupCreateNestedOneWithoutCourseElectiveGroupMembersInput
  }

  export type CourseElectiveGroupMemberUncheckedCreateInput = {
    groupId: string
    courseId: string
  }

  export type CourseElectiveGroupMemberUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutCourseElectiveGroupMembersNestedInput
    group?: DepartmentElectiveGroupUpdateOneRequiredWithoutCourseElectiveGroupMembersNestedInput
  }

  export type CourseElectiveGroupMemberUncheckedUpdateInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseElectiveGroupMemberCreateManyInput = {
    groupId: string
    courseId: string
  }

  export type CourseElectiveGroupMemberUpdateManyMutationInput = {

  }

  export type CourseElectiveGroupMemberUncheckedUpdateManyInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenElectiveRestrictionCreateInput = {
    id?: string
    course?: CourseCreateNestedOneWithoutOpenElectiveRestrictionsInput
    restrictedDepartment: DepartmentCreateNestedOneWithoutOpenElectiveRestrictionsInput
  }

  export type OpenElectiveRestrictionUncheckedCreateInput = {
    id?: string
    courseId?: string | null
    restrictedDepartmentId: string
  }

  export type OpenElectiveRestrictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneWithoutOpenElectiveRestrictionsNestedInput
    restrictedDepartment?: DepartmentUpdateOneRequiredWithoutOpenElectiveRestrictionsNestedInput
  }

  export type OpenElectiveRestrictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    restrictedDepartmentId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenElectiveRestrictionCreateManyInput = {
    id?: string
    courseId?: string | null
    restrictedDepartmentId: string
  }

  export type OpenElectiveRestrictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type OpenElectiveRestrictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    restrictedDepartmentId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseOfferingCreateInput = {
    id?: string
    semester?: number | null
    attendances?: AttendanceCreateNestedManyWithoutOfferingInput
    course: CourseCreateNestedOneWithoutCourseOfferingsInput
    sections?: sectionsCreateNestedOneWithoutCourse_offeringsInput
    teacher?: TeacherCreateNestedOneWithoutCourseOfferingsInput
    academic_years?: academic_yearsCreateNestedOneWithoutCourse_offeringsInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateInput = {
    id?: string
    courseId: string
    teacherId?: string | null
    section_id?: string | null
    year_id?: string | null
    semester?: number | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOfferingInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentUncheckedCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUpdateManyWithoutOfferingNestedInput
    course?: CourseUpdateOneRequiredWithoutCourseOfferingsNestedInput
    sections?: sectionsUpdateOneWithoutCourse_offeringsNestedInput
    teacher?: TeacherUpdateOneWithoutCourseOfferingsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutCourse_offeringsNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUncheckedUpdateManyWithoutOfferingNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUncheckedUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingCreateManyInput = {
    id?: string
    courseId: string
    teacherId?: string | null
    section_id?: string | null
    year_id?: string | null
    semester?: number | null
  }

  export type CourseOfferingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseOfferingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentEnrollmentCreateInput = {
    id?: string
    attemptNumber?: number | null
    offering?: CourseOfferingCreateNestedOneWithoutEnrollmentsInput
    student?: StudentCreateNestedOneWithoutEnrollmentsInput
    academic_years?: academic_yearsCreateNestedOneWithoutStudent_enrollmentsInput
    studentMarks?: StudentMarkCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateInput = {
    id?: string
    studentId?: string | null
    offeringId?: string | null
    attemptNumber?: number | null
    year_id?: string | null
    studentMarks?: StudentMarkUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    offering?: CourseOfferingUpdateOneWithoutEnrollmentsNestedInput
    student?: StudentUpdateOneWithoutEnrollmentsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutStudent_enrollmentsNestedInput
    studentMarks?: StudentMarkUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    studentMarks?: StudentMarkUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentCreateManyInput = {
    id?: string
    studentId?: string | null
    offeringId?: string | null
    attemptNumber?: number | null
    year_id?: string | null
  }

  export type StudentEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceCreateInput = {
    id?: string
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
    offering?: CourseOfferingCreateNestedOneWithoutAttendancesInput
    teacher?: TeacherCreateNestedOneWithoutAttendancesInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    offeringId?: string | null
    teacherId?: string | null
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutAttendanceInput
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    offering?: CourseOfferingUpdateOneWithoutAttendancesNestedInput
    teacher?: TeacherUpdateOneWithoutAttendancesNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutAttendanceNestedInput
  }

  export type AttendanceCreateManyInput = {
    id?: string
    offeringId?: string | null
    teacherId?: string | null
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordCreateInput = {
    id?: string
    status?: $Enums.attendance_status | null
    attendance?: AttendanceCreateNestedOneWithoutAttendanceRecordsInput
    student?: StudentCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateInput = {
    id?: string
    attendanceId?: string | null
    studentId?: string | null
    status?: $Enums.attendance_status | null
  }

  export type AttendanceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    attendance?: AttendanceUpdateOneWithoutAttendanceRecordsNestedInput
    student?: StudentUpdateOneWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
  }

  export type AttendanceRecordCreateManyInput = {
    id?: string
    attendanceId?: string | null
    studentId?: string | null
    status?: $Enums.attendance_status | null
  }

  export type AttendanceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
  }

  export type AttendanceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
  }

  export type AdminCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportViewerCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutReportViewerInput
  }

  export type ReportViewerUncheckedCreateInput = {
    id?: string
    userId: string
  }

  export type ReportViewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutReportViewerNestedInput
  }

  export type ReportViewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportViewerCreateManyInput = {
    id?: string
    userId: string
  }

  export type ReportViewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ReportViewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type academic_yearsCreateInput = {
    year_id?: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    colleges: CollegeCreateNestedOneWithoutAcademic_yearsInput
    course_offerings?: CourseOfferingCreateNestedManyWithoutAcademic_yearsInput
    student_enrollments?: StudentEnrollmentCreateNestedManyWithoutAcademic_yearsInput
  }

  export type academic_yearsUncheckedCreateInput = {
    year_id?: string
    college_id: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    course_offerings?: CourseOfferingUncheckedCreateNestedManyWithoutAcademic_yearsInput
    student_enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutAcademic_yearsInput
  }

  export type academic_yearsUpdateInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colleges?: CollegeUpdateOneRequiredWithoutAcademic_yearsNestedInput
    course_offerings?: CourseOfferingUpdateManyWithoutAcademic_yearsNestedInput
    student_enrollments?: StudentEnrollmentUpdateManyWithoutAcademic_yearsNestedInput
  }

  export type academic_yearsUncheckedUpdateInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    course_offerings?: CourseOfferingUncheckedUpdateManyWithoutAcademic_yearsNestedInput
    student_enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutAcademic_yearsNestedInput
  }

  export type academic_yearsCreateManyInput = {
    year_id?: string
    college_id: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
  }

  export type academic_yearsUpdateManyMutationInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type academic_yearsUncheckedUpdateManyInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type sectionsCreateInput = {
    section_id?: string
    section_name: string
    course_offerings?: CourseOfferingCreateNestedManyWithoutSectionsInput
    departments: DepartmentCreateNestedOneWithoutSectionsInput
    students?: StudentCreateNestedManyWithoutSectionsInput
  }

  export type sectionsUncheckedCreateInput = {
    section_id?: string
    department_id: string
    section_name: string
    course_offerings?: CourseOfferingUncheckedCreateNestedManyWithoutSectionsInput
    students?: StudentUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type sectionsUpdateInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    course_offerings?: CourseOfferingUpdateManyWithoutSectionsNestedInput
    departments?: DepartmentUpdateOneRequiredWithoutSectionsNestedInput
    students?: StudentUpdateManyWithoutSectionsNestedInput
  }

  export type sectionsUncheckedUpdateInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    department_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    course_offerings?: CourseOfferingUncheckedUpdateManyWithoutSectionsNestedInput
    students?: StudentUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type sectionsCreateManyInput = {
    section_id?: string
    department_id: string
    section_name: string
  }

  export type sectionsUpdateManyMutationInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
  }

  export type sectionsUncheckedUpdateManyInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    department_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
  }

  export type TestComponentCreateInput = {
    id?: string
    name: string
    maxMarks: number
    weightage?: number
    courseOffering: CourseOfferingCreateNestedOneWithoutTestComponentsInput
    studentMarks?: StudentMarkCreateNestedManyWithoutTestComponentInput
  }

  export type TestComponentUncheckedCreateInput = {
    id?: string
    courseOfferingId: string
    name: string
    maxMarks: number
    weightage?: number
    studentMarks?: StudentMarkUncheckedCreateNestedManyWithoutTestComponentInput
  }

  export type TestComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    maxMarks?: IntFieldUpdateOperationsInput | number
    weightage?: IntFieldUpdateOperationsInput | number
    courseOffering?: CourseOfferingUpdateOneRequiredWithoutTestComponentsNestedInput
    studentMarks?: StudentMarkUpdateManyWithoutTestComponentNestedInput
  }

  export type TestComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseOfferingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    maxMarks?: IntFieldUpdateOperationsInput | number
    weightage?: IntFieldUpdateOperationsInput | number
    studentMarks?: StudentMarkUncheckedUpdateManyWithoutTestComponentNestedInput
  }

  export type TestComponentCreateManyInput = {
    id?: string
    courseOfferingId: string
    name: string
    maxMarks: number
    weightage?: number
  }

  export type TestComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    maxMarks?: IntFieldUpdateOperationsInput | number
    weightage?: IntFieldUpdateOperationsInput | number
  }

  export type TestComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseOfferingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    maxMarks?: IntFieldUpdateOperationsInput | number
    weightage?: IntFieldUpdateOperationsInput | number
  }

  export type StudentMarkCreateInput = {
    id?: string
    marksObtained?: number | null
    enrollment: StudentEnrollmentCreateNestedOneWithoutStudentMarksInput
    testComponent: TestComponentCreateNestedOneWithoutStudentMarksInput
  }

  export type StudentMarkUncheckedCreateInput = {
    id?: string
    enrollmentId: string
    testComponentId: string
    marksObtained?: number | null
  }

  export type StudentMarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
    enrollment?: StudentEnrollmentUpdateOneRequiredWithoutStudentMarksNestedInput
    testComponent?: TestComponentUpdateOneRequiredWithoutStudentMarksNestedInput
  }

  export type StudentMarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    testComponentId?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentMarkCreateManyInput = {
    id?: string
    enrollmentId: string
    testComponentId: string
    marksObtained?: number | null
  }

  export type StudentMarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentMarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    testComponentId?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Academic_yearsListRelationFilter = {
    every?: academic_yearsWhereInput
    some?: academic_yearsWhereInput
    none?: academic_yearsWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type DepartmentElectiveGroupListRelationFilter = {
    every?: DepartmentElectiveGroupWhereInput
    some?: DepartmentElectiveGroupWhereInput
    none?: DepartmentElectiveGroupWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type TeacherListRelationFilter = {
    every?: TeacherWhereInput
    some?: TeacherWhereInput
    none?: TeacherWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type academic_yearsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentElectiveGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollegeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrder
  }

  export type CollegeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrder
  }

  export type CollegeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CollegeScalarRelationFilter = {
    is?: CollegeWhereInput
    isNot?: CollegeWhereInput
  }

  export type OpenElectiveRestrictionListRelationFilter = {
    every?: OpenElectiveRestrictionWhereInput
    some?: OpenElectiveRestrictionWhereInput
    none?: OpenElectiveRestrictionWhereInput
  }

  export type SectionsListRelationFilter = {
    every?: sectionsWhereInput
    some?: sectionsWhereInput
    none?: sectionsWhereInput
  }

  export type OpenElectiveRestrictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sectionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCollege_idCodeCompoundUniqueInput = {
    college_id: string
    code: string
  }

  export type DepartmentCollege_idNameCompoundUniqueInput = {
    college_id: string
    name: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type ReportViewerNullableScalarRelationFilter = {
    is?: ReportViewerWhereInput | null
    isNot?: ReportViewerWhereInput | null
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type TeacherNullableScalarRelationFilter = {
    is?: TeacherWhereInput | null
    isNot?: TeacherWhereInput | null
  }

  export type UserRoleAssignmentListRelationFilter = {
    every?: UserRoleAssignmentWhereInput
    some?: UserRoleAssignmentWhereInput
    none?: UserRoleAssignmentWhereInput
  }

  export type UserRoleAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRoleAssignmentUserIdRoleCompoundUniqueInput = {
    userId: string
    role: $Enums.user_role
  }

  export type UserRoleAssignmentCountOrderByAggregateInput = {
    userId?: SortOrder
    role?: SortOrder
  }

  export type UserRoleAssignmentMaxOrderByAggregateInput = {
    userId?: SortOrder
    role?: SortOrder
  }

  export type UserRoleAssignmentMinOrderByAggregateInput = {
    userId?: SortOrder
    role?: SortOrder
  }

  export type Enumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AttendanceRecordListRelationFilter = {
    every?: AttendanceRecordWhereInput
    some?: AttendanceRecordWhereInput
    none?: AttendanceRecordWhereInput
  }

  export type StudentEnrollmentListRelationFilter = {
    every?: StudentEnrollmentWhereInput
    some?: StudentEnrollmentWhereInput
    none?: StudentEnrollmentWhereInput
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type SectionsNullableScalarRelationFilter = {
    is?: sectionsWhereInput | null
    isNot?: sectionsWhereInput | null
  }

  export type AttendanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    department_id?: SortOrder
    section_id?: SortOrder
    usn?: SortOrder
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    department_id?: SortOrder
    section_id?: SortOrder
    usn?: SortOrder
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    department_id?: SortOrder
    section_id?: SortOrder
    usn?: SortOrder
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type CourseOfferingListRelationFilter = {
    every?: CourseOfferingWhereInput
    some?: CourseOfferingWhereInput
    none?: CourseOfferingWhereInput
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOfferingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    departmentId?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    departmentId?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    college_id?: SortOrder
    departmentId?: SortOrder
  }

  export type Enumcourse_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.course_type | Enumcourse_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.course_type[] | ListEnumcourse_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.course_type[] | ListEnumcourse_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcourse_typeNullableFilter<$PrismaModel> | $Enums.course_type | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CourseElectiveGroupMemberListRelationFilter = {
    every?: CourseElectiveGroupMemberWhereInput
    some?: CourseElectiveGroupMemberWhereInput
    none?: CourseElectiveGroupMemberWhereInput
  }

  export type CourseElectiveGroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCollege_idCodeCompoundUniqueInput = {
    college_id: string
    code: string
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    college_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    type?: SortOrder
    hasTheoryComponent?: SortOrder
    hasLabComponent?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    college_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    type?: SortOrder
    hasTheoryComponent?: SortOrder
    hasLabComponent?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    college_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    type?: SortOrder
    hasTheoryComponent?: SortOrder
    hasLabComponent?: SortOrder
  }

  export type Enumcourse_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.course_type | Enumcourse_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.course_type[] | ListEnumcourse_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.course_type[] | ListEnumcourse_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcourse_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.course_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcourse_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumcourse_typeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DepartmentScalarRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type DepartmentElectiveGroupCollege_idNameDepartmentIdSemesterBatchYearCompoundUniqueInput = {
    college_id: string
    name: string
    departmentId: string
    semester: number
    batchYear: number
  }

  export type DepartmentElectiveGroupCountOrderByAggregateInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type DepartmentElectiveGroupAvgOrderByAggregateInput = {
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type DepartmentElectiveGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type DepartmentElectiveGroupMinOrderByAggregateInput = {
    id?: SortOrder
    college_id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type DepartmentElectiveGroupSumOrderByAggregateInput = {
    semester?: SortOrder
    batchYear?: SortOrder
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type DepartmentElectiveGroupScalarRelationFilter = {
    is?: DepartmentElectiveGroupWhereInput
    isNot?: DepartmentElectiveGroupWhereInput
  }

  export type CourseElectiveGroupMemberGroupIdCourseIdCompoundUniqueInput = {
    groupId: string
    courseId: string
  }

  export type CourseElectiveGroupMemberCountOrderByAggregateInput = {
    groupId?: SortOrder
    courseId?: SortOrder
  }

  export type CourseElectiveGroupMemberMaxOrderByAggregateInput = {
    groupId?: SortOrder
    courseId?: SortOrder
  }

  export type CourseElectiveGroupMemberMinOrderByAggregateInput = {
    groupId?: SortOrder
    courseId?: SortOrder
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type OpenElectiveRestrictionCourseIdRestrictedDepartmentIdCompoundUniqueInput = {
    courseId: string
    restrictedDepartmentId: string
  }

  export type OpenElectiveRestrictionCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    restrictedDepartmentId?: SortOrder
  }

  export type OpenElectiveRestrictionMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    restrictedDepartmentId?: SortOrder
  }

  export type OpenElectiveRestrictionMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    restrictedDepartmentId?: SortOrder
  }

  export type Academic_yearsNullableScalarRelationFilter = {
    is?: academic_yearsWhereInput | null
    isNot?: academic_yearsWhereInput | null
  }

  export type TestComponentListRelationFilter = {
    every?: TestComponentWhereInput
    some?: TestComponentWhereInput
    none?: TestComponentWhereInput
  }

  export type TestComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOfferingCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    teacherId?: SortOrder
    section_id?: SortOrder
    year_id?: SortOrder
    semester?: SortOrder
  }

  export type CourseOfferingAvgOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type CourseOfferingMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    teacherId?: SortOrder
    section_id?: SortOrder
    year_id?: SortOrder
    semester?: SortOrder
  }

  export type CourseOfferingMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    teacherId?: SortOrder
    section_id?: SortOrder
    year_id?: SortOrder
    semester?: SortOrder
  }

  export type CourseOfferingSumOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type CourseOfferingNullableScalarRelationFilter = {
    is?: CourseOfferingWhereInput | null
    isNot?: CourseOfferingWhereInput | null
  }

  export type StudentMarkListRelationFilter = {
    every?: StudentMarkWhereInput
    some?: StudentMarkWhereInput
    none?: StudentMarkWhereInput
  }

  export type StudentMarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    offeringId?: SortOrder
    attemptNumber?: SortOrder
    year_id?: SortOrder
  }

  export type StudentEnrollmentAvgOrderByAggregateInput = {
    attemptNumber?: SortOrder
  }

  export type StudentEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    offeringId?: SortOrder
    attemptNumber?: SortOrder
    year_id?: SortOrder
  }

  export type StudentEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    offeringId?: SortOrder
    attemptNumber?: SortOrder
    year_id?: SortOrder
  }

  export type StudentEnrollmentSumOrderByAggregateInput = {
    attemptNumber?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    offeringId?: SortOrder
    teacherId?: SortOrder
    classDate?: SortOrder
    periodNumber?: SortOrder
    syllabusCovered?: SortOrder
    status?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    periodNumber?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    offeringId?: SortOrder
    teacherId?: SortOrder
    classDate?: SortOrder
    periodNumber?: SortOrder
    syllabusCovered?: SortOrder
    status?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    offeringId?: SortOrder
    teacherId?: SortOrder
    classDate?: SortOrder
    periodNumber?: SortOrder
    syllabusCovered?: SortOrder
    status?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    periodNumber?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Enumattendance_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.attendance_status | Enumattendance_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumattendance_statusNullableFilter<$PrismaModel> | $Enums.attendance_status | null
  }

  export type AttendanceNullableScalarRelationFilter = {
    is?: AttendanceWhereInput | null
    isNot?: AttendanceWhereInput | null
  }

  export type AttendanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
  }

  export type AttendanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
  }

  export type AttendanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    attendanceId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
  }

  export type Enumattendance_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attendance_status | Enumattendance_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumattendance_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.attendance_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumattendance_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumattendance_statusNullableFilter<$PrismaModel>
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ReportViewerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ReportViewerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ReportViewerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type academic_yearsCollege_idYear_nameCompoundUniqueInput = {
    college_id: string
    year_name: string
  }

  export type academic_yearsCountOrderByAggregateInput = {
    year_id?: SortOrder
    college_id?: SortOrder
    year_name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
  }

  export type academic_yearsMaxOrderByAggregateInput = {
    year_id?: SortOrder
    college_id?: SortOrder
    year_name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
  }

  export type academic_yearsMinOrderByAggregateInput = {
    year_id?: SortOrder
    college_id?: SortOrder
    year_name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type sectionsDepartment_idSection_nameCompoundUniqueInput = {
    department_id: string
    section_name: string
  }

  export type sectionsCountOrderByAggregateInput = {
    section_id?: SortOrder
    department_id?: SortOrder
    section_name?: SortOrder
  }

  export type sectionsMaxOrderByAggregateInput = {
    section_id?: SortOrder
    department_id?: SortOrder
    section_name?: SortOrder
  }

  export type sectionsMinOrderByAggregateInput = {
    section_id?: SortOrder
    department_id?: SortOrder
    section_name?: SortOrder
  }

  export type CourseOfferingScalarRelationFilter = {
    is?: CourseOfferingWhereInput
    isNot?: CourseOfferingWhereInput
  }

  export type TestComponentCountOrderByAggregateInput = {
    id?: SortOrder
    courseOfferingId?: SortOrder
    name?: SortOrder
    maxMarks?: SortOrder
    weightage?: SortOrder
  }

  export type TestComponentAvgOrderByAggregateInput = {
    maxMarks?: SortOrder
    weightage?: SortOrder
  }

  export type TestComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    courseOfferingId?: SortOrder
    name?: SortOrder
    maxMarks?: SortOrder
    weightage?: SortOrder
  }

  export type TestComponentMinOrderByAggregateInput = {
    id?: SortOrder
    courseOfferingId?: SortOrder
    name?: SortOrder
    maxMarks?: SortOrder
    weightage?: SortOrder
  }

  export type TestComponentSumOrderByAggregateInput = {
    maxMarks?: SortOrder
    weightage?: SortOrder
  }

  export type StudentEnrollmentScalarRelationFilter = {
    is?: StudentEnrollmentWhereInput
    isNot?: StudentEnrollmentWhereInput
  }

  export type TestComponentScalarRelationFilter = {
    is?: TestComponentWhereInput
    isNot?: TestComponentWhereInput
  }

  export type StudentMarkEnrollmentIdTestComponentIdCompoundUniqueInput = {
    enrollmentId: string
    testComponentId: string
  }

  export type StudentMarkCountOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    testComponentId?: SortOrder
    marksObtained?: SortOrder
  }

  export type StudentMarkAvgOrderByAggregateInput = {
    marksObtained?: SortOrder
  }

  export type StudentMarkMaxOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    testComponentId?: SortOrder
    marksObtained?: SortOrder
  }

  export type StudentMarkMinOrderByAggregateInput = {
    id?: SortOrder
    enrollmentId?: SortOrder
    testComponentId?: SortOrder
    marksObtained?: SortOrder
  }

  export type StudentMarkSumOrderByAggregateInput = {
    marksObtained?: SortOrder
  }

  export type academic_yearsCreateNestedManyWithoutCollegesInput = {
    create?: XOR<academic_yearsCreateWithoutCollegesInput, academic_yearsUncheckedCreateWithoutCollegesInput> | academic_yearsCreateWithoutCollegesInput[] | academic_yearsUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: academic_yearsCreateOrConnectWithoutCollegesInput | academic_yearsCreateOrConnectWithoutCollegesInput[]
    createMany?: academic_yearsCreateManyCollegesInputEnvelope
    connect?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutCollegesInput = {
    create?: XOR<CourseCreateWithoutCollegesInput, CourseUncheckedCreateWithoutCollegesInput> | CourseCreateWithoutCollegesInput[] | CourseUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCollegesInput | CourseCreateOrConnectWithoutCollegesInput[]
    createMany?: CourseCreateManyCollegesInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type DepartmentElectiveGroupCreateNestedManyWithoutCollegesInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutCollegesInput, DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput> | DepartmentElectiveGroupCreateWithoutCollegesInput[] | DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutCollegesInput | DepartmentElectiveGroupCreateOrConnectWithoutCollegesInput[]
    createMany?: DepartmentElectiveGroupCreateManyCollegesInputEnvelope
    connect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutCollegesInput = {
    create?: XOR<DepartmentCreateWithoutCollegesInput, DepartmentUncheckedCreateWithoutCollegesInput> | DepartmentCreateWithoutCollegesInput[] | DepartmentUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCollegesInput | DepartmentCreateOrConnectWithoutCollegesInput[]
    createMany?: DepartmentCreateManyCollegesInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutCollegesInput = {
    create?: XOR<StudentCreateWithoutCollegesInput, StudentUncheckedCreateWithoutCollegesInput> | StudentCreateWithoutCollegesInput[] | StudentUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCollegesInput | StudentCreateOrConnectWithoutCollegesInput[]
    createMany?: StudentCreateManyCollegesInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherCreateNestedManyWithoutCollegesInput = {
    create?: XOR<TeacherCreateWithoutCollegesInput, TeacherUncheckedCreateWithoutCollegesInput> | TeacherCreateWithoutCollegesInput[] | TeacherUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutCollegesInput | TeacherCreateOrConnectWithoutCollegesInput[]
    createMany?: TeacherCreateManyCollegesInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type academic_yearsUncheckedCreateNestedManyWithoutCollegesInput = {
    create?: XOR<academic_yearsCreateWithoutCollegesInput, academic_yearsUncheckedCreateWithoutCollegesInput> | academic_yearsCreateWithoutCollegesInput[] | academic_yearsUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: academic_yearsCreateOrConnectWithoutCollegesInput | academic_yearsCreateOrConnectWithoutCollegesInput[]
    createMany?: academic_yearsCreateManyCollegesInputEnvelope
    connect?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCollegesInput = {
    create?: XOR<CourseCreateWithoutCollegesInput, CourseUncheckedCreateWithoutCollegesInput> | CourseCreateWithoutCollegesInput[] | CourseUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCollegesInput | CourseCreateOrConnectWithoutCollegesInput[]
    createMany?: CourseCreateManyCollegesInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type DepartmentElectiveGroupUncheckedCreateNestedManyWithoutCollegesInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutCollegesInput, DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput> | DepartmentElectiveGroupCreateWithoutCollegesInput[] | DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutCollegesInput | DepartmentElectiveGroupCreateOrConnectWithoutCollegesInput[]
    createMany?: DepartmentElectiveGroupCreateManyCollegesInputEnvelope
    connect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutCollegesInput = {
    create?: XOR<DepartmentCreateWithoutCollegesInput, DepartmentUncheckedCreateWithoutCollegesInput> | DepartmentCreateWithoutCollegesInput[] | DepartmentUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCollegesInput | DepartmentCreateOrConnectWithoutCollegesInput[]
    createMany?: DepartmentCreateManyCollegesInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutCollegesInput = {
    create?: XOR<StudentCreateWithoutCollegesInput, StudentUncheckedCreateWithoutCollegesInput> | StudentCreateWithoutCollegesInput[] | StudentUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCollegesInput | StudentCreateOrConnectWithoutCollegesInput[]
    createMany?: StudentCreateManyCollegesInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedManyWithoutCollegesInput = {
    create?: XOR<TeacherCreateWithoutCollegesInput, TeacherUncheckedCreateWithoutCollegesInput> | TeacherCreateWithoutCollegesInput[] | TeacherUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutCollegesInput | TeacherCreateOrConnectWithoutCollegesInput[]
    createMany?: TeacherCreateManyCollegesInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type academic_yearsUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<academic_yearsCreateWithoutCollegesInput, academic_yearsUncheckedCreateWithoutCollegesInput> | academic_yearsCreateWithoutCollegesInput[] | academic_yearsUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: academic_yearsCreateOrConnectWithoutCollegesInput | academic_yearsCreateOrConnectWithoutCollegesInput[]
    upsert?: academic_yearsUpsertWithWhereUniqueWithoutCollegesInput | academic_yearsUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: academic_yearsCreateManyCollegesInputEnvelope
    set?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
    disconnect?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
    delete?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
    connect?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
    update?: academic_yearsUpdateWithWhereUniqueWithoutCollegesInput | academic_yearsUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: academic_yearsUpdateManyWithWhereWithoutCollegesInput | academic_yearsUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: academic_yearsScalarWhereInput | academic_yearsScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<CourseCreateWithoutCollegesInput, CourseUncheckedCreateWithoutCollegesInput> | CourseCreateWithoutCollegesInput[] | CourseUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCollegesInput | CourseCreateOrConnectWithoutCollegesInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCollegesInput | CourseUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: CourseCreateManyCollegesInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCollegesInput | CourseUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCollegesInput | CourseUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type DepartmentElectiveGroupUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutCollegesInput, DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput> | DepartmentElectiveGroupCreateWithoutCollegesInput[] | DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutCollegesInput | DepartmentElectiveGroupCreateOrConnectWithoutCollegesInput[]
    upsert?: DepartmentElectiveGroupUpsertWithWhereUniqueWithoutCollegesInput | DepartmentElectiveGroupUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: DepartmentElectiveGroupCreateManyCollegesInputEnvelope
    set?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    disconnect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    delete?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    connect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    update?: DepartmentElectiveGroupUpdateWithWhereUniqueWithoutCollegesInput | DepartmentElectiveGroupUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: DepartmentElectiveGroupUpdateManyWithWhereWithoutCollegesInput | DepartmentElectiveGroupUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: DepartmentElectiveGroupScalarWhereInput | DepartmentElectiveGroupScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<DepartmentCreateWithoutCollegesInput, DepartmentUncheckedCreateWithoutCollegesInput> | DepartmentCreateWithoutCollegesInput[] | DepartmentUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCollegesInput | DepartmentCreateOrConnectWithoutCollegesInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCollegesInput | DepartmentUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: DepartmentCreateManyCollegesInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCollegesInput | DepartmentUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCollegesInput | DepartmentUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<StudentCreateWithoutCollegesInput, StudentUncheckedCreateWithoutCollegesInput> | StudentCreateWithoutCollegesInput[] | StudentUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCollegesInput | StudentCreateOrConnectWithoutCollegesInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCollegesInput | StudentUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: StudentCreateManyCollegesInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCollegesInput | StudentUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCollegesInput | StudentUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<TeacherCreateWithoutCollegesInput, TeacherUncheckedCreateWithoutCollegesInput> | TeacherCreateWithoutCollegesInput[] | TeacherUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutCollegesInput | TeacherCreateOrConnectWithoutCollegesInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutCollegesInput | TeacherUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: TeacherCreateManyCollegesInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutCollegesInput | TeacherUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutCollegesInput | TeacherUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type academic_yearsUncheckedUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<academic_yearsCreateWithoutCollegesInput, academic_yearsUncheckedCreateWithoutCollegesInput> | academic_yearsCreateWithoutCollegesInput[] | academic_yearsUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: academic_yearsCreateOrConnectWithoutCollegesInput | academic_yearsCreateOrConnectWithoutCollegesInput[]
    upsert?: academic_yearsUpsertWithWhereUniqueWithoutCollegesInput | academic_yearsUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: academic_yearsCreateManyCollegesInputEnvelope
    set?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
    disconnect?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
    delete?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
    connect?: academic_yearsWhereUniqueInput | academic_yearsWhereUniqueInput[]
    update?: academic_yearsUpdateWithWhereUniqueWithoutCollegesInput | academic_yearsUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: academic_yearsUpdateManyWithWhereWithoutCollegesInput | academic_yearsUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: academic_yearsScalarWhereInput | academic_yearsScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<CourseCreateWithoutCollegesInput, CourseUncheckedCreateWithoutCollegesInput> | CourseCreateWithoutCollegesInput[] | CourseUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCollegesInput | CourseCreateOrConnectWithoutCollegesInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCollegesInput | CourseUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: CourseCreateManyCollegesInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCollegesInput | CourseUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCollegesInput | CourseUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type DepartmentElectiveGroupUncheckedUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutCollegesInput, DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput> | DepartmentElectiveGroupCreateWithoutCollegesInput[] | DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutCollegesInput | DepartmentElectiveGroupCreateOrConnectWithoutCollegesInput[]
    upsert?: DepartmentElectiveGroupUpsertWithWhereUniqueWithoutCollegesInput | DepartmentElectiveGroupUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: DepartmentElectiveGroupCreateManyCollegesInputEnvelope
    set?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    disconnect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    delete?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    connect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    update?: DepartmentElectiveGroupUpdateWithWhereUniqueWithoutCollegesInput | DepartmentElectiveGroupUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: DepartmentElectiveGroupUpdateManyWithWhereWithoutCollegesInput | DepartmentElectiveGroupUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: DepartmentElectiveGroupScalarWhereInput | DepartmentElectiveGroupScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<DepartmentCreateWithoutCollegesInput, DepartmentUncheckedCreateWithoutCollegesInput> | DepartmentCreateWithoutCollegesInput[] | DepartmentUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCollegesInput | DepartmentCreateOrConnectWithoutCollegesInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCollegesInput | DepartmentUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: DepartmentCreateManyCollegesInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCollegesInput | DepartmentUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCollegesInput | DepartmentUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<StudentCreateWithoutCollegesInput, StudentUncheckedCreateWithoutCollegesInput> | StudentCreateWithoutCollegesInput[] | StudentUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCollegesInput | StudentCreateOrConnectWithoutCollegesInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCollegesInput | StudentUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: StudentCreateManyCollegesInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCollegesInput | StudentUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCollegesInput | StudentUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateManyWithoutCollegesNestedInput = {
    create?: XOR<TeacherCreateWithoutCollegesInput, TeacherUncheckedCreateWithoutCollegesInput> | TeacherCreateWithoutCollegesInput[] | TeacherUncheckedCreateWithoutCollegesInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutCollegesInput | TeacherCreateOrConnectWithoutCollegesInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutCollegesInput | TeacherUpsertWithWhereUniqueWithoutCollegesInput[]
    createMany?: TeacherCreateManyCollegesInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutCollegesInput | TeacherUpdateWithWhereUniqueWithoutCollegesInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutCollegesInput | TeacherUpdateManyWithWhereWithoutCollegesInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type CourseCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type DepartmentElectiveGroupCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutDepartmentInput, DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput> | DepartmentElectiveGroupCreateWithoutDepartmentInput[] | DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutDepartmentInput | DepartmentElectiveGroupCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentElectiveGroupCreateManyDepartmentInputEnvelope
    connect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
  }

  export type CollegeCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<CollegeCreateWithoutDepartmentsInput, CollegeUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutDepartmentsInput
    connect?: CollegeWhereUniqueInput
  }

  export type OpenElectiveRestrictionCreateNestedManyWithoutRestrictedDepartmentInput = {
    create?: XOR<OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput, OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput> | OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput[] | OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput[]
    connectOrCreate?: OpenElectiveRestrictionCreateOrConnectWithoutRestrictedDepartmentInput | OpenElectiveRestrictionCreateOrConnectWithoutRestrictedDepartmentInput[]
    createMany?: OpenElectiveRestrictionCreateManyRestrictedDepartmentInputEnvelope
    connect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
  }

  export type sectionsCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<sectionsCreateWithoutDepartmentsInput, sectionsUncheckedCreateWithoutDepartmentsInput> | sectionsCreateWithoutDepartmentsInput[] | sectionsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: sectionsCreateOrConnectWithoutDepartmentsInput | sectionsCreateOrConnectWithoutDepartmentsInput[]
    createMany?: sectionsCreateManyDepartmentsInputEnvelope
    connect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<StudentCreateWithoutDepartmentsInput, StudentUncheckedCreateWithoutDepartmentsInput> | StudentCreateWithoutDepartmentsInput[] | StudentUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutDepartmentsInput | StudentCreateOrConnectWithoutDepartmentsInput[]
    createMany?: StudentCreateManyDepartmentsInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput> | TeacherCreateWithoutDepartmentInput[] | TeacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutDepartmentInput | TeacherCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeacherCreateManyDepartmentInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type DepartmentElectiveGroupUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutDepartmentInput, DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput> | DepartmentElectiveGroupCreateWithoutDepartmentInput[] | DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutDepartmentInput | DepartmentElectiveGroupCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentElectiveGroupCreateManyDepartmentInputEnvelope
    connect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
  }

  export type OpenElectiveRestrictionUncheckedCreateNestedManyWithoutRestrictedDepartmentInput = {
    create?: XOR<OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput, OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput> | OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput[] | OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput[]
    connectOrCreate?: OpenElectiveRestrictionCreateOrConnectWithoutRestrictedDepartmentInput | OpenElectiveRestrictionCreateOrConnectWithoutRestrictedDepartmentInput[]
    createMany?: OpenElectiveRestrictionCreateManyRestrictedDepartmentInputEnvelope
    connect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
  }

  export type sectionsUncheckedCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<sectionsCreateWithoutDepartmentsInput, sectionsUncheckedCreateWithoutDepartmentsInput> | sectionsCreateWithoutDepartmentsInput[] | sectionsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: sectionsCreateOrConnectWithoutDepartmentsInput | sectionsCreateOrConnectWithoutDepartmentsInput[]
    createMany?: sectionsCreateManyDepartmentsInputEnvelope
    connect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<StudentCreateWithoutDepartmentsInput, StudentUncheckedCreateWithoutDepartmentsInput> | StudentCreateWithoutDepartmentsInput[] | StudentUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutDepartmentsInput | StudentCreateOrConnectWithoutDepartmentsInput[]
    createMany?: StudentCreateManyDepartmentsInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput> | TeacherCreateWithoutDepartmentInput[] | TeacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutDepartmentInput | TeacherCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeacherCreateManyDepartmentInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type CourseUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutDepartmentInput | CourseUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutDepartmentInput | CourseUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutDepartmentInput | CourseUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type DepartmentElectiveGroupUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutDepartmentInput, DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput> | DepartmentElectiveGroupCreateWithoutDepartmentInput[] | DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutDepartmentInput | DepartmentElectiveGroupCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentElectiveGroupUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentElectiveGroupUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentElectiveGroupCreateManyDepartmentInputEnvelope
    set?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    disconnect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    delete?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    connect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    update?: DepartmentElectiveGroupUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentElectiveGroupUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentElectiveGroupUpdateManyWithWhereWithoutDepartmentInput | DepartmentElectiveGroupUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentElectiveGroupScalarWhereInput | DepartmentElectiveGroupScalarWhereInput[]
  }

  export type CollegeUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<CollegeCreateWithoutDepartmentsInput, CollegeUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutDepartmentsInput
    upsert?: CollegeUpsertWithoutDepartmentsInput
    connect?: CollegeWhereUniqueInput
    update?: XOR<XOR<CollegeUpdateToOneWithWhereWithoutDepartmentsInput, CollegeUpdateWithoutDepartmentsInput>, CollegeUncheckedUpdateWithoutDepartmentsInput>
  }

  export type OpenElectiveRestrictionUpdateManyWithoutRestrictedDepartmentNestedInput = {
    create?: XOR<OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput, OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput> | OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput[] | OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput[]
    connectOrCreate?: OpenElectiveRestrictionCreateOrConnectWithoutRestrictedDepartmentInput | OpenElectiveRestrictionCreateOrConnectWithoutRestrictedDepartmentInput[]
    upsert?: OpenElectiveRestrictionUpsertWithWhereUniqueWithoutRestrictedDepartmentInput | OpenElectiveRestrictionUpsertWithWhereUniqueWithoutRestrictedDepartmentInput[]
    createMany?: OpenElectiveRestrictionCreateManyRestrictedDepartmentInputEnvelope
    set?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    disconnect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    delete?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    connect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    update?: OpenElectiveRestrictionUpdateWithWhereUniqueWithoutRestrictedDepartmentInput | OpenElectiveRestrictionUpdateWithWhereUniqueWithoutRestrictedDepartmentInput[]
    updateMany?: OpenElectiveRestrictionUpdateManyWithWhereWithoutRestrictedDepartmentInput | OpenElectiveRestrictionUpdateManyWithWhereWithoutRestrictedDepartmentInput[]
    deleteMany?: OpenElectiveRestrictionScalarWhereInput | OpenElectiveRestrictionScalarWhereInput[]
  }

  export type sectionsUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<sectionsCreateWithoutDepartmentsInput, sectionsUncheckedCreateWithoutDepartmentsInput> | sectionsCreateWithoutDepartmentsInput[] | sectionsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: sectionsCreateOrConnectWithoutDepartmentsInput | sectionsCreateOrConnectWithoutDepartmentsInput[]
    upsert?: sectionsUpsertWithWhereUniqueWithoutDepartmentsInput | sectionsUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: sectionsCreateManyDepartmentsInputEnvelope
    set?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    disconnect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    delete?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    connect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    update?: sectionsUpdateWithWhereUniqueWithoutDepartmentsInput | sectionsUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: sectionsUpdateManyWithWhereWithoutDepartmentsInput | sectionsUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: sectionsScalarWhereInput | sectionsScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<StudentCreateWithoutDepartmentsInput, StudentUncheckedCreateWithoutDepartmentsInput> | StudentCreateWithoutDepartmentsInput[] | StudentUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutDepartmentsInput | StudentCreateOrConnectWithoutDepartmentsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutDepartmentsInput | StudentUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: StudentCreateManyDepartmentsInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutDepartmentsInput | StudentUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutDepartmentsInput | StudentUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput> | TeacherCreateWithoutDepartmentInput[] | TeacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutDepartmentInput | TeacherCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutDepartmentInput | TeacherUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeacherCreateManyDepartmentInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutDepartmentInput | TeacherUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutDepartmentInput | TeacherUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput> | CourseCreateWithoutDepartmentInput[] | CourseUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutDepartmentInput | CourseCreateOrConnectWithoutDepartmentInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutDepartmentInput | CourseUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: CourseCreateManyDepartmentInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutDepartmentInput | CourseUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutDepartmentInput | CourseUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutDepartmentInput, DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput> | DepartmentElectiveGroupCreateWithoutDepartmentInput[] | DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutDepartmentInput | DepartmentElectiveGroupCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentElectiveGroupUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentElectiveGroupUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentElectiveGroupCreateManyDepartmentInputEnvelope
    set?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    disconnect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    delete?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    connect?: DepartmentElectiveGroupWhereUniqueInput | DepartmentElectiveGroupWhereUniqueInput[]
    update?: DepartmentElectiveGroupUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentElectiveGroupUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentElectiveGroupUpdateManyWithWhereWithoutDepartmentInput | DepartmentElectiveGroupUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentElectiveGroupScalarWhereInput | DepartmentElectiveGroupScalarWhereInput[]
  }

  export type OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentNestedInput = {
    create?: XOR<OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput, OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput> | OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput[] | OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput[]
    connectOrCreate?: OpenElectiveRestrictionCreateOrConnectWithoutRestrictedDepartmentInput | OpenElectiveRestrictionCreateOrConnectWithoutRestrictedDepartmentInput[]
    upsert?: OpenElectiveRestrictionUpsertWithWhereUniqueWithoutRestrictedDepartmentInput | OpenElectiveRestrictionUpsertWithWhereUniqueWithoutRestrictedDepartmentInput[]
    createMany?: OpenElectiveRestrictionCreateManyRestrictedDepartmentInputEnvelope
    set?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    disconnect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    delete?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    connect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    update?: OpenElectiveRestrictionUpdateWithWhereUniqueWithoutRestrictedDepartmentInput | OpenElectiveRestrictionUpdateWithWhereUniqueWithoutRestrictedDepartmentInput[]
    updateMany?: OpenElectiveRestrictionUpdateManyWithWhereWithoutRestrictedDepartmentInput | OpenElectiveRestrictionUpdateManyWithWhereWithoutRestrictedDepartmentInput[]
    deleteMany?: OpenElectiveRestrictionScalarWhereInput | OpenElectiveRestrictionScalarWhereInput[]
  }

  export type sectionsUncheckedUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<sectionsCreateWithoutDepartmentsInput, sectionsUncheckedCreateWithoutDepartmentsInput> | sectionsCreateWithoutDepartmentsInput[] | sectionsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: sectionsCreateOrConnectWithoutDepartmentsInput | sectionsCreateOrConnectWithoutDepartmentsInput[]
    upsert?: sectionsUpsertWithWhereUniqueWithoutDepartmentsInput | sectionsUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: sectionsCreateManyDepartmentsInputEnvelope
    set?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    disconnect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    delete?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    connect?: sectionsWhereUniqueInput | sectionsWhereUniqueInput[]
    update?: sectionsUpdateWithWhereUniqueWithoutDepartmentsInput | sectionsUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: sectionsUpdateManyWithWhereWithoutDepartmentsInput | sectionsUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: sectionsScalarWhereInput | sectionsScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<StudentCreateWithoutDepartmentsInput, StudentUncheckedCreateWithoutDepartmentsInput> | StudentCreateWithoutDepartmentsInput[] | StudentUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutDepartmentsInput | StudentCreateOrConnectWithoutDepartmentsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutDepartmentsInput | StudentUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: StudentCreateManyDepartmentsInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutDepartmentsInput | StudentUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutDepartmentsInput | StudentUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput> | TeacherCreateWithoutDepartmentInput[] | TeacherUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutDepartmentInput | TeacherCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutDepartmentInput | TeacherUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeacherCreateManyDepartmentInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutDepartmentInput | TeacherUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutDepartmentInput | TeacherUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ReportViewerCreateNestedOneWithoutUserInput = {
    create?: XOR<ReportViewerCreateWithoutUserInput, ReportViewerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReportViewerCreateOrConnectWithoutUserInput
    connect?: ReportViewerWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type UserRoleAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput> | UserRoleAssignmentCreateWithoutUserInput[] | UserRoleAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutUserInput | UserRoleAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleAssignmentCreateManyUserInputEnvelope
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ReportViewerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ReportViewerCreateWithoutUserInput, ReportViewerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReportViewerCreateOrConnectWithoutUserInput
    connect?: ReportViewerWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput> | UserRoleAssignmentCreateWithoutUserInput[] | UserRoleAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutUserInput | UserRoleAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleAssignmentCreateManyUserInputEnvelope
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type ReportViewerUpdateOneWithoutUserNestedInput = {
    create?: XOR<ReportViewerCreateWithoutUserInput, ReportViewerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReportViewerCreateOrConnectWithoutUserInput
    upsert?: ReportViewerUpsertWithoutUserInput
    disconnect?: ReportViewerWhereInput | boolean
    delete?: ReportViewerWhereInput | boolean
    connect?: ReportViewerWhereUniqueInput
    update?: XOR<XOR<ReportViewerUpdateToOneWithWhereWithoutUserInput, ReportViewerUpdateWithoutUserInput>, ReportViewerUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput> | UserRoleAssignmentCreateWithoutUserInput[] | UserRoleAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutUserInput | UserRoleAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput | UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleAssignmentCreateManyUserInputEnvelope
    set?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    disconnect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    delete?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    update?: UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput | UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleAssignmentUpdateManyWithWhereWithoutUserInput | UserRoleAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type ReportViewerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ReportViewerCreateWithoutUserInput, ReportViewerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReportViewerCreateOrConnectWithoutUserInput
    upsert?: ReportViewerUpsertWithoutUserInput
    disconnect?: ReportViewerWhereInput | boolean
    delete?: ReportViewerWhereInput | boolean
    connect?: ReportViewerWhereUniqueInput
    update?: XOR<XOR<ReportViewerUpdateToOneWithWhereWithoutUserInput, ReportViewerUpdateWithoutUserInput>, ReportViewerUncheckedUpdateWithoutUserInput>
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput> | UserRoleAssignmentCreateWithoutUserInput[] | UserRoleAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutUserInput | UserRoleAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput | UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleAssignmentCreateManyUserInputEnvelope
    set?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    disconnect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    delete?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    update?: UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput | UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleAssignmentUpdateManyWithWhereWithoutUserInput | UserRoleAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type Enumuser_roleFieldUpdateOperationsInput = {
    set?: $Enums.user_role
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type AttendanceRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentEnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type CollegeCreateNestedOneWithoutStudentsInput = {
    create?: XOR<CollegeCreateWithoutStudentsInput, CollegeUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutStudentsInput
    connect?: CollegeWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutStudentsInput = {
    create?: XOR<DepartmentCreateWithoutStudentsInput, DepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStudentsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type sectionsCreateNestedOneWithoutStudentsInput = {
    create?: XOR<sectionsCreateWithoutStudentsInput, sectionsUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: sectionsCreateOrConnectWithoutStudentsInput
    connect?: sectionsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AttendanceRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput | AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput | AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutStudentInput | AttendanceRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentEnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutStudentInput | StudentEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type CollegeUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<CollegeCreateWithoutStudentsInput, CollegeUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutStudentsInput
    upsert?: CollegeUpsertWithoutStudentsInput
    connect?: CollegeWhereUniqueInput
    update?: XOR<XOR<CollegeUpdateToOneWithWhereWithoutStudentsInput, CollegeUpdateWithoutStudentsInput>, CollegeUncheckedUpdateWithoutStudentsInput>
  }

  export type DepartmentUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<DepartmentCreateWithoutStudentsInput, DepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStudentsInput
    upsert?: DepartmentUpsertWithoutStudentsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutStudentsInput, DepartmentUpdateWithoutStudentsInput>, DepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type sectionsUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<sectionsCreateWithoutStudentsInput, sectionsUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: sectionsCreateOrConnectWithoutStudentsInput
    upsert?: sectionsUpsertWithoutStudentsInput
    disconnect?: sectionsWhereInput | boolean
    delete?: sectionsWhereInput | boolean
    connect?: sectionsWhereUniqueInput
    update?: XOR<XOR<sectionsUpdateToOneWithWhereWithoutStudentsInput, sectionsUpdateWithoutStudentsInput>, sectionsUncheckedUpdateWithoutStudentsInput>
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput | AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput | AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutStudentInput | AttendanceRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutStudentInput | StudentEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type AttendanceCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AttendanceCreateWithoutTeacherInput, AttendanceUncheckedCreateWithoutTeacherInput> | AttendanceCreateWithoutTeacherInput[] | AttendanceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTeacherInput | AttendanceCreateOrConnectWithoutTeacherInput[]
    createMany?: AttendanceCreateManyTeacherInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type CourseOfferingCreateNestedManyWithoutTeacherInput = {
    create?: XOR<CourseOfferingCreateWithoutTeacherInput, CourseOfferingUncheckedCreateWithoutTeacherInput> | CourseOfferingCreateWithoutTeacherInput[] | CourseOfferingUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTeacherInput | CourseOfferingCreateOrConnectWithoutTeacherInput[]
    createMany?: CourseOfferingCreateManyTeacherInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type CollegeCreateNestedOneWithoutTeachersInput = {
    create?: XOR<CollegeCreateWithoutTeachersInput, CollegeUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutTeachersInput
    connect?: CollegeWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutTeachersInput = {
    create?: XOR<DepartmentCreateWithoutTeachersInput, DepartmentUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeachersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeacherInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type AttendanceUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AttendanceCreateWithoutTeacherInput, AttendanceUncheckedCreateWithoutTeacherInput> | AttendanceCreateWithoutTeacherInput[] | AttendanceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTeacherInput | AttendanceCreateOrConnectWithoutTeacherInput[]
    createMany?: AttendanceCreateManyTeacherInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type CourseOfferingUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<CourseOfferingCreateWithoutTeacherInput, CourseOfferingUncheckedCreateWithoutTeacherInput> | CourseOfferingCreateWithoutTeacherInput[] | CourseOfferingUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTeacherInput | CourseOfferingCreateOrConnectWithoutTeacherInput[]
    createMany?: CourseOfferingCreateManyTeacherInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type AttendanceUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AttendanceCreateWithoutTeacherInput, AttendanceUncheckedCreateWithoutTeacherInput> | AttendanceCreateWithoutTeacherInput[] | AttendanceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTeacherInput | AttendanceCreateOrConnectWithoutTeacherInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutTeacherInput | AttendanceUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AttendanceCreateManyTeacherInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutTeacherInput | AttendanceUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutTeacherInput | AttendanceUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type CourseOfferingUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutTeacherInput, CourseOfferingUncheckedCreateWithoutTeacherInput> | CourseOfferingCreateWithoutTeacherInput[] | CourseOfferingUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTeacherInput | CourseOfferingCreateOrConnectWithoutTeacherInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutTeacherInput | CourseOfferingUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: CourseOfferingCreateManyTeacherInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutTeacherInput | CourseOfferingUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutTeacherInput | CourseOfferingUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type CollegeUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<CollegeCreateWithoutTeachersInput, CollegeUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutTeachersInput
    upsert?: CollegeUpsertWithoutTeachersInput
    connect?: CollegeWhereUniqueInput
    update?: XOR<XOR<CollegeUpdateToOneWithWhereWithoutTeachersInput, CollegeUpdateWithoutTeachersInput>, CollegeUncheckedUpdateWithoutTeachersInput>
  }

  export type DepartmentUpdateOneWithoutTeachersNestedInput = {
    create?: XOR<DepartmentCreateWithoutTeachersInput, DepartmentUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeachersInput
    upsert?: DepartmentUpsertWithoutTeachersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutTeachersInput, DepartmentUpdateWithoutTeachersInput>, DepartmentUncheckedUpdateWithoutTeachersInput>
  }

  export type UserUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    upsert?: UserUpsertWithoutTeacherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherInput, UserUpdateWithoutTeacherInput>, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type AttendanceUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AttendanceCreateWithoutTeacherInput, AttendanceUncheckedCreateWithoutTeacherInput> | AttendanceCreateWithoutTeacherInput[] | AttendanceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTeacherInput | AttendanceCreateOrConnectWithoutTeacherInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutTeacherInput | AttendanceUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AttendanceCreateManyTeacherInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutTeacherInput | AttendanceUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutTeacherInput | AttendanceUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type CourseOfferingUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutTeacherInput, CourseOfferingUncheckedCreateWithoutTeacherInput> | CourseOfferingCreateWithoutTeacherInput[] | CourseOfferingUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTeacherInput | CourseOfferingCreateOrConnectWithoutTeacherInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutTeacherInput | CourseOfferingUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: CourseOfferingCreateManyTeacherInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutTeacherInput | CourseOfferingUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutTeacherInput | CourseOfferingUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type CourseElectiveGroupMemberCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseElectiveGroupMemberCreateWithoutCourseInput, CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput> | CourseElectiveGroupMemberCreateWithoutCourseInput[] | CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseElectiveGroupMemberCreateOrConnectWithoutCourseInput | CourseElectiveGroupMemberCreateOrConnectWithoutCourseInput[]
    createMany?: CourseElectiveGroupMemberCreateManyCourseInputEnvelope
    connect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
  }

  export type CourseOfferingCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput> | CourseOfferingCreateWithoutCourseInput[] | CourseOfferingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutCourseInput | CourseOfferingCreateOrConnectWithoutCourseInput[]
    createMany?: CourseOfferingCreateManyCourseInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type CollegeCreateNestedOneWithoutCoursesInput = {
    create?: XOR<CollegeCreateWithoutCoursesInput, CollegeUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutCoursesInput
    connect?: CollegeWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutCoursesInput = {
    create?: XOR<DepartmentCreateWithoutCoursesInput, DepartmentUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutCoursesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type OpenElectiveRestrictionCreateNestedManyWithoutCourseInput = {
    create?: XOR<OpenElectiveRestrictionCreateWithoutCourseInput, OpenElectiveRestrictionUncheckedCreateWithoutCourseInput> | OpenElectiveRestrictionCreateWithoutCourseInput[] | OpenElectiveRestrictionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OpenElectiveRestrictionCreateOrConnectWithoutCourseInput | OpenElectiveRestrictionCreateOrConnectWithoutCourseInput[]
    createMany?: OpenElectiveRestrictionCreateManyCourseInputEnvelope
    connect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
  }

  export type CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseElectiveGroupMemberCreateWithoutCourseInput, CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput> | CourseElectiveGroupMemberCreateWithoutCourseInput[] | CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseElectiveGroupMemberCreateOrConnectWithoutCourseInput | CourseElectiveGroupMemberCreateOrConnectWithoutCourseInput[]
    createMany?: CourseElectiveGroupMemberCreateManyCourseInputEnvelope
    connect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
  }

  export type CourseOfferingUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput> | CourseOfferingCreateWithoutCourseInput[] | CourseOfferingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutCourseInput | CourseOfferingCreateOrConnectWithoutCourseInput[]
    createMany?: CourseOfferingCreateManyCourseInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type OpenElectiveRestrictionUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<OpenElectiveRestrictionCreateWithoutCourseInput, OpenElectiveRestrictionUncheckedCreateWithoutCourseInput> | OpenElectiveRestrictionCreateWithoutCourseInput[] | OpenElectiveRestrictionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OpenElectiveRestrictionCreateOrConnectWithoutCourseInput | OpenElectiveRestrictionCreateOrConnectWithoutCourseInput[]
    createMany?: OpenElectiveRestrictionCreateManyCourseInputEnvelope
    connect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
  }

  export type NullableEnumcourse_typeFieldUpdateOperationsInput = {
    set?: $Enums.course_type | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CourseElectiveGroupMemberUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseElectiveGroupMemberCreateWithoutCourseInput, CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput> | CourseElectiveGroupMemberCreateWithoutCourseInput[] | CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseElectiveGroupMemberCreateOrConnectWithoutCourseInput | CourseElectiveGroupMemberCreateOrConnectWithoutCourseInput[]
    upsert?: CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutCourseInput | CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseElectiveGroupMemberCreateManyCourseInputEnvelope
    set?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    disconnect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    delete?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    connect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    update?: CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutCourseInput | CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseElectiveGroupMemberUpdateManyWithWhereWithoutCourseInput | CourseElectiveGroupMemberUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseElectiveGroupMemberScalarWhereInput | CourseElectiveGroupMemberScalarWhereInput[]
  }

  export type CourseOfferingUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput> | CourseOfferingCreateWithoutCourseInput[] | CourseOfferingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutCourseInput | CourseOfferingCreateOrConnectWithoutCourseInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutCourseInput | CourseOfferingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseOfferingCreateManyCourseInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutCourseInput | CourseOfferingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutCourseInput | CourseOfferingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type CollegeUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<CollegeCreateWithoutCoursesInput, CollegeUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutCoursesInput
    upsert?: CollegeUpsertWithoutCoursesInput
    connect?: CollegeWhereUniqueInput
    update?: XOR<XOR<CollegeUpdateToOneWithWhereWithoutCoursesInput, CollegeUpdateWithoutCoursesInput>, CollegeUncheckedUpdateWithoutCoursesInput>
  }

  export type DepartmentUpdateOneWithoutCoursesNestedInput = {
    create?: XOR<DepartmentCreateWithoutCoursesInput, DepartmentUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutCoursesInput
    upsert?: DepartmentUpsertWithoutCoursesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutCoursesInput, DepartmentUpdateWithoutCoursesInput>, DepartmentUncheckedUpdateWithoutCoursesInput>
  }

  export type OpenElectiveRestrictionUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OpenElectiveRestrictionCreateWithoutCourseInput, OpenElectiveRestrictionUncheckedCreateWithoutCourseInput> | OpenElectiveRestrictionCreateWithoutCourseInput[] | OpenElectiveRestrictionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OpenElectiveRestrictionCreateOrConnectWithoutCourseInput | OpenElectiveRestrictionCreateOrConnectWithoutCourseInput[]
    upsert?: OpenElectiveRestrictionUpsertWithWhereUniqueWithoutCourseInput | OpenElectiveRestrictionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OpenElectiveRestrictionCreateManyCourseInputEnvelope
    set?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    disconnect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    delete?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    connect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    update?: OpenElectiveRestrictionUpdateWithWhereUniqueWithoutCourseInput | OpenElectiveRestrictionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OpenElectiveRestrictionUpdateManyWithWhereWithoutCourseInput | OpenElectiveRestrictionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OpenElectiveRestrictionScalarWhereInput | OpenElectiveRestrictionScalarWhereInput[]
  }

  export type CourseElectiveGroupMemberUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseElectiveGroupMemberCreateWithoutCourseInput, CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput> | CourseElectiveGroupMemberCreateWithoutCourseInput[] | CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseElectiveGroupMemberCreateOrConnectWithoutCourseInput | CourseElectiveGroupMemberCreateOrConnectWithoutCourseInput[]
    upsert?: CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutCourseInput | CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseElectiveGroupMemberCreateManyCourseInputEnvelope
    set?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    disconnect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    delete?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    connect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    update?: CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutCourseInput | CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseElectiveGroupMemberUpdateManyWithWhereWithoutCourseInput | CourseElectiveGroupMemberUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseElectiveGroupMemberScalarWhereInput | CourseElectiveGroupMemberScalarWhereInput[]
  }

  export type CourseOfferingUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput> | CourseOfferingCreateWithoutCourseInput[] | CourseOfferingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutCourseInput | CourseOfferingCreateOrConnectWithoutCourseInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutCourseInput | CourseOfferingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseOfferingCreateManyCourseInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutCourseInput | CourseOfferingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutCourseInput | CourseOfferingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type OpenElectiveRestrictionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OpenElectiveRestrictionCreateWithoutCourseInput, OpenElectiveRestrictionUncheckedCreateWithoutCourseInput> | OpenElectiveRestrictionCreateWithoutCourseInput[] | OpenElectiveRestrictionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OpenElectiveRestrictionCreateOrConnectWithoutCourseInput | OpenElectiveRestrictionCreateOrConnectWithoutCourseInput[]
    upsert?: OpenElectiveRestrictionUpsertWithWhereUniqueWithoutCourseInput | OpenElectiveRestrictionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OpenElectiveRestrictionCreateManyCourseInputEnvelope
    set?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    disconnect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    delete?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    connect?: OpenElectiveRestrictionWhereUniqueInput | OpenElectiveRestrictionWhereUniqueInput[]
    update?: OpenElectiveRestrictionUpdateWithWhereUniqueWithoutCourseInput | OpenElectiveRestrictionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OpenElectiveRestrictionUpdateManyWithWhereWithoutCourseInput | OpenElectiveRestrictionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OpenElectiveRestrictionScalarWhereInput | OpenElectiveRestrictionScalarWhereInput[]
  }

  export type CourseElectiveGroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<CourseElectiveGroupMemberCreateWithoutGroupInput, CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput> | CourseElectiveGroupMemberCreateWithoutGroupInput[] | CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: CourseElectiveGroupMemberCreateOrConnectWithoutGroupInput | CourseElectiveGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: CourseElectiveGroupMemberCreateManyGroupInputEnvelope
    connect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
  }

  export type CollegeCreateNestedOneWithoutDepartment_elective_groupsInput = {
    create?: XOR<CollegeCreateWithoutDepartment_elective_groupsInput, CollegeUncheckedCreateWithoutDepartment_elective_groupsInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutDepartment_elective_groupsInput
    connect?: CollegeWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutDepartmentElectiveGroupsInput = {
    create?: XOR<DepartmentCreateWithoutDepartmentElectiveGroupsInput, DepartmentUncheckedCreateWithoutDepartmentElectiveGroupsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDepartmentElectiveGroupsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<CourseElectiveGroupMemberCreateWithoutGroupInput, CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput> | CourseElectiveGroupMemberCreateWithoutGroupInput[] | CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: CourseElectiveGroupMemberCreateOrConnectWithoutGroupInput | CourseElectiveGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: CourseElectiveGroupMemberCreateManyGroupInputEnvelope
    connect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
  }

  export type CourseElectiveGroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<CourseElectiveGroupMemberCreateWithoutGroupInput, CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput> | CourseElectiveGroupMemberCreateWithoutGroupInput[] | CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: CourseElectiveGroupMemberCreateOrConnectWithoutGroupInput | CourseElectiveGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutGroupInput | CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: CourseElectiveGroupMemberCreateManyGroupInputEnvelope
    set?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    disconnect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    delete?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    connect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    update?: CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutGroupInput | CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: CourseElectiveGroupMemberUpdateManyWithWhereWithoutGroupInput | CourseElectiveGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: CourseElectiveGroupMemberScalarWhereInput | CourseElectiveGroupMemberScalarWhereInput[]
  }

  export type CollegeUpdateOneRequiredWithoutDepartment_elective_groupsNestedInput = {
    create?: XOR<CollegeCreateWithoutDepartment_elective_groupsInput, CollegeUncheckedCreateWithoutDepartment_elective_groupsInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutDepartment_elective_groupsInput
    upsert?: CollegeUpsertWithoutDepartment_elective_groupsInput
    connect?: CollegeWhereUniqueInput
    update?: XOR<XOR<CollegeUpdateToOneWithWhereWithoutDepartment_elective_groupsInput, CollegeUpdateWithoutDepartment_elective_groupsInput>, CollegeUncheckedUpdateWithoutDepartment_elective_groupsInput>
  }

  export type DepartmentUpdateOneRequiredWithoutDepartmentElectiveGroupsNestedInput = {
    create?: XOR<DepartmentCreateWithoutDepartmentElectiveGroupsInput, DepartmentUncheckedCreateWithoutDepartmentElectiveGroupsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDepartmentElectiveGroupsInput
    upsert?: DepartmentUpsertWithoutDepartmentElectiveGroupsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutDepartmentElectiveGroupsInput, DepartmentUpdateWithoutDepartmentElectiveGroupsInput>, DepartmentUncheckedUpdateWithoutDepartmentElectiveGroupsInput>
  }

  export type CourseElectiveGroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<CourseElectiveGroupMemberCreateWithoutGroupInput, CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput> | CourseElectiveGroupMemberCreateWithoutGroupInput[] | CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: CourseElectiveGroupMemberCreateOrConnectWithoutGroupInput | CourseElectiveGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutGroupInput | CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: CourseElectiveGroupMemberCreateManyGroupInputEnvelope
    set?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    disconnect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    delete?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    connect?: CourseElectiveGroupMemberWhereUniqueInput | CourseElectiveGroupMemberWhereUniqueInput[]
    update?: CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutGroupInput | CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: CourseElectiveGroupMemberUpdateManyWithWhereWithoutGroupInput | CourseElectiveGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: CourseElectiveGroupMemberScalarWhereInput | CourseElectiveGroupMemberScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutCourseElectiveGroupMembersInput = {
    create?: XOR<CourseCreateWithoutCourseElectiveGroupMembersInput, CourseUncheckedCreateWithoutCourseElectiveGroupMembersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseElectiveGroupMembersInput
    connect?: CourseWhereUniqueInput
  }

  export type DepartmentElectiveGroupCreateNestedOneWithoutCourseElectiveGroupMembersInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutCourseElectiveGroupMembersInput, DepartmentElectiveGroupUncheckedCreateWithoutCourseElectiveGroupMembersInput>
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutCourseElectiveGroupMembersInput
    connect?: DepartmentElectiveGroupWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCourseElectiveGroupMembersNestedInput = {
    create?: XOR<CourseCreateWithoutCourseElectiveGroupMembersInput, CourseUncheckedCreateWithoutCourseElectiveGroupMembersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseElectiveGroupMembersInput
    upsert?: CourseUpsertWithoutCourseElectiveGroupMembersInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseElectiveGroupMembersInput, CourseUpdateWithoutCourseElectiveGroupMembersInput>, CourseUncheckedUpdateWithoutCourseElectiveGroupMembersInput>
  }

  export type DepartmentElectiveGroupUpdateOneRequiredWithoutCourseElectiveGroupMembersNestedInput = {
    create?: XOR<DepartmentElectiveGroupCreateWithoutCourseElectiveGroupMembersInput, DepartmentElectiveGroupUncheckedCreateWithoutCourseElectiveGroupMembersInput>
    connectOrCreate?: DepartmentElectiveGroupCreateOrConnectWithoutCourseElectiveGroupMembersInput
    upsert?: DepartmentElectiveGroupUpsertWithoutCourseElectiveGroupMembersInput
    connect?: DepartmentElectiveGroupWhereUniqueInput
    update?: XOR<XOR<DepartmentElectiveGroupUpdateToOneWithWhereWithoutCourseElectiveGroupMembersInput, DepartmentElectiveGroupUpdateWithoutCourseElectiveGroupMembersInput>, DepartmentElectiveGroupUncheckedUpdateWithoutCourseElectiveGroupMembersInput>
  }

  export type CourseCreateNestedOneWithoutOpenElectiveRestrictionsInput = {
    create?: XOR<CourseCreateWithoutOpenElectiveRestrictionsInput, CourseUncheckedCreateWithoutOpenElectiveRestrictionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOpenElectiveRestrictionsInput
    connect?: CourseWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutOpenElectiveRestrictionsInput = {
    create?: XOR<DepartmentCreateWithoutOpenElectiveRestrictionsInput, DepartmentUncheckedCreateWithoutOpenElectiveRestrictionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutOpenElectiveRestrictionsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type CourseUpdateOneWithoutOpenElectiveRestrictionsNestedInput = {
    create?: XOR<CourseCreateWithoutOpenElectiveRestrictionsInput, CourseUncheckedCreateWithoutOpenElectiveRestrictionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOpenElectiveRestrictionsInput
    upsert?: CourseUpsertWithoutOpenElectiveRestrictionsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutOpenElectiveRestrictionsInput, CourseUpdateWithoutOpenElectiveRestrictionsInput>, CourseUncheckedUpdateWithoutOpenElectiveRestrictionsInput>
  }

  export type DepartmentUpdateOneRequiredWithoutOpenElectiveRestrictionsNestedInput = {
    create?: XOR<DepartmentCreateWithoutOpenElectiveRestrictionsInput, DepartmentUncheckedCreateWithoutOpenElectiveRestrictionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutOpenElectiveRestrictionsInput
    upsert?: DepartmentUpsertWithoutOpenElectiveRestrictionsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutOpenElectiveRestrictionsInput, DepartmentUpdateWithoutOpenElectiveRestrictionsInput>, DepartmentUncheckedUpdateWithoutOpenElectiveRestrictionsInput>
  }

  export type AttendanceCreateNestedManyWithoutOfferingInput = {
    create?: XOR<AttendanceCreateWithoutOfferingInput, AttendanceUncheckedCreateWithoutOfferingInput> | AttendanceCreateWithoutOfferingInput[] | AttendanceUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOfferingInput | AttendanceCreateOrConnectWithoutOfferingInput[]
    createMany?: AttendanceCreateManyOfferingInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type CourseCreateNestedOneWithoutCourseOfferingsInput = {
    create?: XOR<CourseCreateWithoutCourseOfferingsInput, CourseUncheckedCreateWithoutCourseOfferingsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseOfferingsInput
    connect?: CourseWhereUniqueInput
  }

  export type sectionsCreateNestedOneWithoutCourse_offeringsInput = {
    create?: XOR<sectionsCreateWithoutCourse_offeringsInput, sectionsUncheckedCreateWithoutCourse_offeringsInput>
    connectOrCreate?: sectionsCreateOrConnectWithoutCourse_offeringsInput
    connect?: sectionsWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutCourseOfferingsInput = {
    create?: XOR<TeacherCreateWithoutCourseOfferingsInput, TeacherUncheckedCreateWithoutCourseOfferingsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCourseOfferingsInput
    connect?: TeacherWhereUniqueInput
  }

  export type academic_yearsCreateNestedOneWithoutCourse_offeringsInput = {
    create?: XOR<academic_yearsCreateWithoutCourse_offeringsInput, academic_yearsUncheckedCreateWithoutCourse_offeringsInput>
    connectOrCreate?: academic_yearsCreateOrConnectWithoutCourse_offeringsInput
    connect?: academic_yearsWhereUniqueInput
  }

  export type StudentEnrollmentCreateNestedManyWithoutOfferingInput = {
    create?: XOR<StudentEnrollmentCreateWithoutOfferingInput, StudentEnrollmentUncheckedCreateWithoutOfferingInput> | StudentEnrollmentCreateWithoutOfferingInput[] | StudentEnrollmentUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutOfferingInput | StudentEnrollmentCreateOrConnectWithoutOfferingInput[]
    createMany?: StudentEnrollmentCreateManyOfferingInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type TestComponentCreateNestedManyWithoutCourseOfferingInput = {
    create?: XOR<TestComponentCreateWithoutCourseOfferingInput, TestComponentUncheckedCreateWithoutCourseOfferingInput> | TestComponentCreateWithoutCourseOfferingInput[] | TestComponentUncheckedCreateWithoutCourseOfferingInput[]
    connectOrCreate?: TestComponentCreateOrConnectWithoutCourseOfferingInput | TestComponentCreateOrConnectWithoutCourseOfferingInput[]
    createMany?: TestComponentCreateManyCourseOfferingInputEnvelope
    connect?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutOfferingInput = {
    create?: XOR<AttendanceCreateWithoutOfferingInput, AttendanceUncheckedCreateWithoutOfferingInput> | AttendanceCreateWithoutOfferingInput[] | AttendanceUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOfferingInput | AttendanceCreateOrConnectWithoutOfferingInput[]
    createMany?: AttendanceCreateManyOfferingInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type StudentEnrollmentUncheckedCreateNestedManyWithoutOfferingInput = {
    create?: XOR<StudentEnrollmentCreateWithoutOfferingInput, StudentEnrollmentUncheckedCreateWithoutOfferingInput> | StudentEnrollmentCreateWithoutOfferingInput[] | StudentEnrollmentUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutOfferingInput | StudentEnrollmentCreateOrConnectWithoutOfferingInput[]
    createMany?: StudentEnrollmentCreateManyOfferingInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type TestComponentUncheckedCreateNestedManyWithoutCourseOfferingInput = {
    create?: XOR<TestComponentCreateWithoutCourseOfferingInput, TestComponentUncheckedCreateWithoutCourseOfferingInput> | TestComponentCreateWithoutCourseOfferingInput[] | TestComponentUncheckedCreateWithoutCourseOfferingInput[]
    connectOrCreate?: TestComponentCreateOrConnectWithoutCourseOfferingInput | TestComponentCreateOrConnectWithoutCourseOfferingInput[]
    createMany?: TestComponentCreateManyCourseOfferingInputEnvelope
    connect?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
  }

  export type AttendanceUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<AttendanceCreateWithoutOfferingInput, AttendanceUncheckedCreateWithoutOfferingInput> | AttendanceCreateWithoutOfferingInput[] | AttendanceUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOfferingInput | AttendanceCreateOrConnectWithoutOfferingInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutOfferingInput | AttendanceUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: AttendanceCreateManyOfferingInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutOfferingInput | AttendanceUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutOfferingInput | AttendanceUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type CourseUpdateOneRequiredWithoutCourseOfferingsNestedInput = {
    create?: XOR<CourseCreateWithoutCourseOfferingsInput, CourseUncheckedCreateWithoutCourseOfferingsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseOfferingsInput
    upsert?: CourseUpsertWithoutCourseOfferingsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseOfferingsInput, CourseUpdateWithoutCourseOfferingsInput>, CourseUncheckedUpdateWithoutCourseOfferingsInput>
  }

  export type sectionsUpdateOneWithoutCourse_offeringsNestedInput = {
    create?: XOR<sectionsCreateWithoutCourse_offeringsInput, sectionsUncheckedCreateWithoutCourse_offeringsInput>
    connectOrCreate?: sectionsCreateOrConnectWithoutCourse_offeringsInput
    upsert?: sectionsUpsertWithoutCourse_offeringsInput
    disconnect?: sectionsWhereInput | boolean
    delete?: sectionsWhereInput | boolean
    connect?: sectionsWhereUniqueInput
    update?: XOR<XOR<sectionsUpdateToOneWithWhereWithoutCourse_offeringsInput, sectionsUpdateWithoutCourse_offeringsInput>, sectionsUncheckedUpdateWithoutCourse_offeringsInput>
  }

  export type TeacherUpdateOneWithoutCourseOfferingsNestedInput = {
    create?: XOR<TeacherCreateWithoutCourseOfferingsInput, TeacherUncheckedCreateWithoutCourseOfferingsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCourseOfferingsInput
    upsert?: TeacherUpsertWithoutCourseOfferingsInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutCourseOfferingsInput, TeacherUpdateWithoutCourseOfferingsInput>, TeacherUncheckedUpdateWithoutCourseOfferingsInput>
  }

  export type academic_yearsUpdateOneWithoutCourse_offeringsNestedInput = {
    create?: XOR<academic_yearsCreateWithoutCourse_offeringsInput, academic_yearsUncheckedCreateWithoutCourse_offeringsInput>
    connectOrCreate?: academic_yearsCreateOrConnectWithoutCourse_offeringsInput
    upsert?: academic_yearsUpsertWithoutCourse_offeringsInput
    disconnect?: academic_yearsWhereInput | boolean
    delete?: academic_yearsWhereInput | boolean
    connect?: academic_yearsWhereUniqueInput
    update?: XOR<XOR<academic_yearsUpdateToOneWithWhereWithoutCourse_offeringsInput, academic_yearsUpdateWithoutCourse_offeringsInput>, academic_yearsUncheckedUpdateWithoutCourse_offeringsInput>
  }

  export type StudentEnrollmentUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutOfferingInput, StudentEnrollmentUncheckedCreateWithoutOfferingInput> | StudentEnrollmentCreateWithoutOfferingInput[] | StudentEnrollmentUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutOfferingInput | StudentEnrollmentCreateOrConnectWithoutOfferingInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutOfferingInput | StudentEnrollmentUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: StudentEnrollmentCreateManyOfferingInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutOfferingInput | StudentEnrollmentUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutOfferingInput | StudentEnrollmentUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type TestComponentUpdateManyWithoutCourseOfferingNestedInput = {
    create?: XOR<TestComponentCreateWithoutCourseOfferingInput, TestComponentUncheckedCreateWithoutCourseOfferingInput> | TestComponentCreateWithoutCourseOfferingInput[] | TestComponentUncheckedCreateWithoutCourseOfferingInput[]
    connectOrCreate?: TestComponentCreateOrConnectWithoutCourseOfferingInput | TestComponentCreateOrConnectWithoutCourseOfferingInput[]
    upsert?: TestComponentUpsertWithWhereUniqueWithoutCourseOfferingInput | TestComponentUpsertWithWhereUniqueWithoutCourseOfferingInput[]
    createMany?: TestComponentCreateManyCourseOfferingInputEnvelope
    set?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
    disconnect?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
    delete?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
    connect?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
    update?: TestComponentUpdateWithWhereUniqueWithoutCourseOfferingInput | TestComponentUpdateWithWhereUniqueWithoutCourseOfferingInput[]
    updateMany?: TestComponentUpdateManyWithWhereWithoutCourseOfferingInput | TestComponentUpdateManyWithWhereWithoutCourseOfferingInput[]
    deleteMany?: TestComponentScalarWhereInput | TestComponentScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<AttendanceCreateWithoutOfferingInput, AttendanceUncheckedCreateWithoutOfferingInput> | AttendanceCreateWithoutOfferingInput[] | AttendanceUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutOfferingInput | AttendanceCreateOrConnectWithoutOfferingInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutOfferingInput | AttendanceUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: AttendanceCreateManyOfferingInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutOfferingInput | AttendanceUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutOfferingInput | AttendanceUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutOfferingInput, StudentEnrollmentUncheckedCreateWithoutOfferingInput> | StudentEnrollmentCreateWithoutOfferingInput[] | StudentEnrollmentUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutOfferingInput | StudentEnrollmentCreateOrConnectWithoutOfferingInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutOfferingInput | StudentEnrollmentUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: StudentEnrollmentCreateManyOfferingInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutOfferingInput | StudentEnrollmentUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutOfferingInput | StudentEnrollmentUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type TestComponentUncheckedUpdateManyWithoutCourseOfferingNestedInput = {
    create?: XOR<TestComponentCreateWithoutCourseOfferingInput, TestComponentUncheckedCreateWithoutCourseOfferingInput> | TestComponentCreateWithoutCourseOfferingInput[] | TestComponentUncheckedCreateWithoutCourseOfferingInput[]
    connectOrCreate?: TestComponentCreateOrConnectWithoutCourseOfferingInput | TestComponentCreateOrConnectWithoutCourseOfferingInput[]
    upsert?: TestComponentUpsertWithWhereUniqueWithoutCourseOfferingInput | TestComponentUpsertWithWhereUniqueWithoutCourseOfferingInput[]
    createMany?: TestComponentCreateManyCourseOfferingInputEnvelope
    set?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
    disconnect?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
    delete?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
    connect?: TestComponentWhereUniqueInput | TestComponentWhereUniqueInput[]
    update?: TestComponentUpdateWithWhereUniqueWithoutCourseOfferingInput | TestComponentUpdateWithWhereUniqueWithoutCourseOfferingInput[]
    updateMany?: TestComponentUpdateManyWithWhereWithoutCourseOfferingInput | TestComponentUpdateManyWithWhereWithoutCourseOfferingInput[]
    deleteMany?: TestComponentScalarWhereInput | TestComponentScalarWhereInput[]
  }

  export type CourseOfferingCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseOfferingCreateWithoutEnrollmentsInput, CourseOfferingUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseOfferingWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type academic_yearsCreateNestedOneWithoutStudent_enrollmentsInput = {
    create?: XOR<academic_yearsCreateWithoutStudent_enrollmentsInput, academic_yearsUncheckedCreateWithoutStudent_enrollmentsInput>
    connectOrCreate?: academic_yearsCreateOrConnectWithoutStudent_enrollmentsInput
    connect?: academic_yearsWhereUniqueInput
  }

  export type StudentMarkCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<StudentMarkCreateWithoutEnrollmentInput, StudentMarkUncheckedCreateWithoutEnrollmentInput> | StudentMarkCreateWithoutEnrollmentInput[] | StudentMarkUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: StudentMarkCreateOrConnectWithoutEnrollmentInput | StudentMarkCreateOrConnectWithoutEnrollmentInput[]
    createMany?: StudentMarkCreateManyEnrollmentInputEnvelope
    connect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
  }

  export type StudentMarkUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<StudentMarkCreateWithoutEnrollmentInput, StudentMarkUncheckedCreateWithoutEnrollmentInput> | StudentMarkCreateWithoutEnrollmentInput[] | StudentMarkUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: StudentMarkCreateOrConnectWithoutEnrollmentInput | StudentMarkCreateOrConnectWithoutEnrollmentInput[]
    createMany?: StudentMarkCreateManyEnrollmentInputEnvelope
    connect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
  }

  export type CourseOfferingUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutEnrollmentsInput, CourseOfferingUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseOfferingUpsertWithoutEnrollmentsInput
    disconnect?: CourseOfferingWhereInput | boolean
    delete?: CourseOfferingWhereInput | boolean
    connect?: CourseOfferingWhereUniqueInput
    update?: XOR<XOR<CourseOfferingUpdateToOneWithWhereWithoutEnrollmentsInput, CourseOfferingUpdateWithoutEnrollmentsInput>, CourseOfferingUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    upsert?: StudentUpsertWithoutEnrollmentsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEnrollmentsInput, StudentUpdateWithoutEnrollmentsInput>, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type academic_yearsUpdateOneWithoutStudent_enrollmentsNestedInput = {
    create?: XOR<academic_yearsCreateWithoutStudent_enrollmentsInput, academic_yearsUncheckedCreateWithoutStudent_enrollmentsInput>
    connectOrCreate?: academic_yearsCreateOrConnectWithoutStudent_enrollmentsInput
    upsert?: academic_yearsUpsertWithoutStudent_enrollmentsInput
    disconnect?: academic_yearsWhereInput | boolean
    delete?: academic_yearsWhereInput | boolean
    connect?: academic_yearsWhereUniqueInput
    update?: XOR<XOR<academic_yearsUpdateToOneWithWhereWithoutStudent_enrollmentsInput, academic_yearsUpdateWithoutStudent_enrollmentsInput>, academic_yearsUncheckedUpdateWithoutStudent_enrollmentsInput>
  }

  export type StudentMarkUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<StudentMarkCreateWithoutEnrollmentInput, StudentMarkUncheckedCreateWithoutEnrollmentInput> | StudentMarkCreateWithoutEnrollmentInput[] | StudentMarkUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: StudentMarkCreateOrConnectWithoutEnrollmentInput | StudentMarkCreateOrConnectWithoutEnrollmentInput[]
    upsert?: StudentMarkUpsertWithWhereUniqueWithoutEnrollmentInput | StudentMarkUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: StudentMarkCreateManyEnrollmentInputEnvelope
    set?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    disconnect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    delete?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    connect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    update?: StudentMarkUpdateWithWhereUniqueWithoutEnrollmentInput | StudentMarkUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: StudentMarkUpdateManyWithWhereWithoutEnrollmentInput | StudentMarkUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: StudentMarkScalarWhereInput | StudentMarkScalarWhereInput[]
  }

  export type StudentMarkUncheckedUpdateManyWithoutEnrollmentNestedInput = {
    create?: XOR<StudentMarkCreateWithoutEnrollmentInput, StudentMarkUncheckedCreateWithoutEnrollmentInput> | StudentMarkCreateWithoutEnrollmentInput[] | StudentMarkUncheckedCreateWithoutEnrollmentInput[]
    connectOrCreate?: StudentMarkCreateOrConnectWithoutEnrollmentInput | StudentMarkCreateOrConnectWithoutEnrollmentInput[]
    upsert?: StudentMarkUpsertWithWhereUniqueWithoutEnrollmentInput | StudentMarkUpsertWithWhereUniqueWithoutEnrollmentInput[]
    createMany?: StudentMarkCreateManyEnrollmentInputEnvelope
    set?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    disconnect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    delete?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    connect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    update?: StudentMarkUpdateWithWhereUniqueWithoutEnrollmentInput | StudentMarkUpdateWithWhereUniqueWithoutEnrollmentInput[]
    updateMany?: StudentMarkUpdateManyWithWhereWithoutEnrollmentInput | StudentMarkUpdateManyWithWhereWithoutEnrollmentInput[]
    deleteMany?: StudentMarkScalarWhereInput | StudentMarkScalarWhereInput[]
  }

  export type CourseOfferingCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<CourseOfferingCreateWithoutAttendancesInput, CourseOfferingUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutAttendancesInput
    connect?: CourseOfferingWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<TeacherCreateWithoutAttendancesInput, TeacherUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAttendancesInput
    connect?: TeacherWhereUniqueInput
  }

  export type AttendanceRecordCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<AttendanceRecordCreateWithoutAttendanceInput, AttendanceRecordUncheckedCreateWithoutAttendanceInput> | AttendanceRecordCreateWithoutAttendanceInput[] | AttendanceRecordUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutAttendanceInput | AttendanceRecordCreateOrConnectWithoutAttendanceInput[]
    createMany?: AttendanceRecordCreateManyAttendanceInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<AttendanceRecordCreateWithoutAttendanceInput, AttendanceRecordUncheckedCreateWithoutAttendanceInput> | AttendanceRecordCreateWithoutAttendanceInput[] | AttendanceRecordUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutAttendanceInput | AttendanceRecordCreateOrConnectWithoutAttendanceInput[]
    createMany?: AttendanceRecordCreateManyAttendanceInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CourseOfferingUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutAttendancesInput, CourseOfferingUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutAttendancesInput
    upsert?: CourseOfferingUpsertWithoutAttendancesInput
    disconnect?: CourseOfferingWhereInput | boolean
    delete?: CourseOfferingWhereInput | boolean
    connect?: CourseOfferingWhereUniqueInput
    update?: XOR<XOR<CourseOfferingUpdateToOneWithWhereWithoutAttendancesInput, CourseOfferingUpdateWithoutAttendancesInput>, CourseOfferingUncheckedUpdateWithoutAttendancesInput>
  }

  export type TeacherUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<TeacherCreateWithoutAttendancesInput, TeacherUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAttendancesInput
    upsert?: TeacherUpsertWithoutAttendancesInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutAttendancesInput, TeacherUpdateWithoutAttendancesInput>, TeacherUncheckedUpdateWithoutAttendancesInput>
  }

  export type AttendanceRecordUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutAttendanceInput, AttendanceRecordUncheckedCreateWithoutAttendanceInput> | AttendanceRecordCreateWithoutAttendanceInput[] | AttendanceRecordUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutAttendanceInput | AttendanceRecordCreateOrConnectWithoutAttendanceInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutAttendanceInput | AttendanceRecordUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: AttendanceRecordCreateManyAttendanceInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutAttendanceInput | AttendanceRecordUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutAttendanceInput | AttendanceRecordUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutAttendanceInput, AttendanceRecordUncheckedCreateWithoutAttendanceInput> | AttendanceRecordCreateWithoutAttendanceInput[] | AttendanceRecordUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutAttendanceInput | AttendanceRecordCreateOrConnectWithoutAttendanceInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutAttendanceInput | AttendanceRecordUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: AttendanceRecordCreateManyAttendanceInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutAttendanceInput | AttendanceRecordUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutAttendanceInput | AttendanceRecordUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AttendanceCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<AttendanceCreateWithoutAttendanceRecordsInput, AttendanceUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutAttendanceRecordsInput
    connect?: AttendanceWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type NullableEnumattendance_statusFieldUpdateOperationsInput = {
    set?: $Enums.attendance_status | null
  }

  export type AttendanceUpdateOneWithoutAttendanceRecordsNestedInput = {
    create?: XOR<AttendanceCreateWithoutAttendanceRecordsInput, AttendanceUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: AttendanceCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: AttendanceUpsertWithoutAttendanceRecordsInput
    disconnect?: AttendanceWhereInput | boolean
    delete?: AttendanceWhereInput | boolean
    connect?: AttendanceWhereUniqueInput
    update?: XOR<XOR<AttendanceUpdateToOneWithWhereWithoutAttendanceRecordsInput, AttendanceUpdateWithoutAttendanceRecordsInput>, AttendanceUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type StudentUpdateOneWithoutAttendanceRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: StudentUpsertWithoutAttendanceRecordsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendanceRecordsInput, StudentUpdateWithoutAttendanceRecordsInput>, StudentUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserCreateNestedOneWithoutReportViewerInput = {
    create?: XOR<UserCreateWithoutReportViewerInput, UserUncheckedCreateWithoutReportViewerInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportViewerInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReportViewerNestedInput = {
    create?: XOR<UserCreateWithoutReportViewerInput, UserUncheckedCreateWithoutReportViewerInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportViewerInput
    upsert?: UserUpsertWithoutReportViewerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportViewerInput, UserUpdateWithoutReportViewerInput>, UserUncheckedUpdateWithoutReportViewerInput>
  }

  export type CollegeCreateNestedOneWithoutAcademic_yearsInput = {
    create?: XOR<CollegeCreateWithoutAcademic_yearsInput, CollegeUncheckedCreateWithoutAcademic_yearsInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutAcademic_yearsInput
    connect?: CollegeWhereUniqueInput
  }

  export type CourseOfferingCreateNestedManyWithoutAcademic_yearsInput = {
    create?: XOR<CourseOfferingCreateWithoutAcademic_yearsInput, CourseOfferingUncheckedCreateWithoutAcademic_yearsInput> | CourseOfferingCreateWithoutAcademic_yearsInput[] | CourseOfferingUncheckedCreateWithoutAcademic_yearsInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutAcademic_yearsInput | CourseOfferingCreateOrConnectWithoutAcademic_yearsInput[]
    createMany?: CourseOfferingCreateManyAcademic_yearsInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type StudentEnrollmentCreateNestedManyWithoutAcademic_yearsInput = {
    create?: XOR<StudentEnrollmentCreateWithoutAcademic_yearsInput, StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput> | StudentEnrollmentCreateWithoutAcademic_yearsInput[] | StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutAcademic_yearsInput | StudentEnrollmentCreateOrConnectWithoutAcademic_yearsInput[]
    createMany?: StudentEnrollmentCreateManyAcademic_yearsInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type CourseOfferingUncheckedCreateNestedManyWithoutAcademic_yearsInput = {
    create?: XOR<CourseOfferingCreateWithoutAcademic_yearsInput, CourseOfferingUncheckedCreateWithoutAcademic_yearsInput> | CourseOfferingCreateWithoutAcademic_yearsInput[] | CourseOfferingUncheckedCreateWithoutAcademic_yearsInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutAcademic_yearsInput | CourseOfferingCreateOrConnectWithoutAcademic_yearsInput[]
    createMany?: CourseOfferingCreateManyAcademic_yearsInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type StudentEnrollmentUncheckedCreateNestedManyWithoutAcademic_yearsInput = {
    create?: XOR<StudentEnrollmentCreateWithoutAcademic_yearsInput, StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput> | StudentEnrollmentCreateWithoutAcademic_yearsInput[] | StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutAcademic_yearsInput | StudentEnrollmentCreateOrConnectWithoutAcademic_yearsInput[]
    createMany?: StudentEnrollmentCreateManyAcademic_yearsInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CollegeUpdateOneRequiredWithoutAcademic_yearsNestedInput = {
    create?: XOR<CollegeCreateWithoutAcademic_yearsInput, CollegeUncheckedCreateWithoutAcademic_yearsInput>
    connectOrCreate?: CollegeCreateOrConnectWithoutAcademic_yearsInput
    upsert?: CollegeUpsertWithoutAcademic_yearsInput
    connect?: CollegeWhereUniqueInput
    update?: XOR<XOR<CollegeUpdateToOneWithWhereWithoutAcademic_yearsInput, CollegeUpdateWithoutAcademic_yearsInput>, CollegeUncheckedUpdateWithoutAcademic_yearsInput>
  }

  export type CourseOfferingUpdateManyWithoutAcademic_yearsNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutAcademic_yearsInput, CourseOfferingUncheckedCreateWithoutAcademic_yearsInput> | CourseOfferingCreateWithoutAcademic_yearsInput[] | CourseOfferingUncheckedCreateWithoutAcademic_yearsInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutAcademic_yearsInput | CourseOfferingCreateOrConnectWithoutAcademic_yearsInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutAcademic_yearsInput | CourseOfferingUpsertWithWhereUniqueWithoutAcademic_yearsInput[]
    createMany?: CourseOfferingCreateManyAcademic_yearsInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutAcademic_yearsInput | CourseOfferingUpdateWithWhereUniqueWithoutAcademic_yearsInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutAcademic_yearsInput | CourseOfferingUpdateManyWithWhereWithoutAcademic_yearsInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type StudentEnrollmentUpdateManyWithoutAcademic_yearsNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutAcademic_yearsInput, StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput> | StudentEnrollmentCreateWithoutAcademic_yearsInput[] | StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutAcademic_yearsInput | StudentEnrollmentCreateOrConnectWithoutAcademic_yearsInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutAcademic_yearsInput | StudentEnrollmentUpsertWithWhereUniqueWithoutAcademic_yearsInput[]
    createMany?: StudentEnrollmentCreateManyAcademic_yearsInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutAcademic_yearsInput | StudentEnrollmentUpdateWithWhereUniqueWithoutAcademic_yearsInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutAcademic_yearsInput | StudentEnrollmentUpdateManyWithWhereWithoutAcademic_yearsInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type CourseOfferingUncheckedUpdateManyWithoutAcademic_yearsNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutAcademic_yearsInput, CourseOfferingUncheckedCreateWithoutAcademic_yearsInput> | CourseOfferingCreateWithoutAcademic_yearsInput[] | CourseOfferingUncheckedCreateWithoutAcademic_yearsInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutAcademic_yearsInput | CourseOfferingCreateOrConnectWithoutAcademic_yearsInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutAcademic_yearsInput | CourseOfferingUpsertWithWhereUniqueWithoutAcademic_yearsInput[]
    createMany?: CourseOfferingCreateManyAcademic_yearsInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutAcademic_yearsInput | CourseOfferingUpdateWithWhereUniqueWithoutAcademic_yearsInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutAcademic_yearsInput | CourseOfferingUpdateManyWithWhereWithoutAcademic_yearsInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutAcademic_yearsNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutAcademic_yearsInput, StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput> | StudentEnrollmentCreateWithoutAcademic_yearsInput[] | StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutAcademic_yearsInput | StudentEnrollmentCreateOrConnectWithoutAcademic_yearsInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutAcademic_yearsInput | StudentEnrollmentUpsertWithWhereUniqueWithoutAcademic_yearsInput[]
    createMany?: StudentEnrollmentCreateManyAcademic_yearsInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutAcademic_yearsInput | StudentEnrollmentUpdateWithWhereUniqueWithoutAcademic_yearsInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutAcademic_yearsInput | StudentEnrollmentUpdateManyWithWhereWithoutAcademic_yearsInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type CourseOfferingCreateNestedManyWithoutSectionsInput = {
    create?: XOR<CourseOfferingCreateWithoutSectionsInput, CourseOfferingUncheckedCreateWithoutSectionsInput> | CourseOfferingCreateWithoutSectionsInput[] | CourseOfferingUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutSectionsInput | CourseOfferingCreateOrConnectWithoutSectionsInput[]
    createMany?: CourseOfferingCreateManySectionsInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutSectionsInput = {
    create?: XOR<DepartmentCreateWithoutSectionsInput, DepartmentUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSectionsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutSectionsInput = {
    create?: XOR<StudentCreateWithoutSectionsInput, StudentUncheckedCreateWithoutSectionsInput> | StudentCreateWithoutSectionsInput[] | StudentUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSectionsInput | StudentCreateOrConnectWithoutSectionsInput[]
    createMany?: StudentCreateManySectionsInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type CourseOfferingUncheckedCreateNestedManyWithoutSectionsInput = {
    create?: XOR<CourseOfferingCreateWithoutSectionsInput, CourseOfferingUncheckedCreateWithoutSectionsInput> | CourseOfferingCreateWithoutSectionsInput[] | CourseOfferingUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutSectionsInput | CourseOfferingCreateOrConnectWithoutSectionsInput[]
    createMany?: CourseOfferingCreateManySectionsInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutSectionsInput = {
    create?: XOR<StudentCreateWithoutSectionsInput, StudentUncheckedCreateWithoutSectionsInput> | StudentCreateWithoutSectionsInput[] | StudentUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSectionsInput | StudentCreateOrConnectWithoutSectionsInput[]
    createMany?: StudentCreateManySectionsInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type CourseOfferingUpdateManyWithoutSectionsNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutSectionsInput, CourseOfferingUncheckedCreateWithoutSectionsInput> | CourseOfferingCreateWithoutSectionsInput[] | CourseOfferingUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutSectionsInput | CourseOfferingCreateOrConnectWithoutSectionsInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutSectionsInput | CourseOfferingUpsertWithWhereUniqueWithoutSectionsInput[]
    createMany?: CourseOfferingCreateManySectionsInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutSectionsInput | CourseOfferingUpdateWithWhereUniqueWithoutSectionsInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutSectionsInput | CourseOfferingUpdateManyWithWhereWithoutSectionsInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type DepartmentUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<DepartmentCreateWithoutSectionsInput, DepartmentUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSectionsInput
    upsert?: DepartmentUpsertWithoutSectionsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutSectionsInput, DepartmentUpdateWithoutSectionsInput>, DepartmentUncheckedUpdateWithoutSectionsInput>
  }

  export type StudentUpdateManyWithoutSectionsNestedInput = {
    create?: XOR<StudentCreateWithoutSectionsInput, StudentUncheckedCreateWithoutSectionsInput> | StudentCreateWithoutSectionsInput[] | StudentUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSectionsInput | StudentCreateOrConnectWithoutSectionsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSectionsInput | StudentUpsertWithWhereUniqueWithoutSectionsInput[]
    createMany?: StudentCreateManySectionsInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSectionsInput | StudentUpdateWithWhereUniqueWithoutSectionsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSectionsInput | StudentUpdateManyWithWhereWithoutSectionsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type CourseOfferingUncheckedUpdateManyWithoutSectionsNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutSectionsInput, CourseOfferingUncheckedCreateWithoutSectionsInput> | CourseOfferingCreateWithoutSectionsInput[] | CourseOfferingUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutSectionsInput | CourseOfferingCreateOrConnectWithoutSectionsInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutSectionsInput | CourseOfferingUpsertWithWhereUniqueWithoutSectionsInput[]
    createMany?: CourseOfferingCreateManySectionsInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutSectionsInput | CourseOfferingUpdateWithWhereUniqueWithoutSectionsInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutSectionsInput | CourseOfferingUpdateManyWithWhereWithoutSectionsInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutSectionsNestedInput = {
    create?: XOR<StudentCreateWithoutSectionsInput, StudentUncheckedCreateWithoutSectionsInput> | StudentCreateWithoutSectionsInput[] | StudentUncheckedCreateWithoutSectionsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSectionsInput | StudentCreateOrConnectWithoutSectionsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSectionsInput | StudentUpsertWithWhereUniqueWithoutSectionsInput[]
    createMany?: StudentCreateManySectionsInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSectionsInput | StudentUpdateWithWhereUniqueWithoutSectionsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSectionsInput | StudentUpdateManyWithWhereWithoutSectionsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type CourseOfferingCreateNestedOneWithoutTestComponentsInput = {
    create?: XOR<CourseOfferingCreateWithoutTestComponentsInput, CourseOfferingUncheckedCreateWithoutTestComponentsInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTestComponentsInput
    connect?: CourseOfferingWhereUniqueInput
  }

  export type StudentMarkCreateNestedManyWithoutTestComponentInput = {
    create?: XOR<StudentMarkCreateWithoutTestComponentInput, StudentMarkUncheckedCreateWithoutTestComponentInput> | StudentMarkCreateWithoutTestComponentInput[] | StudentMarkUncheckedCreateWithoutTestComponentInput[]
    connectOrCreate?: StudentMarkCreateOrConnectWithoutTestComponentInput | StudentMarkCreateOrConnectWithoutTestComponentInput[]
    createMany?: StudentMarkCreateManyTestComponentInputEnvelope
    connect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
  }

  export type StudentMarkUncheckedCreateNestedManyWithoutTestComponentInput = {
    create?: XOR<StudentMarkCreateWithoutTestComponentInput, StudentMarkUncheckedCreateWithoutTestComponentInput> | StudentMarkCreateWithoutTestComponentInput[] | StudentMarkUncheckedCreateWithoutTestComponentInput[]
    connectOrCreate?: StudentMarkCreateOrConnectWithoutTestComponentInput | StudentMarkCreateOrConnectWithoutTestComponentInput[]
    createMany?: StudentMarkCreateManyTestComponentInputEnvelope
    connect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
  }

  export type CourseOfferingUpdateOneRequiredWithoutTestComponentsNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutTestComponentsInput, CourseOfferingUncheckedCreateWithoutTestComponentsInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutTestComponentsInput
    upsert?: CourseOfferingUpsertWithoutTestComponentsInput
    connect?: CourseOfferingWhereUniqueInput
    update?: XOR<XOR<CourseOfferingUpdateToOneWithWhereWithoutTestComponentsInput, CourseOfferingUpdateWithoutTestComponentsInput>, CourseOfferingUncheckedUpdateWithoutTestComponentsInput>
  }

  export type StudentMarkUpdateManyWithoutTestComponentNestedInput = {
    create?: XOR<StudentMarkCreateWithoutTestComponentInput, StudentMarkUncheckedCreateWithoutTestComponentInput> | StudentMarkCreateWithoutTestComponentInput[] | StudentMarkUncheckedCreateWithoutTestComponentInput[]
    connectOrCreate?: StudentMarkCreateOrConnectWithoutTestComponentInput | StudentMarkCreateOrConnectWithoutTestComponentInput[]
    upsert?: StudentMarkUpsertWithWhereUniqueWithoutTestComponentInput | StudentMarkUpsertWithWhereUniqueWithoutTestComponentInput[]
    createMany?: StudentMarkCreateManyTestComponentInputEnvelope
    set?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    disconnect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    delete?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    connect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    update?: StudentMarkUpdateWithWhereUniqueWithoutTestComponentInput | StudentMarkUpdateWithWhereUniqueWithoutTestComponentInput[]
    updateMany?: StudentMarkUpdateManyWithWhereWithoutTestComponentInput | StudentMarkUpdateManyWithWhereWithoutTestComponentInput[]
    deleteMany?: StudentMarkScalarWhereInput | StudentMarkScalarWhereInput[]
  }

  export type StudentMarkUncheckedUpdateManyWithoutTestComponentNestedInput = {
    create?: XOR<StudentMarkCreateWithoutTestComponentInput, StudentMarkUncheckedCreateWithoutTestComponentInput> | StudentMarkCreateWithoutTestComponentInput[] | StudentMarkUncheckedCreateWithoutTestComponentInput[]
    connectOrCreate?: StudentMarkCreateOrConnectWithoutTestComponentInput | StudentMarkCreateOrConnectWithoutTestComponentInput[]
    upsert?: StudentMarkUpsertWithWhereUniqueWithoutTestComponentInput | StudentMarkUpsertWithWhereUniqueWithoutTestComponentInput[]
    createMany?: StudentMarkCreateManyTestComponentInputEnvelope
    set?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    disconnect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    delete?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    connect?: StudentMarkWhereUniqueInput | StudentMarkWhereUniqueInput[]
    update?: StudentMarkUpdateWithWhereUniqueWithoutTestComponentInput | StudentMarkUpdateWithWhereUniqueWithoutTestComponentInput[]
    updateMany?: StudentMarkUpdateManyWithWhereWithoutTestComponentInput | StudentMarkUpdateManyWithWhereWithoutTestComponentInput[]
    deleteMany?: StudentMarkScalarWhereInput | StudentMarkScalarWhereInput[]
  }

  export type StudentEnrollmentCreateNestedOneWithoutStudentMarksInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentMarksInput, StudentEnrollmentUncheckedCreateWithoutStudentMarksInput>
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentMarksInput
    connect?: StudentEnrollmentWhereUniqueInput
  }

  export type TestComponentCreateNestedOneWithoutStudentMarksInput = {
    create?: XOR<TestComponentCreateWithoutStudentMarksInput, TestComponentUncheckedCreateWithoutStudentMarksInput>
    connectOrCreate?: TestComponentCreateOrConnectWithoutStudentMarksInput
    connect?: TestComponentWhereUniqueInput
  }

  export type StudentEnrollmentUpdateOneRequiredWithoutStudentMarksNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentMarksInput, StudentEnrollmentUncheckedCreateWithoutStudentMarksInput>
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentMarksInput
    upsert?: StudentEnrollmentUpsertWithoutStudentMarksInput
    connect?: StudentEnrollmentWhereUniqueInput
    update?: XOR<XOR<StudentEnrollmentUpdateToOneWithWhereWithoutStudentMarksInput, StudentEnrollmentUpdateWithoutStudentMarksInput>, StudentEnrollmentUncheckedUpdateWithoutStudentMarksInput>
  }

  export type TestComponentUpdateOneRequiredWithoutStudentMarksNestedInput = {
    create?: XOR<TestComponentCreateWithoutStudentMarksInput, TestComponentUncheckedCreateWithoutStudentMarksInput>
    connectOrCreate?: TestComponentCreateOrConnectWithoutStudentMarksInput
    upsert?: TestComponentUpsertWithoutStudentMarksInput
    connect?: TestComponentWhereUniqueInput
    update?: XOR<XOR<TestComponentUpdateToOneWithWhereWithoutStudentMarksInput, TestComponentUpdateWithoutStudentMarksInput>, TestComponentUncheckedUpdateWithoutStudentMarksInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type NestedEnumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumcourse_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.course_type | Enumcourse_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.course_type[] | ListEnumcourse_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.course_type[] | ListEnumcourse_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcourse_typeNullableFilter<$PrismaModel> | $Enums.course_type | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumcourse_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.course_type | Enumcourse_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.course_type[] | ListEnumcourse_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.course_type[] | ListEnumcourse_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcourse_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.course_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcourse_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumcourse_typeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumattendance_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.attendance_status | Enumattendance_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumattendance_statusNullableFilter<$PrismaModel> | $Enums.attendance_status | null
  }

  export type NestedEnumattendance_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attendance_status | Enumattendance_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumattendance_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.attendance_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumattendance_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumattendance_statusNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type academic_yearsCreateWithoutCollegesInput = {
    year_id?: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    course_offerings?: CourseOfferingCreateNestedManyWithoutAcademic_yearsInput
    student_enrollments?: StudentEnrollmentCreateNestedManyWithoutAcademic_yearsInput
  }

  export type academic_yearsUncheckedCreateWithoutCollegesInput = {
    year_id?: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    course_offerings?: CourseOfferingUncheckedCreateNestedManyWithoutAcademic_yearsInput
    student_enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutAcademic_yearsInput
  }

  export type academic_yearsCreateOrConnectWithoutCollegesInput = {
    where: academic_yearsWhereUniqueInput
    create: XOR<academic_yearsCreateWithoutCollegesInput, academic_yearsUncheckedCreateWithoutCollegesInput>
  }

  export type academic_yearsCreateManyCollegesInputEnvelope = {
    data: academic_yearsCreateManyCollegesInput | academic_yearsCreateManyCollegesInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCollegesInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberCreateNestedManyWithoutCourseInput
    courseOfferings?: CourseOfferingCreateNestedManyWithoutCourseInput
    department?: DepartmentCreateNestedOneWithoutCoursesInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCollegesInput = {
    id?: string
    code: string
    name: string
    departmentId?: string | null
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutCourseInput
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCollegesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCollegesInput, CourseUncheckedCreateWithoutCollegesInput>
  }

  export type CourseCreateManyCollegesInputEnvelope = {
    data: CourseCreateManyCollegesInput | CourseCreateManyCollegesInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentElectiveGroupCreateWithoutCollegesInput = {
    id?: string
    name: string
    semester: number
    batchYear: number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberCreateNestedManyWithoutGroupInput
    department: DepartmentCreateNestedOneWithoutDepartmentElectiveGroupsInput
  }

  export type DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput = {
    id?: string
    name: string
    departmentId: string
    semester: number
    batchYear: number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type DepartmentElectiveGroupCreateOrConnectWithoutCollegesInput = {
    where: DepartmentElectiveGroupWhereUniqueInput
    create: XOR<DepartmentElectiveGroupCreateWithoutCollegesInput, DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput>
  }

  export type DepartmentElectiveGroupCreateManyCollegesInputEnvelope = {
    data: DepartmentElectiveGroupCreateManyCollegesInput | DepartmentElectiveGroupCreateManyCollegesInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutCollegesInput = {
    id?: string
    name: string
    code?: string | null
    courses?: CourseCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupCreateNestedManyWithoutDepartmentInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsCreateNestedManyWithoutDepartmentsInput
    students?: StudentCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutCollegesInput = {
    id?: string
    name: string
    code?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutDepartmentInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsUncheckedCreateNestedManyWithoutDepartmentsInput
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutCollegesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutCollegesInput, DepartmentUncheckedCreateWithoutCollegesInput>
  }

  export type DepartmentCreateManyCollegesInputEnvelope = {
    data: DepartmentCreateManyCollegesInput | DepartmentCreateManyCollegesInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutCollegesInput = {
    id?: string
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    departments?: DepartmentCreateNestedOneWithoutStudentsInput
    sections?: sectionsCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCollegesInput = {
    id?: string
    userId: string
    department_id?: string | null
    section_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCollegesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCollegesInput, StudentUncheckedCreateWithoutCollegesInput>
  }

  export type StudentCreateManyCollegesInputEnvelope = {
    data: StudentCreateManyCollegesInput | StudentCreateManyCollegesInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutCollegesInput = {
    id?: string
    attendances?: AttendanceCreateNestedManyWithoutTeacherInput
    courseOfferings?: CourseOfferingCreateNestedManyWithoutTeacherInput
    department?: DepartmentCreateNestedOneWithoutTeachersInput
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCollegesInput = {
    id?: string
    userId: string
    departmentId?: string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTeacherInput
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCollegesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCollegesInput, TeacherUncheckedCreateWithoutCollegesInput>
  }

  export type TeacherCreateManyCollegesInputEnvelope = {
    data: TeacherCreateManyCollegesInput | TeacherCreateManyCollegesInput[]
    skipDuplicates?: boolean
  }

  export type academic_yearsUpsertWithWhereUniqueWithoutCollegesInput = {
    where: academic_yearsWhereUniqueInput
    update: XOR<academic_yearsUpdateWithoutCollegesInput, academic_yearsUncheckedUpdateWithoutCollegesInput>
    create: XOR<academic_yearsCreateWithoutCollegesInput, academic_yearsUncheckedCreateWithoutCollegesInput>
  }

  export type academic_yearsUpdateWithWhereUniqueWithoutCollegesInput = {
    where: academic_yearsWhereUniqueInput
    data: XOR<academic_yearsUpdateWithoutCollegesInput, academic_yearsUncheckedUpdateWithoutCollegesInput>
  }

  export type academic_yearsUpdateManyWithWhereWithoutCollegesInput = {
    where: academic_yearsScalarWhereInput
    data: XOR<academic_yearsUpdateManyMutationInput, academic_yearsUncheckedUpdateManyWithoutCollegesInput>
  }

  export type academic_yearsScalarWhereInput = {
    AND?: academic_yearsScalarWhereInput | academic_yearsScalarWhereInput[]
    OR?: academic_yearsScalarWhereInput[]
    NOT?: academic_yearsScalarWhereInput | academic_yearsScalarWhereInput[]
    year_id?: UuidFilter<"academic_years"> | string
    college_id?: UuidFilter<"academic_years"> | string
    year_name?: StringFilter<"academic_years"> | string
    start_date?: DateTimeNullableFilter<"academic_years"> | Date | string | null
    end_date?: DateTimeNullableFilter<"academic_years"> | Date | string | null
    is_active?: BoolNullableFilter<"academic_years"> | boolean | null
  }

  export type CourseUpsertWithWhereUniqueWithoutCollegesInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCollegesInput, CourseUncheckedUpdateWithoutCollegesInput>
    create: XOR<CourseCreateWithoutCollegesInput, CourseUncheckedCreateWithoutCollegesInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCollegesInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCollegesInput, CourseUncheckedUpdateWithoutCollegesInput>
  }

  export type CourseUpdateManyWithWhereWithoutCollegesInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCollegesInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: UuidFilter<"Course"> | string
    college_id?: UuidFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    departmentId?: UuidNullableFilter<"Course"> | string | null
    type?: Enumcourse_typeNullableFilter<"Course"> | $Enums.course_type | null
    hasTheoryComponent?: BoolFilter<"Course"> | boolean
    hasLabComponent?: BoolFilter<"Course"> | boolean
  }

  export type DepartmentElectiveGroupUpsertWithWhereUniqueWithoutCollegesInput = {
    where: DepartmentElectiveGroupWhereUniqueInput
    update: XOR<DepartmentElectiveGroupUpdateWithoutCollegesInput, DepartmentElectiveGroupUncheckedUpdateWithoutCollegesInput>
    create: XOR<DepartmentElectiveGroupCreateWithoutCollegesInput, DepartmentElectiveGroupUncheckedCreateWithoutCollegesInput>
  }

  export type DepartmentElectiveGroupUpdateWithWhereUniqueWithoutCollegesInput = {
    where: DepartmentElectiveGroupWhereUniqueInput
    data: XOR<DepartmentElectiveGroupUpdateWithoutCollegesInput, DepartmentElectiveGroupUncheckedUpdateWithoutCollegesInput>
  }

  export type DepartmentElectiveGroupUpdateManyWithWhereWithoutCollegesInput = {
    where: DepartmentElectiveGroupScalarWhereInput
    data: XOR<DepartmentElectiveGroupUpdateManyMutationInput, DepartmentElectiveGroupUncheckedUpdateManyWithoutCollegesInput>
  }

  export type DepartmentElectiveGroupScalarWhereInput = {
    AND?: DepartmentElectiveGroupScalarWhereInput | DepartmentElectiveGroupScalarWhereInput[]
    OR?: DepartmentElectiveGroupScalarWhereInput[]
    NOT?: DepartmentElectiveGroupScalarWhereInput | DepartmentElectiveGroupScalarWhereInput[]
    id?: UuidFilter<"DepartmentElectiveGroup"> | string
    college_id?: UuidFilter<"DepartmentElectiveGroup"> | string
    name?: StringFilter<"DepartmentElectiveGroup"> | string
    departmentId?: UuidFilter<"DepartmentElectiveGroup"> | string
    semester?: IntFilter<"DepartmentElectiveGroup"> | number
    batchYear?: IntFilter<"DepartmentElectiveGroup"> | number
  }

  export type DepartmentUpsertWithWhereUniqueWithoutCollegesInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutCollegesInput, DepartmentUncheckedUpdateWithoutCollegesInput>
    create: XOR<DepartmentCreateWithoutCollegesInput, DepartmentUncheckedCreateWithoutCollegesInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutCollegesInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutCollegesInput, DepartmentUncheckedUpdateWithoutCollegesInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutCollegesInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutCollegesInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: UuidFilter<"Department"> | string
    college_id?: UuidFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
  }

  export type StudentUpsertWithWhereUniqueWithoutCollegesInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutCollegesInput, StudentUncheckedUpdateWithoutCollegesInput>
    create: XOR<StudentCreateWithoutCollegesInput, StudentUncheckedCreateWithoutCollegesInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutCollegesInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutCollegesInput, StudentUncheckedUpdateWithoutCollegesInput>
  }

  export type StudentUpdateManyWithWhereWithoutCollegesInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutCollegesInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: UuidFilter<"Student"> | string
    userId?: UuidFilter<"Student"> | string
    college_id?: UuidFilter<"Student"> | string
    department_id?: UuidNullableFilter<"Student"> | string | null
    section_id?: UuidNullableFilter<"Student"> | string | null
    usn?: StringFilter<"Student"> | string
    semester?: IntNullableFilter<"Student"> | number | null
    batchYear?: IntFilter<"Student"> | number
  }

  export type TeacherUpsertWithWhereUniqueWithoutCollegesInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutCollegesInput, TeacherUncheckedUpdateWithoutCollegesInput>
    create: XOR<TeacherCreateWithoutCollegesInput, TeacherUncheckedCreateWithoutCollegesInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutCollegesInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutCollegesInput, TeacherUncheckedUpdateWithoutCollegesInput>
  }

  export type TeacherUpdateManyWithWhereWithoutCollegesInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutCollegesInput>
  }

  export type TeacherScalarWhereInput = {
    AND?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    OR?: TeacherScalarWhereInput[]
    NOT?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    id?: UuidFilter<"Teacher"> | string
    userId?: UuidFilter<"Teacher"> | string
    college_id?: UuidFilter<"Teacher"> | string
    departmentId?: UuidNullableFilter<"Teacher"> | string | null
  }

  export type CourseCreateWithoutDepartmentInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberCreateNestedManyWithoutCourseInput
    courseOfferings?: CourseOfferingCreateNestedManyWithoutCourseInput
    colleges: CollegeCreateNestedOneWithoutCoursesInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutDepartmentInput = {
    id?: string
    college_id: string
    code: string
    name: string
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutCourseInput
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput>
  }

  export type CourseCreateManyDepartmentInputEnvelope = {
    data: CourseCreateManyDepartmentInput | CourseCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentElectiveGroupCreateWithoutDepartmentInput = {
    id?: string
    name: string
    semester: number
    batchYear: number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberCreateNestedManyWithoutGroupInput
    colleges: CollegeCreateNestedOneWithoutDepartment_elective_groupsInput
  }

  export type DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput = {
    id?: string
    college_id: string
    name: string
    semester: number
    batchYear: number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type DepartmentElectiveGroupCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentElectiveGroupWhereUniqueInput
    create: XOR<DepartmentElectiveGroupCreateWithoutDepartmentInput, DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentElectiveGroupCreateManyDepartmentInputEnvelope = {
    data: DepartmentElectiveGroupCreateManyDepartmentInput | DepartmentElectiveGroupCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type CollegeCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsCreateNestedManyWithoutCollegesInput
    courses?: CourseCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupCreateNestedManyWithoutCollegesInput
    students?: StudentCreateNestedManyWithoutCollegesInput
    teachers?: TeacherCreateNestedManyWithoutCollegesInput
  }

  export type CollegeUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsUncheckedCreateNestedManyWithoutCollegesInput
    courses?: CourseUncheckedCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutCollegesInput
    students?: StudentUncheckedCreateNestedManyWithoutCollegesInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutCollegesInput
  }

  export type CollegeCreateOrConnectWithoutDepartmentsInput = {
    where: CollegeWhereUniqueInput
    create: XOR<CollegeCreateWithoutDepartmentsInput, CollegeUncheckedCreateWithoutDepartmentsInput>
  }

  export type OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput = {
    id?: string
    course?: CourseCreateNestedOneWithoutOpenElectiveRestrictionsInput
  }

  export type OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput = {
    id?: string
    courseId?: string | null
  }

  export type OpenElectiveRestrictionCreateOrConnectWithoutRestrictedDepartmentInput = {
    where: OpenElectiveRestrictionWhereUniqueInput
    create: XOR<OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput, OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput>
  }

  export type OpenElectiveRestrictionCreateManyRestrictedDepartmentInputEnvelope = {
    data: OpenElectiveRestrictionCreateManyRestrictedDepartmentInput | OpenElectiveRestrictionCreateManyRestrictedDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type sectionsCreateWithoutDepartmentsInput = {
    section_id?: string
    section_name: string
    course_offerings?: CourseOfferingCreateNestedManyWithoutSectionsInput
    students?: StudentCreateNestedManyWithoutSectionsInput
  }

  export type sectionsUncheckedCreateWithoutDepartmentsInput = {
    section_id?: string
    section_name: string
    course_offerings?: CourseOfferingUncheckedCreateNestedManyWithoutSectionsInput
    students?: StudentUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type sectionsCreateOrConnectWithoutDepartmentsInput = {
    where: sectionsWhereUniqueInput
    create: XOR<sectionsCreateWithoutDepartmentsInput, sectionsUncheckedCreateWithoutDepartmentsInput>
  }

  export type sectionsCreateManyDepartmentsInputEnvelope = {
    data: sectionsCreateManyDepartmentsInput | sectionsCreateManyDepartmentsInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutDepartmentsInput = {
    id?: string
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    colleges: CollegeCreateNestedOneWithoutStudentsInput
    sections?: sectionsCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    userId: string
    college_id: string
    section_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutDepartmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutDepartmentsInput, StudentUncheckedCreateWithoutDepartmentsInput>
  }

  export type StudentCreateManyDepartmentsInputEnvelope = {
    data: StudentCreateManyDepartmentsInput | StudentCreateManyDepartmentsInput[]
    skipDuplicates?: boolean
  }

  export type TeacherCreateWithoutDepartmentInput = {
    id?: string
    attendances?: AttendanceCreateNestedManyWithoutTeacherInput
    courseOfferings?: CourseOfferingCreateNestedManyWithoutTeacherInput
    colleges: CollegeCreateNestedOneWithoutTeachersInput
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    college_id: string
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTeacherInput
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutDepartmentInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput>
  }

  export type TeacherCreateManyDepartmentInputEnvelope = {
    data: TeacherCreateManyDepartmentInput | TeacherCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutDepartmentInput, CourseUncheckedUpdateWithoutDepartmentInput>
    create: XOR<CourseCreateWithoutDepartmentInput, CourseUncheckedCreateWithoutDepartmentInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutDepartmentInput, CourseUncheckedUpdateWithoutDepartmentInput>
  }

  export type CourseUpdateManyWithWhereWithoutDepartmentInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentElectiveGroupUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentElectiveGroupWhereUniqueInput
    update: XOR<DepartmentElectiveGroupUpdateWithoutDepartmentInput, DepartmentElectiveGroupUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentElectiveGroupCreateWithoutDepartmentInput, DepartmentElectiveGroupUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentElectiveGroupUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentElectiveGroupWhereUniqueInput
    data: XOR<DepartmentElectiveGroupUpdateWithoutDepartmentInput, DepartmentElectiveGroupUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentElectiveGroupUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentElectiveGroupScalarWhereInput
    data: XOR<DepartmentElectiveGroupUpdateManyMutationInput, DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type CollegeUpsertWithoutDepartmentsInput = {
    update: XOR<CollegeUpdateWithoutDepartmentsInput, CollegeUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<CollegeCreateWithoutDepartmentsInput, CollegeUncheckedCreateWithoutDepartmentsInput>
    where?: CollegeWhereInput
  }

  export type CollegeUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: CollegeWhereInput
    data: XOR<CollegeUpdateWithoutDepartmentsInput, CollegeUncheckedUpdateWithoutDepartmentsInput>
  }

  export type CollegeUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUpdateManyWithoutCollegesNestedInput
    courses?: CourseUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUpdateManyWithoutCollegesNestedInput
    students?: StudentUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUpdateManyWithoutCollegesNestedInput
  }

  export type CollegeUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUncheckedUpdateManyWithoutCollegesNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutCollegesNestedInput
    students?: StudentUncheckedUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutCollegesNestedInput
  }

  export type OpenElectiveRestrictionUpsertWithWhereUniqueWithoutRestrictedDepartmentInput = {
    where: OpenElectiveRestrictionWhereUniqueInput
    update: XOR<OpenElectiveRestrictionUpdateWithoutRestrictedDepartmentInput, OpenElectiveRestrictionUncheckedUpdateWithoutRestrictedDepartmentInput>
    create: XOR<OpenElectiveRestrictionCreateWithoutRestrictedDepartmentInput, OpenElectiveRestrictionUncheckedCreateWithoutRestrictedDepartmentInput>
  }

  export type OpenElectiveRestrictionUpdateWithWhereUniqueWithoutRestrictedDepartmentInput = {
    where: OpenElectiveRestrictionWhereUniqueInput
    data: XOR<OpenElectiveRestrictionUpdateWithoutRestrictedDepartmentInput, OpenElectiveRestrictionUncheckedUpdateWithoutRestrictedDepartmentInput>
  }

  export type OpenElectiveRestrictionUpdateManyWithWhereWithoutRestrictedDepartmentInput = {
    where: OpenElectiveRestrictionScalarWhereInput
    data: XOR<OpenElectiveRestrictionUpdateManyMutationInput, OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentInput>
  }

  export type OpenElectiveRestrictionScalarWhereInput = {
    AND?: OpenElectiveRestrictionScalarWhereInput | OpenElectiveRestrictionScalarWhereInput[]
    OR?: OpenElectiveRestrictionScalarWhereInput[]
    NOT?: OpenElectiveRestrictionScalarWhereInput | OpenElectiveRestrictionScalarWhereInput[]
    id?: UuidFilter<"OpenElectiveRestriction"> | string
    courseId?: UuidNullableFilter<"OpenElectiveRestriction"> | string | null
    restrictedDepartmentId?: UuidFilter<"OpenElectiveRestriction"> | string
  }

  export type sectionsUpsertWithWhereUniqueWithoutDepartmentsInput = {
    where: sectionsWhereUniqueInput
    update: XOR<sectionsUpdateWithoutDepartmentsInput, sectionsUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<sectionsCreateWithoutDepartmentsInput, sectionsUncheckedCreateWithoutDepartmentsInput>
  }

  export type sectionsUpdateWithWhereUniqueWithoutDepartmentsInput = {
    where: sectionsWhereUniqueInput
    data: XOR<sectionsUpdateWithoutDepartmentsInput, sectionsUncheckedUpdateWithoutDepartmentsInput>
  }

  export type sectionsUpdateManyWithWhereWithoutDepartmentsInput = {
    where: sectionsScalarWhereInput
    data: XOR<sectionsUpdateManyMutationInput, sectionsUncheckedUpdateManyWithoutDepartmentsInput>
  }

  export type sectionsScalarWhereInput = {
    AND?: sectionsScalarWhereInput | sectionsScalarWhereInput[]
    OR?: sectionsScalarWhereInput[]
    NOT?: sectionsScalarWhereInput | sectionsScalarWhereInput[]
    section_id?: UuidFilter<"sections"> | string
    department_id?: UuidFilter<"sections"> | string
    section_name?: StringFilter<"sections"> | string
  }

  export type StudentUpsertWithWhereUniqueWithoutDepartmentsInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutDepartmentsInput, StudentUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<StudentCreateWithoutDepartmentsInput, StudentUncheckedCreateWithoutDepartmentsInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutDepartmentsInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutDepartmentsInput, StudentUncheckedUpdateWithoutDepartmentsInput>
  }

  export type StudentUpdateManyWithWhereWithoutDepartmentsInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutDepartmentsInput>
  }

  export type TeacherUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutDepartmentInput, TeacherUncheckedUpdateWithoutDepartmentInput>
    create: XOR<TeacherCreateWithoutDepartmentInput, TeacherUncheckedCreateWithoutDepartmentInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutDepartmentInput, TeacherUncheckedUpdateWithoutDepartmentInput>
  }

  export type TeacherUpdateManyWithWhereWithoutDepartmentInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type ReportViewerCreateWithoutUserInput = {
    id?: string
  }

  export type ReportViewerUncheckedCreateWithoutUserInput = {
    id?: string
  }

  export type ReportViewerCreateOrConnectWithoutUserInput = {
    where: ReportViewerWhereUniqueInput
    create: XOR<ReportViewerCreateWithoutUserInput, ReportViewerUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    colleges: CollegeCreateNestedOneWithoutStudentsInput
    departments?: DepartmentCreateNestedOneWithoutStudentsInput
    sections?: sectionsCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    college_id: string
    department_id?: string | null
    section_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    attendances?: AttendanceCreateNestedManyWithoutTeacherInput
    courseOfferings?: CourseOfferingCreateNestedManyWithoutTeacherInput
    colleges: CollegeCreateNestedOneWithoutTeachersInput
    department?: DepartmentCreateNestedOneWithoutTeachersInput
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    college_id: string
    departmentId?: string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTeacherInput
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type UserRoleAssignmentCreateWithoutUserInput = {
    role: $Enums.user_role
  }

  export type UserRoleAssignmentUncheckedCreateWithoutUserInput = {
    role: $Enums.user_role
  }

  export type UserRoleAssignmentCreateOrConnectWithoutUserInput = {
    where: UserRoleAssignmentWhereUniqueInput
    create: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput>
  }

  export type UserRoleAssignmentCreateManyUserInputEnvelope = {
    data: UserRoleAssignmentCreateManyUserInput | UserRoleAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ReportViewerUpsertWithoutUserInput = {
    update: XOR<ReportViewerUpdateWithoutUserInput, ReportViewerUncheckedUpdateWithoutUserInput>
    create: XOR<ReportViewerCreateWithoutUserInput, ReportViewerUncheckedCreateWithoutUserInput>
    where?: ReportViewerWhereInput
  }

  export type ReportViewerUpdateToOneWithWhereWithoutUserInput = {
    where?: ReportViewerWhereInput
    data: XOR<ReportViewerUpdateWithoutUserInput, ReportViewerUncheckedUpdateWithoutUserInput>
  }

  export type ReportViewerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ReportViewerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutStudentsNestedInput
    departments?: DepartmentUpdateOneWithoutStudentsNestedInput
    sections?: sectionsUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherUpsertWithoutUserInput = {
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutUserInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendances?: AttendanceUpdateManyWithoutTeacherNestedInput
    courseOfferings?: CourseOfferingUpdateManyWithoutTeacherNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutTeachersNestedInput
    department?: DepartmentUpdateOneWithoutTeachersNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutTeacherNestedInput
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleAssignmentWhereUniqueInput
    update: XOR<UserRoleAssignmentUpdateWithoutUserInput, UserRoleAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput>
  }

  export type UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleAssignmentWhereUniqueInput
    data: XOR<UserRoleAssignmentUpdateWithoutUserInput, UserRoleAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleAssignmentScalarWhereInput
    data: XOR<UserRoleAssignmentUpdateManyMutationInput, UserRoleAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleAssignmentScalarWhereInput = {
    AND?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
    OR?: UserRoleAssignmentScalarWhereInput[]
    NOT?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
    userId?: UuidFilter<"UserRoleAssignment"> | string
    role?: Enumuser_roleFilter<"UserRoleAssignment"> | $Enums.user_role
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    reportViewer?: ReportViewerCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    reportViewer?: ReportViewerUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    reportViewer?: ReportViewerUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    reportViewer?: ReportViewerUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AttendanceRecordCreateWithoutStudentInput = {
    id?: string
    status?: $Enums.attendance_status | null
    attendance?: AttendanceCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateWithoutStudentInput = {
    id?: string
    attendanceId?: string | null
    status?: $Enums.attendance_status | null
  }

  export type AttendanceRecordCreateOrConnectWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceRecordCreateManyStudentInputEnvelope = {
    data: AttendanceRecordCreateManyStudentInput | AttendanceRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrollmentCreateWithoutStudentInput = {
    id?: string
    attemptNumber?: number | null
    offering?: CourseOfferingCreateNestedOneWithoutEnrollmentsInput
    academic_years?: academic_yearsCreateNestedOneWithoutStudent_enrollmentsInput
    studentMarks?: StudentMarkCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    offeringId?: string | null
    attemptNumber?: number | null
    year_id?: string | null
    studentMarks?: StudentMarkUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentCreateOrConnectWithoutStudentInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrollmentCreateManyStudentInputEnvelope = {
    data: StudentEnrollmentCreateManyStudentInput | StudentEnrollmentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type CollegeCreateWithoutStudentsInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsCreateNestedManyWithoutCollegesInput
    courses?: CourseCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupCreateNestedManyWithoutCollegesInput
    departments?: DepartmentCreateNestedManyWithoutCollegesInput
    teachers?: TeacherCreateNestedManyWithoutCollegesInput
  }

  export type CollegeUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsUncheckedCreateNestedManyWithoutCollegesInput
    courses?: CourseUncheckedCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutCollegesInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCollegesInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutCollegesInput
  }

  export type CollegeCreateOrConnectWithoutStudentsInput = {
    where: CollegeWhereUniqueInput
    create: XOR<CollegeCreateWithoutStudentsInput, CollegeUncheckedCreateWithoutStudentsInput>
  }

  export type DepartmentCreateWithoutStudentsInput = {
    id?: string
    name: string
    code?: string | null
    courses?: CourseCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupCreateNestedManyWithoutDepartmentInput
    colleges: CollegeCreateNestedOneWithoutDepartmentsInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutStudentsInput = {
    id?: string
    college_id: string
    name: string
    code?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutDepartmentInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsUncheckedCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutStudentsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutStudentsInput, DepartmentUncheckedCreateWithoutStudentsInput>
  }

  export type sectionsCreateWithoutStudentsInput = {
    section_id?: string
    section_name: string
    course_offerings?: CourseOfferingCreateNestedManyWithoutSectionsInput
    departments: DepartmentCreateNestedOneWithoutSectionsInput
  }

  export type sectionsUncheckedCreateWithoutStudentsInput = {
    section_id?: string
    department_id: string
    section_name: string
    course_offerings?: CourseOfferingUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type sectionsCreateOrConnectWithoutStudentsInput = {
    where: sectionsWhereUniqueInput
    create: XOR<sectionsCreateWithoutStudentsInput, sectionsUncheckedCreateWithoutStudentsInput>
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    reportViewer?: ReportViewerCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    reportViewer?: ReportViewerUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutStudentInput, AttendanceRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutStudentInput, AttendanceRecordUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceRecordScalarWhereInput = {
    AND?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    OR?: AttendanceRecordScalarWhereInput[]
    NOT?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    id?: UuidFilter<"AttendanceRecord"> | string
    attendanceId?: UuidNullableFilter<"AttendanceRecord"> | string | null
    studentId?: UuidNullableFilter<"AttendanceRecord"> | string | null
    status?: Enumattendance_statusNullableFilter<"AttendanceRecord"> | $Enums.attendance_status | null
  }

  export type StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrollmentWhereUniqueInput
    update: XOR<StudentEnrollmentUpdateWithoutStudentInput, StudentEnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrollmentWhereUniqueInput
    data: XOR<StudentEnrollmentUpdateWithoutStudentInput, StudentEnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentEnrollmentScalarWhereInput
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentEnrollmentScalarWhereInput = {
    AND?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
    OR?: StudentEnrollmentScalarWhereInput[]
    NOT?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
    id?: UuidFilter<"StudentEnrollment"> | string
    studentId?: UuidNullableFilter<"StudentEnrollment"> | string | null
    offeringId?: UuidNullableFilter<"StudentEnrollment"> | string | null
    attemptNumber?: IntNullableFilter<"StudentEnrollment"> | number | null
    year_id?: UuidNullableFilter<"StudentEnrollment"> | string | null
  }

  export type CollegeUpsertWithoutStudentsInput = {
    update: XOR<CollegeUpdateWithoutStudentsInput, CollegeUncheckedUpdateWithoutStudentsInput>
    create: XOR<CollegeCreateWithoutStudentsInput, CollegeUncheckedCreateWithoutStudentsInput>
    where?: CollegeWhereInput
  }

  export type CollegeUpdateToOneWithWhereWithoutStudentsInput = {
    where?: CollegeWhereInput
    data: XOR<CollegeUpdateWithoutStudentsInput, CollegeUncheckedUpdateWithoutStudentsInput>
  }

  export type CollegeUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUpdateManyWithoutCollegesNestedInput
    courses?: CourseUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUpdateManyWithoutCollegesNestedInput
  }

  export type CollegeUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUncheckedUpdateManyWithoutCollegesNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutCollegesNestedInput
  }

  export type DepartmentUpsertWithoutStudentsInput = {
    update: XOR<DepartmentUpdateWithoutStudentsInput, DepartmentUncheckedUpdateWithoutStudentsInput>
    create: XOR<DepartmentCreateWithoutStudentsInput, DepartmentUncheckedCreateWithoutStudentsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutStudentsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutStudentsInput, DepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type DepartmentUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUpdateManyWithoutDepartmentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutDepartmentsNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUncheckedUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type sectionsUpsertWithoutStudentsInput = {
    update: XOR<sectionsUpdateWithoutStudentsInput, sectionsUncheckedUpdateWithoutStudentsInput>
    create: XOR<sectionsCreateWithoutStudentsInput, sectionsUncheckedCreateWithoutStudentsInput>
    where?: sectionsWhereInput
  }

  export type sectionsUpdateToOneWithWhereWithoutStudentsInput = {
    where?: sectionsWhereInput
    data: XOR<sectionsUpdateWithoutStudentsInput, sectionsUncheckedUpdateWithoutStudentsInput>
  }

  export type sectionsUpdateWithoutStudentsInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    course_offerings?: CourseOfferingUpdateManyWithoutSectionsNestedInput
    departments?: DepartmentUpdateOneRequiredWithoutSectionsNestedInput
  }

  export type sectionsUncheckedUpdateWithoutStudentsInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    department_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    course_offerings?: CourseOfferingUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    reportViewer?: ReportViewerUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    reportViewer?: ReportViewerUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttendanceCreateWithoutTeacherInput = {
    id?: string
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
    offering?: CourseOfferingCreateNestedOneWithoutAttendancesInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutTeacherInput = {
    id?: string
    offeringId?: string | null
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutTeacherInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutTeacherInput, AttendanceUncheckedCreateWithoutTeacherInput>
  }

  export type AttendanceCreateManyTeacherInputEnvelope = {
    data: AttendanceCreateManyTeacherInput | AttendanceCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type CourseOfferingCreateWithoutTeacherInput = {
    id?: string
    semester?: number | null
    attendances?: AttendanceCreateNestedManyWithoutOfferingInput
    course: CourseCreateNestedOneWithoutCourseOfferingsInput
    sections?: sectionsCreateNestedOneWithoutCourse_offeringsInput
    academic_years?: academic_yearsCreateNestedOneWithoutCourse_offeringsInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutTeacherInput = {
    id?: string
    courseId: string
    section_id?: string | null
    year_id?: string | null
    semester?: number | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOfferingInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentUncheckedCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutTeacherInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutTeacherInput, CourseOfferingUncheckedCreateWithoutTeacherInput>
  }

  export type CourseOfferingCreateManyTeacherInputEnvelope = {
    data: CourseOfferingCreateManyTeacherInput | CourseOfferingCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type CollegeCreateWithoutTeachersInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsCreateNestedManyWithoutCollegesInput
    courses?: CourseCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupCreateNestedManyWithoutCollegesInput
    departments?: DepartmentCreateNestedManyWithoutCollegesInput
    students?: StudentCreateNestedManyWithoutCollegesInput
  }

  export type CollegeUncheckedCreateWithoutTeachersInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsUncheckedCreateNestedManyWithoutCollegesInput
    courses?: CourseUncheckedCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutCollegesInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCollegesInput
    students?: StudentUncheckedCreateNestedManyWithoutCollegesInput
  }

  export type CollegeCreateOrConnectWithoutTeachersInput = {
    where: CollegeWhereUniqueInput
    create: XOR<CollegeCreateWithoutTeachersInput, CollegeUncheckedCreateWithoutTeachersInput>
  }

  export type DepartmentCreateWithoutTeachersInput = {
    id?: string
    name: string
    code?: string | null
    courses?: CourseCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupCreateNestedManyWithoutDepartmentInput
    colleges: CollegeCreateNestedOneWithoutDepartmentsInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsCreateNestedManyWithoutDepartmentsInput
    students?: StudentCreateNestedManyWithoutDepartmentsInput
  }

  export type DepartmentUncheckedCreateWithoutTeachersInput = {
    id?: string
    college_id: string
    name: string
    code?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutDepartmentInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsUncheckedCreateNestedManyWithoutDepartmentsInput
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentsInput
  }

  export type DepartmentCreateOrConnectWithoutTeachersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutTeachersInput, DepartmentUncheckedCreateWithoutTeachersInput>
  }

  export type UserCreateWithoutTeacherInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    reportViewer?: ReportViewerCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeacherInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    reportViewer?: ReportViewerUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutTeacherInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutTeacherInput, AttendanceUncheckedUpdateWithoutTeacherInput>
    create: XOR<AttendanceCreateWithoutTeacherInput, AttendanceUncheckedCreateWithoutTeacherInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutTeacherInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutTeacherInput, AttendanceUncheckedUpdateWithoutTeacherInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutTeacherInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutTeacherInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: UuidFilter<"Attendance"> | string
    offeringId?: UuidNullableFilter<"Attendance"> | string | null
    teacherId?: UuidNullableFilter<"Attendance"> | string | null
    classDate?: DateTimeFilter<"Attendance"> | Date | string
    periodNumber?: IntNullableFilter<"Attendance"> | number | null
    syllabusCovered?: StringNullableFilter<"Attendance"> | string | null
    status?: StringNullableFilter<"Attendance"> | string | null
  }

  export type CourseOfferingUpsertWithWhereUniqueWithoutTeacherInput = {
    where: CourseOfferingWhereUniqueInput
    update: XOR<CourseOfferingUpdateWithoutTeacherInput, CourseOfferingUncheckedUpdateWithoutTeacherInput>
    create: XOR<CourseOfferingCreateWithoutTeacherInput, CourseOfferingUncheckedCreateWithoutTeacherInput>
  }

  export type CourseOfferingUpdateWithWhereUniqueWithoutTeacherInput = {
    where: CourseOfferingWhereUniqueInput
    data: XOR<CourseOfferingUpdateWithoutTeacherInput, CourseOfferingUncheckedUpdateWithoutTeacherInput>
  }

  export type CourseOfferingUpdateManyWithWhereWithoutTeacherInput = {
    where: CourseOfferingScalarWhereInput
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyWithoutTeacherInput>
  }

  export type CourseOfferingScalarWhereInput = {
    AND?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
    OR?: CourseOfferingScalarWhereInput[]
    NOT?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
    id?: UuidFilter<"CourseOffering"> | string
    courseId?: UuidFilter<"CourseOffering"> | string
    teacherId?: UuidNullableFilter<"CourseOffering"> | string | null
    section_id?: UuidNullableFilter<"CourseOffering"> | string | null
    year_id?: UuidNullableFilter<"CourseOffering"> | string | null
    semester?: IntNullableFilter<"CourseOffering"> | number | null
  }

  export type CollegeUpsertWithoutTeachersInput = {
    update: XOR<CollegeUpdateWithoutTeachersInput, CollegeUncheckedUpdateWithoutTeachersInput>
    create: XOR<CollegeCreateWithoutTeachersInput, CollegeUncheckedCreateWithoutTeachersInput>
    where?: CollegeWhereInput
  }

  export type CollegeUpdateToOneWithWhereWithoutTeachersInput = {
    where?: CollegeWhereInput
    data: XOR<CollegeUpdateWithoutTeachersInput, CollegeUncheckedUpdateWithoutTeachersInput>
  }

  export type CollegeUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUpdateManyWithoutCollegesNestedInput
    courses?: CourseUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUpdateManyWithoutCollegesNestedInput
    students?: StudentUpdateManyWithoutCollegesNestedInput
  }

  export type CollegeUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUncheckedUpdateManyWithoutCollegesNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCollegesNestedInput
    students?: StudentUncheckedUpdateManyWithoutCollegesNestedInput
  }

  export type DepartmentUpsertWithoutTeachersInput = {
    update: XOR<DepartmentUpdateWithoutTeachersInput, DepartmentUncheckedUpdateWithoutTeachersInput>
    create: XOR<DepartmentCreateWithoutTeachersInput, DepartmentUncheckedCreateWithoutTeachersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutTeachersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutTeachersInput, DepartmentUncheckedUpdateWithoutTeachersInput>
  }

  export type DepartmentUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUpdateManyWithoutDepartmentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutDepartmentsNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUpdateManyWithoutDepartmentsNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUncheckedUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUncheckedUpdateManyWithoutDepartmentsNestedInput
  }

  export type UserUpsertWithoutTeacherInput = {
    update: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type UserUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    reportViewer?: ReportViewerUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    reportViewer?: ReportViewerUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseElectiveGroupMemberCreateWithoutCourseInput = {
    group: DepartmentElectiveGroupCreateNestedOneWithoutCourseElectiveGroupMembersInput
  }

  export type CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput = {
    groupId: string
  }

  export type CourseElectiveGroupMemberCreateOrConnectWithoutCourseInput = {
    where: CourseElectiveGroupMemberWhereUniqueInput
    create: XOR<CourseElectiveGroupMemberCreateWithoutCourseInput, CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput>
  }

  export type CourseElectiveGroupMemberCreateManyCourseInputEnvelope = {
    data: CourseElectiveGroupMemberCreateManyCourseInput | CourseElectiveGroupMemberCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseOfferingCreateWithoutCourseInput = {
    id?: string
    semester?: number | null
    attendances?: AttendanceCreateNestedManyWithoutOfferingInput
    sections?: sectionsCreateNestedOneWithoutCourse_offeringsInput
    teacher?: TeacherCreateNestedOneWithoutCourseOfferingsInput
    academic_years?: academic_yearsCreateNestedOneWithoutCourse_offeringsInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutCourseInput = {
    id?: string
    teacherId?: string | null
    section_id?: string | null
    year_id?: string | null
    semester?: number | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOfferingInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentUncheckedCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutCourseInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput>
  }

  export type CourseOfferingCreateManyCourseInputEnvelope = {
    data: CourseOfferingCreateManyCourseInput | CourseOfferingCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CollegeCreateWithoutCoursesInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupCreateNestedManyWithoutCollegesInput
    departments?: DepartmentCreateNestedManyWithoutCollegesInput
    students?: StudentCreateNestedManyWithoutCollegesInput
    teachers?: TeacherCreateNestedManyWithoutCollegesInput
  }

  export type CollegeUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsUncheckedCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutCollegesInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCollegesInput
    students?: StudentUncheckedCreateNestedManyWithoutCollegesInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutCollegesInput
  }

  export type CollegeCreateOrConnectWithoutCoursesInput = {
    where: CollegeWhereUniqueInput
    create: XOR<CollegeCreateWithoutCoursesInput, CollegeUncheckedCreateWithoutCoursesInput>
  }

  export type DepartmentCreateWithoutCoursesInput = {
    id?: string
    name: string
    code?: string | null
    departmentElectiveGroups?: DepartmentElectiveGroupCreateNestedManyWithoutDepartmentInput
    colleges: CollegeCreateNestedOneWithoutDepartmentsInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsCreateNestedManyWithoutDepartmentsInput
    students?: StudentCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutCoursesInput = {
    id?: string
    college_id: string
    name: string
    code?: string | null
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutDepartmentInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsUncheckedCreateNestedManyWithoutDepartmentsInput
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutCoursesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutCoursesInput, DepartmentUncheckedCreateWithoutCoursesInput>
  }

  export type OpenElectiveRestrictionCreateWithoutCourseInput = {
    id?: string
    restrictedDepartment: DepartmentCreateNestedOneWithoutOpenElectiveRestrictionsInput
  }

  export type OpenElectiveRestrictionUncheckedCreateWithoutCourseInput = {
    id?: string
    restrictedDepartmentId: string
  }

  export type OpenElectiveRestrictionCreateOrConnectWithoutCourseInput = {
    where: OpenElectiveRestrictionWhereUniqueInput
    create: XOR<OpenElectiveRestrictionCreateWithoutCourseInput, OpenElectiveRestrictionUncheckedCreateWithoutCourseInput>
  }

  export type OpenElectiveRestrictionCreateManyCourseInputEnvelope = {
    data: OpenElectiveRestrictionCreateManyCourseInput | OpenElectiveRestrictionCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseElectiveGroupMemberWhereUniqueInput
    update: XOR<CourseElectiveGroupMemberUpdateWithoutCourseInput, CourseElectiveGroupMemberUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseElectiveGroupMemberCreateWithoutCourseInput, CourseElectiveGroupMemberUncheckedCreateWithoutCourseInput>
  }

  export type CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseElectiveGroupMemberWhereUniqueInput
    data: XOR<CourseElectiveGroupMemberUpdateWithoutCourseInput, CourseElectiveGroupMemberUncheckedUpdateWithoutCourseInput>
  }

  export type CourseElectiveGroupMemberUpdateManyWithWhereWithoutCourseInput = {
    where: CourseElectiveGroupMemberScalarWhereInput
    data: XOR<CourseElectiveGroupMemberUpdateManyMutationInput, CourseElectiveGroupMemberUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseElectiveGroupMemberScalarWhereInput = {
    AND?: CourseElectiveGroupMemberScalarWhereInput | CourseElectiveGroupMemberScalarWhereInput[]
    OR?: CourseElectiveGroupMemberScalarWhereInput[]
    NOT?: CourseElectiveGroupMemberScalarWhereInput | CourseElectiveGroupMemberScalarWhereInput[]
    groupId?: UuidFilter<"CourseElectiveGroupMember"> | string
    courseId?: UuidFilter<"CourseElectiveGroupMember"> | string
  }

  export type CourseOfferingUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseOfferingWhereUniqueInput
    update: XOR<CourseOfferingUpdateWithoutCourseInput, CourseOfferingUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput>
  }

  export type CourseOfferingUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseOfferingWhereUniqueInput
    data: XOR<CourseOfferingUpdateWithoutCourseInput, CourseOfferingUncheckedUpdateWithoutCourseInput>
  }

  export type CourseOfferingUpdateManyWithWhereWithoutCourseInput = {
    where: CourseOfferingScalarWhereInput
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyWithoutCourseInput>
  }

  export type CollegeUpsertWithoutCoursesInput = {
    update: XOR<CollegeUpdateWithoutCoursesInput, CollegeUncheckedUpdateWithoutCoursesInput>
    create: XOR<CollegeCreateWithoutCoursesInput, CollegeUncheckedCreateWithoutCoursesInput>
    where?: CollegeWhereInput
  }

  export type CollegeUpdateToOneWithWhereWithoutCoursesInput = {
    where?: CollegeWhereInput
    data: XOR<CollegeUpdateWithoutCoursesInput, CollegeUncheckedUpdateWithoutCoursesInput>
  }

  export type CollegeUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUpdateManyWithoutCollegesNestedInput
    students?: StudentUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUpdateManyWithoutCollegesNestedInput
  }

  export type CollegeUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUncheckedUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCollegesNestedInput
    students?: StudentUncheckedUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutCollegesNestedInput
  }

  export type DepartmentUpsertWithoutCoursesInput = {
    update: XOR<DepartmentUpdateWithoutCoursesInput, DepartmentUncheckedUpdateWithoutCoursesInput>
    create: XOR<DepartmentCreateWithoutCoursesInput, DepartmentUncheckedCreateWithoutCoursesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutCoursesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutCoursesInput, DepartmentUncheckedUpdateWithoutCoursesInput>
  }

  export type DepartmentUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    departmentElectiveGroups?: DepartmentElectiveGroupUpdateManyWithoutDepartmentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutDepartmentsNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUncheckedUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUncheckedUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type OpenElectiveRestrictionUpsertWithWhereUniqueWithoutCourseInput = {
    where: OpenElectiveRestrictionWhereUniqueInput
    update: XOR<OpenElectiveRestrictionUpdateWithoutCourseInput, OpenElectiveRestrictionUncheckedUpdateWithoutCourseInput>
    create: XOR<OpenElectiveRestrictionCreateWithoutCourseInput, OpenElectiveRestrictionUncheckedCreateWithoutCourseInput>
  }

  export type OpenElectiveRestrictionUpdateWithWhereUniqueWithoutCourseInput = {
    where: OpenElectiveRestrictionWhereUniqueInput
    data: XOR<OpenElectiveRestrictionUpdateWithoutCourseInput, OpenElectiveRestrictionUncheckedUpdateWithoutCourseInput>
  }

  export type OpenElectiveRestrictionUpdateManyWithWhereWithoutCourseInput = {
    where: OpenElectiveRestrictionScalarWhereInput
    data: XOR<OpenElectiveRestrictionUpdateManyMutationInput, OpenElectiveRestrictionUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseElectiveGroupMemberCreateWithoutGroupInput = {
    course: CourseCreateNestedOneWithoutCourseElectiveGroupMembersInput
  }

  export type CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput = {
    courseId: string
  }

  export type CourseElectiveGroupMemberCreateOrConnectWithoutGroupInput = {
    where: CourseElectiveGroupMemberWhereUniqueInput
    create: XOR<CourseElectiveGroupMemberCreateWithoutGroupInput, CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type CourseElectiveGroupMemberCreateManyGroupInputEnvelope = {
    data: CourseElectiveGroupMemberCreateManyGroupInput | CourseElectiveGroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type CollegeCreateWithoutDepartment_elective_groupsInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsCreateNestedManyWithoutCollegesInput
    courses?: CourseCreateNestedManyWithoutCollegesInput
    departments?: DepartmentCreateNestedManyWithoutCollegesInput
    students?: StudentCreateNestedManyWithoutCollegesInput
    teachers?: TeacherCreateNestedManyWithoutCollegesInput
  }

  export type CollegeUncheckedCreateWithoutDepartment_elective_groupsInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    academic_years?: academic_yearsUncheckedCreateNestedManyWithoutCollegesInput
    courses?: CourseUncheckedCreateNestedManyWithoutCollegesInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCollegesInput
    students?: StudentUncheckedCreateNestedManyWithoutCollegesInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutCollegesInput
  }

  export type CollegeCreateOrConnectWithoutDepartment_elective_groupsInput = {
    where: CollegeWhereUniqueInput
    create: XOR<CollegeCreateWithoutDepartment_elective_groupsInput, CollegeUncheckedCreateWithoutDepartment_elective_groupsInput>
  }

  export type DepartmentCreateWithoutDepartmentElectiveGroupsInput = {
    id?: string
    name: string
    code?: string | null
    courses?: CourseCreateNestedManyWithoutDepartmentInput
    colleges: CollegeCreateNestedOneWithoutDepartmentsInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsCreateNestedManyWithoutDepartmentsInput
    students?: StudentCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutDepartmentElectiveGroupsInput = {
    id?: string
    college_id: string
    name: string
    code?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutRestrictedDepartmentInput
    sections?: sectionsUncheckedCreateNestedManyWithoutDepartmentsInput
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutDepartmentElectiveGroupsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutDepartmentElectiveGroupsInput, DepartmentUncheckedCreateWithoutDepartmentElectiveGroupsInput>
  }

  export type CourseElectiveGroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: CourseElectiveGroupMemberWhereUniqueInput
    update: XOR<CourseElectiveGroupMemberUpdateWithoutGroupInput, CourseElectiveGroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<CourseElectiveGroupMemberCreateWithoutGroupInput, CourseElectiveGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type CourseElectiveGroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: CourseElectiveGroupMemberWhereUniqueInput
    data: XOR<CourseElectiveGroupMemberUpdateWithoutGroupInput, CourseElectiveGroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type CourseElectiveGroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: CourseElectiveGroupMemberScalarWhereInput
    data: XOR<CourseElectiveGroupMemberUpdateManyMutationInput, CourseElectiveGroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type CollegeUpsertWithoutDepartment_elective_groupsInput = {
    update: XOR<CollegeUpdateWithoutDepartment_elective_groupsInput, CollegeUncheckedUpdateWithoutDepartment_elective_groupsInput>
    create: XOR<CollegeCreateWithoutDepartment_elective_groupsInput, CollegeUncheckedCreateWithoutDepartment_elective_groupsInput>
    where?: CollegeWhereInput
  }

  export type CollegeUpdateToOneWithWhereWithoutDepartment_elective_groupsInput = {
    where?: CollegeWhereInput
    data: XOR<CollegeUpdateWithoutDepartment_elective_groupsInput, CollegeUncheckedUpdateWithoutDepartment_elective_groupsInput>
  }

  export type CollegeUpdateWithoutDepartment_elective_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUpdateManyWithoutCollegesNestedInput
    courses?: CourseUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUpdateManyWithoutCollegesNestedInput
    students?: StudentUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUpdateManyWithoutCollegesNestedInput
  }

  export type CollegeUncheckedUpdateWithoutDepartment_elective_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    academic_years?: academic_yearsUncheckedUpdateManyWithoutCollegesNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCollegesNestedInput
    students?: StudentUncheckedUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutCollegesNestedInput
  }

  export type DepartmentUpsertWithoutDepartmentElectiveGroupsInput = {
    update: XOR<DepartmentUpdateWithoutDepartmentElectiveGroupsInput, DepartmentUncheckedUpdateWithoutDepartmentElectiveGroupsInput>
    create: XOR<DepartmentCreateWithoutDepartmentElectiveGroupsInput, DepartmentUncheckedCreateWithoutDepartmentElectiveGroupsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutDepartmentElectiveGroupsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutDepartmentElectiveGroupsInput, DepartmentUncheckedUpdateWithoutDepartmentElectiveGroupsInput>
  }

  export type DepartmentUpdateWithoutDepartmentElectiveGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutDepartmentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutDepartmentsNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutDepartmentElectiveGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUncheckedUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUncheckedUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type CourseCreateWithoutCourseElectiveGroupMembersInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseOfferings?: CourseOfferingCreateNestedManyWithoutCourseInput
    colleges: CollegeCreateNestedOneWithoutCoursesInput
    department?: DepartmentCreateNestedOneWithoutCoursesInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseElectiveGroupMembersInput = {
    id?: string
    college_id: string
    code: string
    name: string
    departmentId?: string | null
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseElectiveGroupMembersInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseElectiveGroupMembersInput, CourseUncheckedCreateWithoutCourseElectiveGroupMembersInput>
  }

  export type DepartmentElectiveGroupCreateWithoutCourseElectiveGroupMembersInput = {
    id?: string
    name: string
    semester: number
    batchYear: number
    colleges: CollegeCreateNestedOneWithoutDepartment_elective_groupsInput
    department: DepartmentCreateNestedOneWithoutDepartmentElectiveGroupsInput
  }

  export type DepartmentElectiveGroupUncheckedCreateWithoutCourseElectiveGroupMembersInput = {
    id?: string
    college_id: string
    name: string
    departmentId: string
    semester: number
    batchYear: number
  }

  export type DepartmentElectiveGroupCreateOrConnectWithoutCourseElectiveGroupMembersInput = {
    where: DepartmentElectiveGroupWhereUniqueInput
    create: XOR<DepartmentElectiveGroupCreateWithoutCourseElectiveGroupMembersInput, DepartmentElectiveGroupUncheckedCreateWithoutCourseElectiveGroupMembersInput>
  }

  export type CourseUpsertWithoutCourseElectiveGroupMembersInput = {
    update: XOR<CourseUpdateWithoutCourseElectiveGroupMembersInput, CourseUncheckedUpdateWithoutCourseElectiveGroupMembersInput>
    create: XOR<CourseCreateWithoutCourseElectiveGroupMembersInput, CourseUncheckedCreateWithoutCourseElectiveGroupMembersInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseElectiveGroupMembersInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseElectiveGroupMembersInput, CourseUncheckedUpdateWithoutCourseElectiveGroupMembersInput>
  }

  export type CourseUpdateWithoutCourseElectiveGroupMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseOfferings?: CourseOfferingUpdateManyWithoutCourseNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutCoursesNestedInput
    department?: DepartmentUpdateOneWithoutCoursesNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseElectiveGroupMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutCourseNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type DepartmentElectiveGroupUpsertWithoutCourseElectiveGroupMembersInput = {
    update: XOR<DepartmentElectiveGroupUpdateWithoutCourseElectiveGroupMembersInput, DepartmentElectiveGroupUncheckedUpdateWithoutCourseElectiveGroupMembersInput>
    create: XOR<DepartmentElectiveGroupCreateWithoutCourseElectiveGroupMembersInput, DepartmentElectiveGroupUncheckedCreateWithoutCourseElectiveGroupMembersInput>
    where?: DepartmentElectiveGroupWhereInput
  }

  export type DepartmentElectiveGroupUpdateToOneWithWhereWithoutCourseElectiveGroupMembersInput = {
    where?: DepartmentElectiveGroupWhereInput
    data: XOR<DepartmentElectiveGroupUpdateWithoutCourseElectiveGroupMembersInput, DepartmentElectiveGroupUncheckedUpdateWithoutCourseElectiveGroupMembersInput>
  }

  export type DepartmentElectiveGroupUpdateWithoutCourseElectiveGroupMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
    colleges?: CollegeUpdateOneRequiredWithoutDepartment_elective_groupsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutDepartmentElectiveGroupsNestedInput
  }

  export type DepartmentElectiveGroupUncheckedUpdateWithoutCourseElectiveGroupMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type CourseCreateWithoutOpenElectiveRestrictionsInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberCreateNestedManyWithoutCourseInput
    courseOfferings?: CourseOfferingCreateNestedManyWithoutCourseInput
    colleges: CollegeCreateNestedOneWithoutCoursesInput
    department?: DepartmentCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutOpenElectiveRestrictionsInput = {
    id?: string
    college_id: string
    code: string
    name: string
    departmentId?: string | null
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutCourseInput
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutOpenElectiveRestrictionsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutOpenElectiveRestrictionsInput, CourseUncheckedCreateWithoutOpenElectiveRestrictionsInput>
  }

  export type DepartmentCreateWithoutOpenElectiveRestrictionsInput = {
    id?: string
    name: string
    code?: string | null
    courses?: CourseCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupCreateNestedManyWithoutDepartmentInput
    colleges: CollegeCreateNestedOneWithoutDepartmentsInput
    sections?: sectionsCreateNestedManyWithoutDepartmentsInput
    students?: StudentCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutOpenElectiveRestrictionsInput = {
    id?: string
    college_id: string
    name: string
    code?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutDepartmentInput
    sections?: sectionsUncheckedCreateNestedManyWithoutDepartmentsInput
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutOpenElectiveRestrictionsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutOpenElectiveRestrictionsInput, DepartmentUncheckedCreateWithoutOpenElectiveRestrictionsInput>
  }

  export type CourseUpsertWithoutOpenElectiveRestrictionsInput = {
    update: XOR<CourseUpdateWithoutOpenElectiveRestrictionsInput, CourseUncheckedUpdateWithoutOpenElectiveRestrictionsInput>
    create: XOR<CourseCreateWithoutOpenElectiveRestrictionsInput, CourseUncheckedCreateWithoutOpenElectiveRestrictionsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutOpenElectiveRestrictionsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutOpenElectiveRestrictionsInput, CourseUncheckedUpdateWithoutOpenElectiveRestrictionsInput>
  }

  export type CourseUpdateWithoutOpenElectiveRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUpdateManyWithoutCourseNestedInput
    courseOfferings?: CourseOfferingUpdateManyWithoutCourseNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutCoursesNestedInput
    department?: DepartmentUpdateOneWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutOpenElectiveRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedUpdateManyWithoutCourseNestedInput
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type DepartmentUpsertWithoutOpenElectiveRestrictionsInput = {
    update: XOR<DepartmentUpdateWithoutOpenElectiveRestrictionsInput, DepartmentUncheckedUpdateWithoutOpenElectiveRestrictionsInput>
    create: XOR<DepartmentCreateWithoutOpenElectiveRestrictionsInput, DepartmentUncheckedCreateWithoutOpenElectiveRestrictionsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutOpenElectiveRestrictionsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutOpenElectiveRestrictionsInput, DepartmentUncheckedUpdateWithoutOpenElectiveRestrictionsInput>
  }

  export type DepartmentUpdateWithoutOpenElectiveRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUpdateManyWithoutDepartmentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutDepartmentsNestedInput
    sections?: sectionsUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutOpenElectiveRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentNestedInput
    sections?: sectionsUncheckedUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUncheckedUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type AttendanceCreateWithoutOfferingInput = {
    id?: string
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
    teacher?: TeacherCreateNestedOneWithoutAttendancesInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutOfferingInput = {
    id?: string
    teacherId?: string | null
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutAttendanceInput
  }

  export type AttendanceCreateOrConnectWithoutOfferingInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutOfferingInput, AttendanceUncheckedCreateWithoutOfferingInput>
  }

  export type AttendanceCreateManyOfferingInputEnvelope = {
    data: AttendanceCreateManyOfferingInput | AttendanceCreateManyOfferingInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCourseOfferingsInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberCreateNestedManyWithoutCourseInput
    colleges: CollegeCreateNestedOneWithoutCoursesInput
    department?: DepartmentCreateNestedOneWithoutCoursesInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseOfferingsInput = {
    id?: string
    college_id: string
    code: string
    name: string
    departmentId?: string | null
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedCreateNestedManyWithoutCourseInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseOfferingsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseOfferingsInput, CourseUncheckedCreateWithoutCourseOfferingsInput>
  }

  export type sectionsCreateWithoutCourse_offeringsInput = {
    section_id?: string
    section_name: string
    departments: DepartmentCreateNestedOneWithoutSectionsInput
    students?: StudentCreateNestedManyWithoutSectionsInput
  }

  export type sectionsUncheckedCreateWithoutCourse_offeringsInput = {
    section_id?: string
    department_id: string
    section_name: string
    students?: StudentUncheckedCreateNestedManyWithoutSectionsInput
  }

  export type sectionsCreateOrConnectWithoutCourse_offeringsInput = {
    where: sectionsWhereUniqueInput
    create: XOR<sectionsCreateWithoutCourse_offeringsInput, sectionsUncheckedCreateWithoutCourse_offeringsInput>
  }

  export type TeacherCreateWithoutCourseOfferingsInput = {
    id?: string
    attendances?: AttendanceCreateNestedManyWithoutTeacherInput
    colleges: CollegeCreateNestedOneWithoutTeachersInput
    department?: DepartmentCreateNestedOneWithoutTeachersInput
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCourseOfferingsInput = {
    id?: string
    userId: string
    college_id: string
    departmentId?: string | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCourseOfferingsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCourseOfferingsInput, TeacherUncheckedCreateWithoutCourseOfferingsInput>
  }

  export type academic_yearsCreateWithoutCourse_offeringsInput = {
    year_id?: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    colleges: CollegeCreateNestedOneWithoutAcademic_yearsInput
    student_enrollments?: StudentEnrollmentCreateNestedManyWithoutAcademic_yearsInput
  }

  export type academic_yearsUncheckedCreateWithoutCourse_offeringsInput = {
    year_id?: string
    college_id: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    student_enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutAcademic_yearsInput
  }

  export type academic_yearsCreateOrConnectWithoutCourse_offeringsInput = {
    where: academic_yearsWhereUniqueInput
    create: XOR<academic_yearsCreateWithoutCourse_offeringsInput, academic_yearsUncheckedCreateWithoutCourse_offeringsInput>
  }

  export type StudentEnrollmentCreateWithoutOfferingInput = {
    id?: string
    attemptNumber?: number | null
    student?: StudentCreateNestedOneWithoutEnrollmentsInput
    academic_years?: academic_yearsCreateNestedOneWithoutStudent_enrollmentsInput
    studentMarks?: StudentMarkCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutOfferingInput = {
    id?: string
    studentId?: string | null
    attemptNumber?: number | null
    year_id?: string | null
    studentMarks?: StudentMarkUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentCreateOrConnectWithoutOfferingInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutOfferingInput, StudentEnrollmentUncheckedCreateWithoutOfferingInput>
  }

  export type StudentEnrollmentCreateManyOfferingInputEnvelope = {
    data: StudentEnrollmentCreateManyOfferingInput | StudentEnrollmentCreateManyOfferingInput[]
    skipDuplicates?: boolean
  }

  export type TestComponentCreateWithoutCourseOfferingInput = {
    id?: string
    name: string
    maxMarks: number
    weightage?: number
    studentMarks?: StudentMarkCreateNestedManyWithoutTestComponentInput
  }

  export type TestComponentUncheckedCreateWithoutCourseOfferingInput = {
    id?: string
    name: string
    maxMarks: number
    weightage?: number
    studentMarks?: StudentMarkUncheckedCreateNestedManyWithoutTestComponentInput
  }

  export type TestComponentCreateOrConnectWithoutCourseOfferingInput = {
    where: TestComponentWhereUniqueInput
    create: XOR<TestComponentCreateWithoutCourseOfferingInput, TestComponentUncheckedCreateWithoutCourseOfferingInput>
  }

  export type TestComponentCreateManyCourseOfferingInputEnvelope = {
    data: TestComponentCreateManyCourseOfferingInput | TestComponentCreateManyCourseOfferingInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceUpsertWithWhereUniqueWithoutOfferingInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutOfferingInput, AttendanceUncheckedUpdateWithoutOfferingInput>
    create: XOR<AttendanceCreateWithoutOfferingInput, AttendanceUncheckedCreateWithoutOfferingInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutOfferingInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutOfferingInput, AttendanceUncheckedUpdateWithoutOfferingInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutOfferingInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutOfferingInput>
  }

  export type CourseUpsertWithoutCourseOfferingsInput = {
    update: XOR<CourseUpdateWithoutCourseOfferingsInput, CourseUncheckedUpdateWithoutCourseOfferingsInput>
    create: XOR<CourseCreateWithoutCourseOfferingsInput, CourseUncheckedCreateWithoutCourseOfferingsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseOfferingsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseOfferingsInput, CourseUncheckedUpdateWithoutCourseOfferingsInput>
  }

  export type CourseUpdateWithoutCourseOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUpdateManyWithoutCourseNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutCoursesNestedInput
    department?: DepartmentUpdateOneWithoutCoursesNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedUpdateManyWithoutCourseNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type sectionsUpsertWithoutCourse_offeringsInput = {
    update: XOR<sectionsUpdateWithoutCourse_offeringsInput, sectionsUncheckedUpdateWithoutCourse_offeringsInput>
    create: XOR<sectionsCreateWithoutCourse_offeringsInput, sectionsUncheckedCreateWithoutCourse_offeringsInput>
    where?: sectionsWhereInput
  }

  export type sectionsUpdateToOneWithWhereWithoutCourse_offeringsInput = {
    where?: sectionsWhereInput
    data: XOR<sectionsUpdateWithoutCourse_offeringsInput, sectionsUncheckedUpdateWithoutCourse_offeringsInput>
  }

  export type sectionsUpdateWithoutCourse_offeringsInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateOneRequiredWithoutSectionsNestedInput
    students?: StudentUpdateManyWithoutSectionsNestedInput
  }

  export type sectionsUncheckedUpdateWithoutCourse_offeringsInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    department_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type TeacherUpsertWithoutCourseOfferingsInput = {
    update: XOR<TeacherUpdateWithoutCourseOfferingsInput, TeacherUncheckedUpdateWithoutCourseOfferingsInput>
    create: XOR<TeacherCreateWithoutCourseOfferingsInput, TeacherUncheckedCreateWithoutCourseOfferingsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutCourseOfferingsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutCourseOfferingsInput, TeacherUncheckedUpdateWithoutCourseOfferingsInput>
  }

  export type TeacherUpdateWithoutCourseOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendances?: AttendanceUpdateManyWithoutTeacherNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutTeachersNestedInput
    department?: DepartmentUpdateOneWithoutTeachersNestedInput
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCourseOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type academic_yearsUpsertWithoutCourse_offeringsInput = {
    update: XOR<academic_yearsUpdateWithoutCourse_offeringsInput, academic_yearsUncheckedUpdateWithoutCourse_offeringsInput>
    create: XOR<academic_yearsCreateWithoutCourse_offeringsInput, academic_yearsUncheckedCreateWithoutCourse_offeringsInput>
    where?: academic_yearsWhereInput
  }

  export type academic_yearsUpdateToOneWithWhereWithoutCourse_offeringsInput = {
    where?: academic_yearsWhereInput
    data: XOR<academic_yearsUpdateWithoutCourse_offeringsInput, academic_yearsUncheckedUpdateWithoutCourse_offeringsInput>
  }

  export type academic_yearsUpdateWithoutCourse_offeringsInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colleges?: CollegeUpdateOneRequiredWithoutAcademic_yearsNestedInput
    student_enrollments?: StudentEnrollmentUpdateManyWithoutAcademic_yearsNestedInput
  }

  export type academic_yearsUncheckedUpdateWithoutCourse_offeringsInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    student_enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutAcademic_yearsNestedInput
  }

  export type StudentEnrollmentUpsertWithWhereUniqueWithoutOfferingInput = {
    where: StudentEnrollmentWhereUniqueInput
    update: XOR<StudentEnrollmentUpdateWithoutOfferingInput, StudentEnrollmentUncheckedUpdateWithoutOfferingInput>
    create: XOR<StudentEnrollmentCreateWithoutOfferingInput, StudentEnrollmentUncheckedCreateWithoutOfferingInput>
  }

  export type StudentEnrollmentUpdateWithWhereUniqueWithoutOfferingInput = {
    where: StudentEnrollmentWhereUniqueInput
    data: XOR<StudentEnrollmentUpdateWithoutOfferingInput, StudentEnrollmentUncheckedUpdateWithoutOfferingInput>
  }

  export type StudentEnrollmentUpdateManyWithWhereWithoutOfferingInput = {
    where: StudentEnrollmentScalarWhereInput
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyWithoutOfferingInput>
  }

  export type TestComponentUpsertWithWhereUniqueWithoutCourseOfferingInput = {
    where: TestComponentWhereUniqueInput
    update: XOR<TestComponentUpdateWithoutCourseOfferingInput, TestComponentUncheckedUpdateWithoutCourseOfferingInput>
    create: XOR<TestComponentCreateWithoutCourseOfferingInput, TestComponentUncheckedCreateWithoutCourseOfferingInput>
  }

  export type TestComponentUpdateWithWhereUniqueWithoutCourseOfferingInput = {
    where: TestComponentWhereUniqueInput
    data: XOR<TestComponentUpdateWithoutCourseOfferingInput, TestComponentUncheckedUpdateWithoutCourseOfferingInput>
  }

  export type TestComponentUpdateManyWithWhereWithoutCourseOfferingInput = {
    where: TestComponentScalarWhereInput
    data: XOR<TestComponentUpdateManyMutationInput, TestComponentUncheckedUpdateManyWithoutCourseOfferingInput>
  }

  export type TestComponentScalarWhereInput = {
    AND?: TestComponentScalarWhereInput | TestComponentScalarWhereInput[]
    OR?: TestComponentScalarWhereInput[]
    NOT?: TestComponentScalarWhereInput | TestComponentScalarWhereInput[]
    id?: UuidFilter<"TestComponent"> | string
    courseOfferingId?: UuidFilter<"TestComponent"> | string
    name?: StringFilter<"TestComponent"> | string
    maxMarks?: IntFilter<"TestComponent"> | number
    weightage?: IntFilter<"TestComponent"> | number
  }

  export type CourseOfferingCreateWithoutEnrollmentsInput = {
    id?: string
    semester?: number | null
    attendances?: AttendanceCreateNestedManyWithoutOfferingInput
    course: CourseCreateNestedOneWithoutCourseOfferingsInput
    sections?: sectionsCreateNestedOneWithoutCourse_offeringsInput
    teacher?: TeacherCreateNestedOneWithoutCourseOfferingsInput
    academic_years?: academic_yearsCreateNestedOneWithoutCourse_offeringsInput
    testComponents?: TestComponentCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    courseId: string
    teacherId?: string | null
    section_id?: string | null
    year_id?: string | null
    semester?: number | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentUncheckedCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutEnrollmentsInput, CourseOfferingUncheckedCreateWithoutEnrollmentsInput>
  }

  export type StudentCreateWithoutEnrollmentsInput = {
    id?: string
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    colleges: CollegeCreateNestedOneWithoutStudentsInput
    departments?: DepartmentCreateNestedOneWithoutStudentsInput
    sections?: sectionsCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    userId: string
    college_id: string
    department_id?: string | null
    section_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnrollmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
  }

  export type academic_yearsCreateWithoutStudent_enrollmentsInput = {
    year_id?: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    colleges: CollegeCreateNestedOneWithoutAcademic_yearsInput
    course_offerings?: CourseOfferingCreateNestedManyWithoutAcademic_yearsInput
  }

  export type academic_yearsUncheckedCreateWithoutStudent_enrollmentsInput = {
    year_id?: string
    college_id: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    course_offerings?: CourseOfferingUncheckedCreateNestedManyWithoutAcademic_yearsInput
  }

  export type academic_yearsCreateOrConnectWithoutStudent_enrollmentsInput = {
    where: academic_yearsWhereUniqueInput
    create: XOR<academic_yearsCreateWithoutStudent_enrollmentsInput, academic_yearsUncheckedCreateWithoutStudent_enrollmentsInput>
  }

  export type StudentMarkCreateWithoutEnrollmentInput = {
    id?: string
    marksObtained?: number | null
    testComponent: TestComponentCreateNestedOneWithoutStudentMarksInput
  }

  export type StudentMarkUncheckedCreateWithoutEnrollmentInput = {
    id?: string
    testComponentId: string
    marksObtained?: number | null
  }

  export type StudentMarkCreateOrConnectWithoutEnrollmentInput = {
    where: StudentMarkWhereUniqueInput
    create: XOR<StudentMarkCreateWithoutEnrollmentInput, StudentMarkUncheckedCreateWithoutEnrollmentInput>
  }

  export type StudentMarkCreateManyEnrollmentInputEnvelope = {
    data: StudentMarkCreateManyEnrollmentInput | StudentMarkCreateManyEnrollmentInput[]
    skipDuplicates?: boolean
  }

  export type CourseOfferingUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseOfferingUpdateWithoutEnrollmentsInput, CourseOfferingUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseOfferingCreateWithoutEnrollmentsInput, CourseOfferingUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseOfferingWhereInput
  }

  export type CourseOfferingUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseOfferingWhereInput
    data: XOR<CourseOfferingUpdateWithoutEnrollmentsInput, CourseOfferingUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseOfferingUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUpdateManyWithoutOfferingNestedInput
    course?: CourseUpdateOneRequiredWithoutCourseOfferingsNestedInput
    sections?: sectionsUpdateOneWithoutCourse_offeringsNestedInput
    teacher?: TeacherUpdateOneWithoutCourseOfferingsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutCourse_offeringsNestedInput
    testComponents?: TestComponentUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUncheckedUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUncheckedUpdateManyWithoutCourseOfferingNestedInput
  }

  export type StudentUpsertWithoutEnrollmentsInput = {
    update: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutStudentsNestedInput
    departments?: DepartmentUpdateOneWithoutStudentsNestedInput
    sections?: sectionsUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type academic_yearsUpsertWithoutStudent_enrollmentsInput = {
    update: XOR<academic_yearsUpdateWithoutStudent_enrollmentsInput, academic_yearsUncheckedUpdateWithoutStudent_enrollmentsInput>
    create: XOR<academic_yearsCreateWithoutStudent_enrollmentsInput, academic_yearsUncheckedCreateWithoutStudent_enrollmentsInput>
    where?: academic_yearsWhereInput
  }

  export type academic_yearsUpdateToOneWithWhereWithoutStudent_enrollmentsInput = {
    where?: academic_yearsWhereInput
    data: XOR<academic_yearsUpdateWithoutStudent_enrollmentsInput, academic_yearsUncheckedUpdateWithoutStudent_enrollmentsInput>
  }

  export type academic_yearsUpdateWithoutStudent_enrollmentsInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    colleges?: CollegeUpdateOneRequiredWithoutAcademic_yearsNestedInput
    course_offerings?: CourseOfferingUpdateManyWithoutAcademic_yearsNestedInput
  }

  export type academic_yearsUncheckedUpdateWithoutStudent_enrollmentsInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    course_offerings?: CourseOfferingUncheckedUpdateManyWithoutAcademic_yearsNestedInput
  }

  export type StudentMarkUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: StudentMarkWhereUniqueInput
    update: XOR<StudentMarkUpdateWithoutEnrollmentInput, StudentMarkUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<StudentMarkCreateWithoutEnrollmentInput, StudentMarkUncheckedCreateWithoutEnrollmentInput>
  }

  export type StudentMarkUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: StudentMarkWhereUniqueInput
    data: XOR<StudentMarkUpdateWithoutEnrollmentInput, StudentMarkUncheckedUpdateWithoutEnrollmentInput>
  }

  export type StudentMarkUpdateManyWithWhereWithoutEnrollmentInput = {
    where: StudentMarkScalarWhereInput
    data: XOR<StudentMarkUpdateManyMutationInput, StudentMarkUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type StudentMarkScalarWhereInput = {
    AND?: StudentMarkScalarWhereInput | StudentMarkScalarWhereInput[]
    OR?: StudentMarkScalarWhereInput[]
    NOT?: StudentMarkScalarWhereInput | StudentMarkScalarWhereInput[]
    id?: UuidFilter<"StudentMark"> | string
    enrollmentId?: UuidFilter<"StudentMark"> | string
    testComponentId?: UuidFilter<"StudentMark"> | string
    marksObtained?: IntNullableFilter<"StudentMark"> | number | null
  }

  export type CourseOfferingCreateWithoutAttendancesInput = {
    id?: string
    semester?: number | null
    course: CourseCreateNestedOneWithoutCourseOfferingsInput
    sections?: sectionsCreateNestedOneWithoutCourse_offeringsInput
    teacher?: TeacherCreateNestedOneWithoutCourseOfferingsInput
    academic_years?: academic_yearsCreateNestedOneWithoutCourse_offeringsInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutAttendancesInput = {
    id?: string
    courseId: string
    teacherId?: string | null
    section_id?: string | null
    year_id?: string | null
    semester?: number | null
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentUncheckedCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutAttendancesInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutAttendancesInput, CourseOfferingUncheckedCreateWithoutAttendancesInput>
  }

  export type TeacherCreateWithoutAttendancesInput = {
    id?: string
    courseOfferings?: CourseOfferingCreateNestedManyWithoutTeacherInput
    colleges: CollegeCreateNestedOneWithoutTeachersInput
    department?: DepartmentCreateNestedOneWithoutTeachersInput
    user: UserCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutAttendancesInput = {
    id?: string
    userId: string
    college_id: string
    departmentId?: string | null
    courseOfferings?: CourseOfferingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutAttendancesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutAttendancesInput, TeacherUncheckedCreateWithoutAttendancesInput>
  }

  export type AttendanceRecordCreateWithoutAttendanceInput = {
    id?: string
    status?: $Enums.attendance_status | null
    student?: StudentCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateWithoutAttendanceInput = {
    id?: string
    studentId?: string | null
    status?: $Enums.attendance_status | null
  }

  export type AttendanceRecordCreateOrConnectWithoutAttendanceInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutAttendanceInput, AttendanceRecordUncheckedCreateWithoutAttendanceInput>
  }

  export type AttendanceRecordCreateManyAttendanceInputEnvelope = {
    data: AttendanceRecordCreateManyAttendanceInput | AttendanceRecordCreateManyAttendanceInput[]
    skipDuplicates?: boolean
  }

  export type CourseOfferingUpsertWithoutAttendancesInput = {
    update: XOR<CourseOfferingUpdateWithoutAttendancesInput, CourseOfferingUncheckedUpdateWithoutAttendancesInput>
    create: XOR<CourseOfferingCreateWithoutAttendancesInput, CourseOfferingUncheckedCreateWithoutAttendancesInput>
    where?: CourseOfferingWhereInput
  }

  export type CourseOfferingUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: CourseOfferingWhereInput
    data: XOR<CourseOfferingUpdateWithoutAttendancesInput, CourseOfferingUncheckedUpdateWithoutAttendancesInput>
  }

  export type CourseOfferingUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneRequiredWithoutCourseOfferingsNestedInput
    sections?: sectionsUpdateOneWithoutCourse_offeringsNestedInput
    teacher?: TeacherUpdateOneWithoutCourseOfferingsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutCourse_offeringsNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUncheckedUpdateManyWithoutCourseOfferingNestedInput
  }

  export type TeacherUpsertWithoutAttendancesInput = {
    update: XOR<TeacherUpdateWithoutAttendancesInput, TeacherUncheckedUpdateWithoutAttendancesInput>
    create: XOR<TeacherCreateWithoutAttendancesInput, TeacherUncheckedCreateWithoutAttendancesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutAttendancesInput, TeacherUncheckedUpdateWithoutAttendancesInput>
  }

  export type TeacherUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseOfferings?: CourseOfferingUpdateManyWithoutTeacherNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutTeachersNestedInput
    department?: DepartmentUpdateOneWithoutTeachersNestedInput
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutAttendanceInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutAttendanceInput, AttendanceRecordUncheckedUpdateWithoutAttendanceInput>
    create: XOR<AttendanceRecordCreateWithoutAttendanceInput, AttendanceRecordUncheckedCreateWithoutAttendanceInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutAttendanceInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutAttendanceInput, AttendanceRecordUncheckedUpdateWithoutAttendanceInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutAttendanceInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutAttendanceInput>
  }

  export type AttendanceCreateWithoutAttendanceRecordsInput = {
    id?: string
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
    offering?: CourseOfferingCreateNestedOneWithoutAttendancesInput
    teacher?: TeacherCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    offeringId?: string | null
    teacherId?: string | null
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
  }

  export type AttendanceCreateOrConnectWithoutAttendanceRecordsInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutAttendanceRecordsInput, AttendanceUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type StudentCreateWithoutAttendanceRecordsInput = {
    id?: string
    usn: string
    semester?: number | null
    batchYear: number
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    colleges: CollegeCreateNestedOneWithoutStudentsInput
    departments?: DepartmentCreateNestedOneWithoutStudentsInput
    sections?: sectionsCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    userId: string
    college_id: string
    department_id?: string | null
    section_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendanceRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type AttendanceUpsertWithoutAttendanceRecordsInput = {
    update: XOR<AttendanceUpdateWithoutAttendanceRecordsInput, AttendanceUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<AttendanceCreateWithoutAttendanceRecordsInput, AttendanceUncheckedCreateWithoutAttendanceRecordsInput>
    where?: AttendanceWhereInput
  }

  export type AttendanceUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: AttendanceWhereInput
    data: XOR<AttendanceUpdateWithoutAttendanceRecordsInput, AttendanceUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type AttendanceUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    offering?: CourseOfferingUpdateOneWithoutAttendancesNestedInput
    teacher?: TeacherUpdateOneWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentUpsertWithoutAttendanceRecordsInput = {
    update: XOR<StudentUpdateWithoutAttendanceRecordsInput, StudentUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendanceRecordsInput, StudentUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type StudentUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutStudentsNestedInput
    departments?: DepartmentUpdateOneWithoutStudentsNestedInput
    sections?: sectionsUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    reportViewer?: ReportViewerCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    reportViewer?: ReportViewerUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportViewer?: ReportViewerUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportViewer?: ReportViewerUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReportViewerInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportViewerInput = {
    id?: string
    username: string
    email?: string | null
    passwordHash: string
    name: string
    phone?: string | null
    photoUrl?: string | null
    createdAt?: Date | string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportViewerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportViewerInput, UserUncheckedCreateWithoutReportViewerInput>
  }

  export type UserUpsertWithoutReportViewerInput = {
    update: XOR<UserUpdateWithoutReportViewerInput, UserUncheckedUpdateWithoutReportViewerInput>
    create: XOR<UserCreateWithoutReportViewerInput, UserUncheckedCreateWithoutReportViewerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportViewerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportViewerInput, UserUncheckedUpdateWithoutReportViewerInput>
  }

  export type UserUpdateWithoutReportViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CollegeCreateWithoutAcademic_yearsInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    courses?: CourseCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupCreateNestedManyWithoutCollegesInput
    departments?: DepartmentCreateNestedManyWithoutCollegesInput
    students?: StudentCreateNestedManyWithoutCollegesInput
    teachers?: TeacherCreateNestedManyWithoutCollegesInput
  }

  export type CollegeUncheckedCreateWithoutAcademic_yearsInput = {
    id?: string
    name: string
    code: string
    logoUrl?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutCollegesInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutCollegesInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutCollegesInput
    students?: StudentUncheckedCreateNestedManyWithoutCollegesInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutCollegesInput
  }

  export type CollegeCreateOrConnectWithoutAcademic_yearsInput = {
    where: CollegeWhereUniqueInput
    create: XOR<CollegeCreateWithoutAcademic_yearsInput, CollegeUncheckedCreateWithoutAcademic_yearsInput>
  }

  export type CourseOfferingCreateWithoutAcademic_yearsInput = {
    id?: string
    semester?: number | null
    attendances?: AttendanceCreateNestedManyWithoutOfferingInput
    course: CourseCreateNestedOneWithoutCourseOfferingsInput
    sections?: sectionsCreateNestedOneWithoutCourse_offeringsInput
    teacher?: TeacherCreateNestedOneWithoutCourseOfferingsInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutAcademic_yearsInput = {
    id?: string
    courseId: string
    teacherId?: string | null
    section_id?: string | null
    semester?: number | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOfferingInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentUncheckedCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutAcademic_yearsInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutAcademic_yearsInput, CourseOfferingUncheckedCreateWithoutAcademic_yearsInput>
  }

  export type CourseOfferingCreateManyAcademic_yearsInputEnvelope = {
    data: CourseOfferingCreateManyAcademic_yearsInput | CourseOfferingCreateManyAcademic_yearsInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrollmentCreateWithoutAcademic_yearsInput = {
    id?: string
    attemptNumber?: number | null
    offering?: CourseOfferingCreateNestedOneWithoutEnrollmentsInput
    student?: StudentCreateNestedOneWithoutEnrollmentsInput
    studentMarks?: StudentMarkCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput = {
    id?: string
    studentId?: string | null
    offeringId?: string | null
    attemptNumber?: number | null
    studentMarks?: StudentMarkUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type StudentEnrollmentCreateOrConnectWithoutAcademic_yearsInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutAcademic_yearsInput, StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput>
  }

  export type StudentEnrollmentCreateManyAcademic_yearsInputEnvelope = {
    data: StudentEnrollmentCreateManyAcademic_yearsInput | StudentEnrollmentCreateManyAcademic_yearsInput[]
    skipDuplicates?: boolean
  }

  export type CollegeUpsertWithoutAcademic_yearsInput = {
    update: XOR<CollegeUpdateWithoutAcademic_yearsInput, CollegeUncheckedUpdateWithoutAcademic_yearsInput>
    create: XOR<CollegeCreateWithoutAcademic_yearsInput, CollegeUncheckedCreateWithoutAcademic_yearsInput>
    where?: CollegeWhereInput
  }

  export type CollegeUpdateToOneWithWhereWithoutAcademic_yearsInput = {
    where?: CollegeWhereInput
    data: XOR<CollegeUpdateWithoutAcademic_yearsInput, CollegeUncheckedUpdateWithoutAcademic_yearsInput>
  }

  export type CollegeUpdateWithoutAcademic_yearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUpdateManyWithoutCollegesNestedInput
    students?: StudentUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUpdateManyWithoutCollegesNestedInput
  }

  export type CollegeUncheckedUpdateWithoutAcademic_yearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutCollegesNestedInput
    department_elective_groups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutCollegesNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutCollegesNestedInput
    students?: StudentUncheckedUpdateManyWithoutCollegesNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutCollegesNestedInput
  }

  export type CourseOfferingUpsertWithWhereUniqueWithoutAcademic_yearsInput = {
    where: CourseOfferingWhereUniqueInput
    update: XOR<CourseOfferingUpdateWithoutAcademic_yearsInput, CourseOfferingUncheckedUpdateWithoutAcademic_yearsInput>
    create: XOR<CourseOfferingCreateWithoutAcademic_yearsInput, CourseOfferingUncheckedCreateWithoutAcademic_yearsInput>
  }

  export type CourseOfferingUpdateWithWhereUniqueWithoutAcademic_yearsInput = {
    where: CourseOfferingWhereUniqueInput
    data: XOR<CourseOfferingUpdateWithoutAcademic_yearsInput, CourseOfferingUncheckedUpdateWithoutAcademic_yearsInput>
  }

  export type CourseOfferingUpdateManyWithWhereWithoutAcademic_yearsInput = {
    where: CourseOfferingScalarWhereInput
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyWithoutAcademic_yearsInput>
  }

  export type StudentEnrollmentUpsertWithWhereUniqueWithoutAcademic_yearsInput = {
    where: StudentEnrollmentWhereUniqueInput
    update: XOR<StudentEnrollmentUpdateWithoutAcademic_yearsInput, StudentEnrollmentUncheckedUpdateWithoutAcademic_yearsInput>
    create: XOR<StudentEnrollmentCreateWithoutAcademic_yearsInput, StudentEnrollmentUncheckedCreateWithoutAcademic_yearsInput>
  }

  export type StudentEnrollmentUpdateWithWhereUniqueWithoutAcademic_yearsInput = {
    where: StudentEnrollmentWhereUniqueInput
    data: XOR<StudentEnrollmentUpdateWithoutAcademic_yearsInput, StudentEnrollmentUncheckedUpdateWithoutAcademic_yearsInput>
  }

  export type StudentEnrollmentUpdateManyWithWhereWithoutAcademic_yearsInput = {
    where: StudentEnrollmentScalarWhereInput
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyWithoutAcademic_yearsInput>
  }

  export type CourseOfferingCreateWithoutSectionsInput = {
    id?: string
    semester?: number | null
    attendances?: AttendanceCreateNestedManyWithoutOfferingInput
    course: CourseCreateNestedOneWithoutCourseOfferingsInput
    teacher?: TeacherCreateNestedOneWithoutCourseOfferingsInput
    academic_years?: academic_yearsCreateNestedOneWithoutCourse_offeringsInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutSectionsInput = {
    id?: string
    courseId: string
    teacherId?: string | null
    year_id?: string | null
    semester?: number | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOfferingInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutOfferingInput
    testComponents?: TestComponentUncheckedCreateNestedManyWithoutCourseOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutSectionsInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutSectionsInput, CourseOfferingUncheckedCreateWithoutSectionsInput>
  }

  export type CourseOfferingCreateManySectionsInputEnvelope = {
    data: CourseOfferingCreateManySectionsInput | CourseOfferingCreateManySectionsInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutSectionsInput = {
    id?: string
    name: string
    code?: string | null
    courses?: CourseCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupCreateNestedManyWithoutDepartmentInput
    colleges: CollegeCreateNestedOneWithoutDepartmentsInput
    openElectiveRestrictions?: OpenElectiveRestrictionCreateNestedManyWithoutRestrictedDepartmentInput
    students?: StudentCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutSectionsInput = {
    id?: string
    college_id: string
    name: string
    code?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutDepartmentInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedCreateNestedManyWithoutDepartmentInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedCreateNestedManyWithoutRestrictedDepartmentInput
    students?: StudentUncheckedCreateNestedManyWithoutDepartmentsInput
    teachers?: TeacherUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutSectionsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutSectionsInput, DepartmentUncheckedCreateWithoutSectionsInput>
  }

  export type StudentCreateWithoutSectionsInput = {
    id?: string
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    colleges: CollegeCreateNestedOneWithoutStudentsInput
    departments?: DepartmentCreateNestedOneWithoutStudentsInput
    user: UserCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSectionsInput = {
    id?: string
    userId: string
    college_id: string
    department_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSectionsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSectionsInput, StudentUncheckedCreateWithoutSectionsInput>
  }

  export type StudentCreateManySectionsInputEnvelope = {
    data: StudentCreateManySectionsInput | StudentCreateManySectionsInput[]
    skipDuplicates?: boolean
  }

  export type CourseOfferingUpsertWithWhereUniqueWithoutSectionsInput = {
    where: CourseOfferingWhereUniqueInput
    update: XOR<CourseOfferingUpdateWithoutSectionsInput, CourseOfferingUncheckedUpdateWithoutSectionsInput>
    create: XOR<CourseOfferingCreateWithoutSectionsInput, CourseOfferingUncheckedCreateWithoutSectionsInput>
  }

  export type CourseOfferingUpdateWithWhereUniqueWithoutSectionsInput = {
    where: CourseOfferingWhereUniqueInput
    data: XOR<CourseOfferingUpdateWithoutSectionsInput, CourseOfferingUncheckedUpdateWithoutSectionsInput>
  }

  export type CourseOfferingUpdateManyWithWhereWithoutSectionsInput = {
    where: CourseOfferingScalarWhereInput
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyWithoutSectionsInput>
  }

  export type DepartmentUpsertWithoutSectionsInput = {
    update: XOR<DepartmentUpdateWithoutSectionsInput, DepartmentUncheckedUpdateWithoutSectionsInput>
    create: XOR<DepartmentCreateWithoutSectionsInput, DepartmentUncheckedCreateWithoutSectionsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutSectionsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutSectionsInput, DepartmentUncheckedUpdateWithoutSectionsInput>
  }

  export type DepartmentUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUpdateManyWithoutDepartmentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutDepartmentsNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutRestrictedDepartmentNestedInput
    students?: StudentUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentNestedInput
    students?: StudentUncheckedUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutSectionsInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutSectionsInput, StudentUncheckedUpdateWithoutSectionsInput>
    create: XOR<StudentCreateWithoutSectionsInput, StudentUncheckedCreateWithoutSectionsInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutSectionsInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutSectionsInput, StudentUncheckedUpdateWithoutSectionsInput>
  }

  export type StudentUpdateManyWithWhereWithoutSectionsInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutSectionsInput>
  }

  export type CourseOfferingCreateWithoutTestComponentsInput = {
    id?: string
    semester?: number | null
    attendances?: AttendanceCreateNestedManyWithoutOfferingInput
    course: CourseCreateNestedOneWithoutCourseOfferingsInput
    sections?: sectionsCreateNestedOneWithoutCourse_offeringsInput
    teacher?: TeacherCreateNestedOneWithoutCourseOfferingsInput
    academic_years?: academic_yearsCreateNestedOneWithoutCourse_offeringsInput
    enrollments?: StudentEnrollmentCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutTestComponentsInput = {
    id?: string
    courseId: string
    teacherId?: string | null
    section_id?: string | null
    year_id?: string | null
    semester?: number | null
    attendances?: AttendanceUncheckedCreateNestedManyWithoutOfferingInput
    enrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutTestComponentsInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutTestComponentsInput, CourseOfferingUncheckedCreateWithoutTestComponentsInput>
  }

  export type StudentMarkCreateWithoutTestComponentInput = {
    id?: string
    marksObtained?: number | null
    enrollment: StudentEnrollmentCreateNestedOneWithoutStudentMarksInput
  }

  export type StudentMarkUncheckedCreateWithoutTestComponentInput = {
    id?: string
    enrollmentId: string
    marksObtained?: number | null
  }

  export type StudentMarkCreateOrConnectWithoutTestComponentInput = {
    where: StudentMarkWhereUniqueInput
    create: XOR<StudentMarkCreateWithoutTestComponentInput, StudentMarkUncheckedCreateWithoutTestComponentInput>
  }

  export type StudentMarkCreateManyTestComponentInputEnvelope = {
    data: StudentMarkCreateManyTestComponentInput | StudentMarkCreateManyTestComponentInput[]
    skipDuplicates?: boolean
  }

  export type CourseOfferingUpsertWithoutTestComponentsInput = {
    update: XOR<CourseOfferingUpdateWithoutTestComponentsInput, CourseOfferingUncheckedUpdateWithoutTestComponentsInput>
    create: XOR<CourseOfferingCreateWithoutTestComponentsInput, CourseOfferingUncheckedCreateWithoutTestComponentsInput>
    where?: CourseOfferingWhereInput
  }

  export type CourseOfferingUpdateToOneWithWhereWithoutTestComponentsInput = {
    where?: CourseOfferingWhereInput
    data: XOR<CourseOfferingUpdateWithoutTestComponentsInput, CourseOfferingUncheckedUpdateWithoutTestComponentsInput>
  }

  export type CourseOfferingUpdateWithoutTestComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUpdateManyWithoutOfferingNestedInput
    course?: CourseUpdateOneRequiredWithoutCourseOfferingsNestedInput
    sections?: sectionsUpdateOneWithoutCourse_offeringsNestedInput
    teacher?: TeacherUpdateOneWithoutCourseOfferingsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutCourse_offeringsNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutTestComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUncheckedUpdateManyWithoutOfferingNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
  }

  export type StudentMarkUpsertWithWhereUniqueWithoutTestComponentInput = {
    where: StudentMarkWhereUniqueInput
    update: XOR<StudentMarkUpdateWithoutTestComponentInput, StudentMarkUncheckedUpdateWithoutTestComponentInput>
    create: XOR<StudentMarkCreateWithoutTestComponentInput, StudentMarkUncheckedCreateWithoutTestComponentInput>
  }

  export type StudentMarkUpdateWithWhereUniqueWithoutTestComponentInput = {
    where: StudentMarkWhereUniqueInput
    data: XOR<StudentMarkUpdateWithoutTestComponentInput, StudentMarkUncheckedUpdateWithoutTestComponentInput>
  }

  export type StudentMarkUpdateManyWithWhereWithoutTestComponentInput = {
    where: StudentMarkScalarWhereInput
    data: XOR<StudentMarkUpdateManyMutationInput, StudentMarkUncheckedUpdateManyWithoutTestComponentInput>
  }

  export type StudentEnrollmentCreateWithoutStudentMarksInput = {
    id?: string
    attemptNumber?: number | null
    offering?: CourseOfferingCreateNestedOneWithoutEnrollmentsInput
    student?: StudentCreateNestedOneWithoutEnrollmentsInput
    academic_years?: academic_yearsCreateNestedOneWithoutStudent_enrollmentsInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutStudentMarksInput = {
    id?: string
    studentId?: string | null
    offeringId?: string | null
    attemptNumber?: number | null
    year_id?: string | null
  }

  export type StudentEnrollmentCreateOrConnectWithoutStudentMarksInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutStudentMarksInput, StudentEnrollmentUncheckedCreateWithoutStudentMarksInput>
  }

  export type TestComponentCreateWithoutStudentMarksInput = {
    id?: string
    name: string
    maxMarks: number
    weightage?: number
    courseOffering: CourseOfferingCreateNestedOneWithoutTestComponentsInput
  }

  export type TestComponentUncheckedCreateWithoutStudentMarksInput = {
    id?: string
    courseOfferingId: string
    name: string
    maxMarks: number
    weightage?: number
  }

  export type TestComponentCreateOrConnectWithoutStudentMarksInput = {
    where: TestComponentWhereUniqueInput
    create: XOR<TestComponentCreateWithoutStudentMarksInput, TestComponentUncheckedCreateWithoutStudentMarksInput>
  }

  export type StudentEnrollmentUpsertWithoutStudentMarksInput = {
    update: XOR<StudentEnrollmentUpdateWithoutStudentMarksInput, StudentEnrollmentUncheckedUpdateWithoutStudentMarksInput>
    create: XOR<StudentEnrollmentCreateWithoutStudentMarksInput, StudentEnrollmentUncheckedCreateWithoutStudentMarksInput>
    where?: StudentEnrollmentWhereInput
  }

  export type StudentEnrollmentUpdateToOneWithWhereWithoutStudentMarksInput = {
    where?: StudentEnrollmentWhereInput
    data: XOR<StudentEnrollmentUpdateWithoutStudentMarksInput, StudentEnrollmentUncheckedUpdateWithoutStudentMarksInput>
  }

  export type StudentEnrollmentUpdateWithoutStudentMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    offering?: CourseOfferingUpdateOneWithoutEnrollmentsNestedInput
    student?: StudentUpdateOneWithoutEnrollmentsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutStudent_enrollmentsNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutStudentMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestComponentUpsertWithoutStudentMarksInput = {
    update: XOR<TestComponentUpdateWithoutStudentMarksInput, TestComponentUncheckedUpdateWithoutStudentMarksInput>
    create: XOR<TestComponentCreateWithoutStudentMarksInput, TestComponentUncheckedCreateWithoutStudentMarksInput>
    where?: TestComponentWhereInput
  }

  export type TestComponentUpdateToOneWithWhereWithoutStudentMarksInput = {
    where?: TestComponentWhereInput
    data: XOR<TestComponentUpdateWithoutStudentMarksInput, TestComponentUncheckedUpdateWithoutStudentMarksInput>
  }

  export type TestComponentUpdateWithoutStudentMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    maxMarks?: IntFieldUpdateOperationsInput | number
    weightage?: IntFieldUpdateOperationsInput | number
    courseOffering?: CourseOfferingUpdateOneRequiredWithoutTestComponentsNestedInput
  }

  export type TestComponentUncheckedUpdateWithoutStudentMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseOfferingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    maxMarks?: IntFieldUpdateOperationsInput | number
    weightage?: IntFieldUpdateOperationsInput | number
  }

  export type academic_yearsCreateManyCollegesInput = {
    year_id?: string
    year_name: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
  }

  export type CourseCreateManyCollegesInput = {
    id?: string
    code: string
    name: string
    departmentId?: string | null
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
  }

  export type DepartmentElectiveGroupCreateManyCollegesInput = {
    id?: string
    name: string
    departmentId: string
    semester: number
    batchYear: number
  }

  export type DepartmentCreateManyCollegesInput = {
    id?: string
    name: string
    code?: string | null
  }

  export type StudentCreateManyCollegesInput = {
    id?: string
    userId: string
    department_id?: string | null
    section_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
  }

  export type TeacherCreateManyCollegesInput = {
    id?: string
    userId: string
    departmentId?: string | null
  }

  export type academic_yearsUpdateWithoutCollegesInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    course_offerings?: CourseOfferingUpdateManyWithoutAcademic_yearsNestedInput
    student_enrollments?: StudentEnrollmentUpdateManyWithoutAcademic_yearsNestedInput
  }

  export type academic_yearsUncheckedUpdateWithoutCollegesInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    course_offerings?: CourseOfferingUncheckedUpdateManyWithoutAcademic_yearsNestedInput
    student_enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutAcademic_yearsNestedInput
  }

  export type academic_yearsUncheckedUpdateManyWithoutCollegesInput = {
    year_id?: StringFieldUpdateOperationsInput | string
    year_name?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CourseUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUpdateManyWithoutCourseNestedInput
    courseOfferings?: CourseOfferingUpdateManyWithoutCourseNestedInput
    department?: DepartmentUpdateOneWithoutCoursesNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedUpdateManyWithoutCourseNestedInput
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutCourseNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DepartmentElectiveGroupUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUpdateManyWithoutGroupNestedInput
    department?: DepartmentUpdateOneRequiredWithoutDepartmentElectiveGroupsNestedInput
  }

  export type DepartmentElectiveGroupUncheckedUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type DepartmentElectiveGroupUncheckedUpdateManyWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUpdateManyWithoutDepartmentNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentElectiveGroups?: DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentNestedInput
    sections?: sectionsUncheckedUpdateManyWithoutDepartmentsNestedInput
    students?: StudentUncheckedUpdateManyWithoutDepartmentsNestedInput
    teachers?: TeacherUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    departments?: DepartmentUpdateOneWithoutStudentsNestedInput
    sections?: sectionsUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendances?: AttendanceUpdateManyWithoutTeacherNestedInput
    courseOfferings?: CourseOfferingUpdateManyWithoutTeacherNestedInput
    department?: DepartmentUpdateOneWithoutTeachersNestedInput
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    attendances?: AttendanceUncheckedUpdateManyWithoutTeacherNestedInput
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateManyWithoutCollegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseCreateManyDepartmentInput = {
    id?: string
    college_id: string
    code: string
    name: string
    type?: $Enums.course_type | null
    hasTheoryComponent?: boolean
    hasLabComponent?: boolean
  }

  export type DepartmentElectiveGroupCreateManyDepartmentInput = {
    id?: string
    college_id: string
    name: string
    semester: number
    batchYear: number
  }

  export type OpenElectiveRestrictionCreateManyRestrictedDepartmentInput = {
    id?: string
    courseId?: string | null
  }

  export type sectionsCreateManyDepartmentsInput = {
    section_id?: string
    section_name: string
  }

  export type StudentCreateManyDepartmentsInput = {
    id?: string
    userId: string
    college_id: string
    section_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
  }

  export type TeacherCreateManyDepartmentInput = {
    id?: string
    userId: string
    college_id: string
  }

  export type CourseUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUpdateManyWithoutCourseNestedInput
    courseOfferings?: CourseOfferingUpdateManyWithoutCourseNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutCoursesNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedUpdateManyWithoutCourseNestedInput
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutCourseNestedInput
    openElectiveRestrictions?: OpenElectiveRestrictionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumcourse_typeFieldUpdateOperationsInput | $Enums.course_type | null
    hasTheoryComponent?: BoolFieldUpdateOperationsInput | boolean
    hasLabComponent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DepartmentElectiveGroupUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUpdateManyWithoutGroupNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutDepartment_elective_groupsNestedInput
  }

  export type DepartmentElectiveGroupUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
    courseElectiveGroupMembers?: CourseElectiveGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type DepartmentElectiveGroupUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type OpenElectiveRestrictionUpdateWithoutRestrictedDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneWithoutOpenElectiveRestrictionsNestedInput
  }

  export type OpenElectiveRestrictionUncheckedUpdateWithoutRestrictedDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpenElectiveRestrictionUncheckedUpdateManyWithoutRestrictedDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sectionsUpdateWithoutDepartmentsInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    course_offerings?: CourseOfferingUpdateManyWithoutSectionsNestedInput
    students?: StudentUpdateManyWithoutSectionsNestedInput
  }

  export type sectionsUncheckedUpdateWithoutDepartmentsInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    course_offerings?: CourseOfferingUncheckedUpdateManyWithoutSectionsNestedInput
    students?: StudentUncheckedUpdateManyWithoutSectionsNestedInput
  }

  export type sectionsUncheckedUpdateManyWithoutDepartmentsInput = {
    section_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutStudentsNestedInput
    sections?: sectionsUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendances?: AttendanceUpdateManyWithoutTeacherNestedInput
    courseOfferings?: CourseOfferingUpdateManyWithoutTeacherNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutTeachersNestedInput
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    attendances?: AttendanceUncheckedUpdateManyWithoutTeacherNestedInput
    courseOfferings?: CourseOfferingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleAssignmentCreateManyUserInput = {
    role: $Enums.user_role
  }

  export type UserRoleAssignmentUpdateWithoutUserInput = {
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
  }

  export type UserRoleAssignmentUncheckedUpdateWithoutUserInput = {
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
  }

  export type UserRoleAssignmentUncheckedUpdateManyWithoutUserInput = {
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
  }

  export type AttendanceRecordCreateManyStudentInput = {
    id?: string
    attendanceId?: string | null
    status?: $Enums.attendance_status | null
  }

  export type StudentEnrollmentCreateManyStudentInput = {
    id?: string
    offeringId?: string | null
    attemptNumber?: number | null
    year_id?: string | null
  }

  export type AttendanceRecordUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    attendance?: AttendanceUpdateOneWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
  }

  export type StudentEnrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    offering?: CourseOfferingUpdateOneWithoutEnrollmentsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutStudent_enrollmentsNestedInput
    studentMarks?: StudentMarkUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    studentMarks?: StudentMarkUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceCreateManyTeacherInput = {
    id?: string
    offeringId?: string | null
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
  }

  export type CourseOfferingCreateManyTeacherInput = {
    id?: string
    courseId: string
    section_id?: string | null
    year_id?: string | null
    semester?: number | null
  }

  export type AttendanceUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    offering?: CourseOfferingUpdateOneWithoutAttendancesNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseOfferingUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUpdateManyWithoutOfferingNestedInput
    course?: CourseUpdateOneRequiredWithoutCourseOfferingsNestedInput
    sections?: sectionsUpdateOneWithoutCourse_offeringsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutCourse_offeringsNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUncheckedUpdateManyWithoutOfferingNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUncheckedUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseElectiveGroupMemberCreateManyCourseInput = {
    groupId: string
  }

  export type CourseOfferingCreateManyCourseInput = {
    id?: string
    teacherId?: string | null
    section_id?: string | null
    year_id?: string | null
    semester?: number | null
  }

  export type OpenElectiveRestrictionCreateManyCourseInput = {
    id?: string
    restrictedDepartmentId: string
  }

  export type CourseElectiveGroupMemberUpdateWithoutCourseInput = {
    group?: DepartmentElectiveGroupUpdateOneRequiredWithoutCourseElectiveGroupMembersNestedInput
  }

  export type CourseElectiveGroupMemberUncheckedUpdateWithoutCourseInput = {
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseElectiveGroupMemberUncheckedUpdateManyWithoutCourseInput = {
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseOfferingUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUpdateManyWithoutOfferingNestedInput
    sections?: sectionsUpdateOneWithoutCourse_offeringsNestedInput
    teacher?: TeacherUpdateOneWithoutCourseOfferingsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutCourse_offeringsNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUncheckedUpdateManyWithoutOfferingNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUncheckedUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OpenElectiveRestrictionUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    restrictedDepartment?: DepartmentUpdateOneRequiredWithoutOpenElectiveRestrictionsNestedInput
  }

  export type OpenElectiveRestrictionUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    restrictedDepartmentId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenElectiveRestrictionUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    restrictedDepartmentId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseElectiveGroupMemberCreateManyGroupInput = {
    courseId: string
  }

  export type CourseElectiveGroupMemberUpdateWithoutGroupInput = {
    course?: CourseUpdateOneRequiredWithoutCourseElectiveGroupMembersNestedInput
  }

  export type CourseElectiveGroupMemberUncheckedUpdateWithoutGroupInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseElectiveGroupMemberUncheckedUpdateManyWithoutGroupInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceCreateManyOfferingInput = {
    id?: string
    teacherId?: string | null
    classDate: Date | string
    periodNumber?: number | null
    syllabusCovered?: string | null
    status?: string | null
  }

  export type StudentEnrollmentCreateManyOfferingInput = {
    id?: string
    studentId?: string | null
    attemptNumber?: number | null
    year_id?: string | null
  }

  export type TestComponentCreateManyCourseOfferingInput = {
    id?: string
    name: string
    maxMarks: number
    weightage?: number
  }

  export type AttendanceUpdateWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    teacher?: TeacherUpdateOneWithoutAttendancesNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateManyWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    classDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodNumber?: NullableIntFieldUpdateOperationsInput | number | null
    syllabusCovered?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentEnrollmentUpdateWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneWithoutEnrollmentsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutStudent_enrollmentsNestedInput
    studentMarks?: StudentMarkUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    studentMarks?: StudentMarkUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestComponentUpdateWithoutCourseOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    maxMarks?: IntFieldUpdateOperationsInput | number
    weightage?: IntFieldUpdateOperationsInput | number
    studentMarks?: StudentMarkUpdateManyWithoutTestComponentNestedInput
  }

  export type TestComponentUncheckedUpdateWithoutCourseOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    maxMarks?: IntFieldUpdateOperationsInput | number
    weightage?: IntFieldUpdateOperationsInput | number
    studentMarks?: StudentMarkUncheckedUpdateManyWithoutTestComponentNestedInput
  }

  export type TestComponentUncheckedUpdateManyWithoutCourseOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    maxMarks?: IntFieldUpdateOperationsInput | number
    weightage?: IntFieldUpdateOperationsInput | number
  }

  export type StudentMarkCreateManyEnrollmentInput = {
    id?: string
    testComponentId: string
    marksObtained?: number | null
  }

  export type StudentMarkUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
    testComponent?: TestComponentUpdateOneRequiredWithoutStudentMarksNestedInput
  }

  export type StudentMarkUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    testComponentId?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentMarkUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    testComponentId?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttendanceRecordCreateManyAttendanceInput = {
    id?: string
    studentId?: string | null
    status?: $Enums.attendance_status | null
  }

  export type AttendanceRecordUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    student?: StudentUpdateOneWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
  }

  export type CourseOfferingCreateManyAcademic_yearsInput = {
    id?: string
    courseId: string
    teacherId?: string | null
    section_id?: string | null
    semester?: number | null
  }

  export type StudentEnrollmentCreateManyAcademic_yearsInput = {
    id?: string
    studentId?: string | null
    offeringId?: string | null
    attemptNumber?: number | null
  }

  export type CourseOfferingUpdateWithoutAcademic_yearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUpdateManyWithoutOfferingNestedInput
    course?: CourseUpdateOneRequiredWithoutCourseOfferingsNestedInput
    sections?: sectionsUpdateOneWithoutCourse_offeringsNestedInput
    teacher?: TeacherUpdateOneWithoutCourseOfferingsNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutAcademic_yearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUncheckedUpdateManyWithoutOfferingNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUncheckedUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateManyWithoutAcademic_yearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    section_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentEnrollmentUpdateWithoutAcademic_yearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    offering?: CourseOfferingUpdateOneWithoutEnrollmentsNestedInput
    student?: StudentUpdateOneWithoutEnrollmentsNestedInput
    studentMarks?: StudentMarkUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutAcademic_yearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
    studentMarks?: StudentMarkUncheckedUpdateManyWithoutEnrollmentNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutAcademic_yearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    offeringId?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseOfferingCreateManySectionsInput = {
    id?: string
    courseId: string
    teacherId?: string | null
    year_id?: string | null
    semester?: number | null
  }

  export type StudentCreateManySectionsInput = {
    id?: string
    userId: string
    college_id: string
    department_id?: string | null
    usn: string
    semester?: number | null
    batchYear: number
  }

  export type CourseOfferingUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUpdateManyWithoutOfferingNestedInput
    course?: CourseUpdateOneRequiredWithoutCourseOfferingsNestedInput
    teacher?: TeacherUpdateOneWithoutCourseOfferingsNestedInput
    academic_years?: academic_yearsUpdateOneWithoutCourse_offeringsNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    attendances?: AttendanceUncheckedUpdateManyWithoutOfferingNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
    testComponents?: TestComponentUncheckedUpdateManyWithoutCourseOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateManyWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    year_id?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    colleges?: CollegeUpdateOneRequiredWithoutStudentsNestedInput
    departments?: DepartmentUpdateOneWithoutStudentsNestedInput
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    college_id?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    usn?: StringFieldUpdateOperationsInput | string
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    batchYear?: IntFieldUpdateOperationsInput | number
  }

  export type StudentMarkCreateManyTestComponentInput = {
    id?: string
    enrollmentId: string
    marksObtained?: number | null
  }

  export type StudentMarkUpdateWithoutTestComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
    enrollment?: StudentEnrollmentUpdateOneRequiredWithoutStudentMarksNestedInput
  }

  export type StudentMarkUncheckedUpdateWithoutTestComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentMarkUncheckedUpdateManyWithoutTestComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    marksObtained?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}